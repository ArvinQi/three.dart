        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Projector class / three Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="three" data-type="Projector">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../three.html">three</a> &rsaquo; <a href="../three/Projector.html">Projector</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../CurveUtils.html">CurveUtils</a></h2><h2><div class="icon-library"></div><a href="../FirstPersonControls.html">FirstPersonControls</a></h2><h2><div class="icon-library"></div><a href="../FontUtils.html">FontUtils</a></h2><h2><div class="icon-library"></div><a href="../GeometryUtils.html">GeometryUtils</a></h2><h2><div class="icon-library"></div><a href="../ImageUtils.html">ImageUtils</a></h2><h2><div class="icon-library"></div><a href="../SceneUtils.html">SceneUtils</a></h2><h2><div class="icon-library"></div><a href="../ShaderUtils.html">ShaderUtils</a></h2><h2><div class="icon-library"></div><a href="../ShapeUtils.html">ShapeUtils</a></h2><h2><div class="icon-library"></div><a href="../three.html">three</a></h2><ul class="icon">
<li><a href="../three/AmbientLight.html"><div class="icon-class"></div>AmbientLight</a></li>
<li><a href="../three/ArcCurve.html"><div class="icon-class"></div>ArcCurve</a></li>
<li><a href="../three/ArrowHelper.html"><div class="icon-class"></div>ArrowHelper</a></li>
<li><a href="../three/Attribute.html"><div class="icon-class"></div>Attribute&lt;T&gt;</a></li>
<li><a href="../three/AxisHelper.html"><div class="icon-class"></div>AxisHelper</a></li>
<li><a href="../three/Bone.html"><div class="icon-class"></div>Bone</a></li>
<li><a href="../three/BoundingBox.html"><div class="icon-class"></div>BoundingBox</a></li>
<li><a href="../three/BoundingSphere.html"><div class="icon-class"></div>BoundingSphere</a></li>
<li><a href="../three/Buffer.html"><div class="icon-class"></div>Buffer</a></li>
<li><a href="../three/BufferGeometry.html"><div class="icon-class"></div>BufferGeometry</a></li>
<li><a href="../three/Camera.html"><div class="icon-class"></div>Camera</a></li>
<li><a href="../three/CameraHelper.html"><div class="icon-class"></div>CameraHelper</a></li>
<li><a href="../three/CanvasRenderData.html"><div class="icon-class"></div>CanvasRenderData</a></li>
<li><a href="../three/CanvasRenderer.html"><div class="icon-class"></div>CanvasRenderer</a></li>
<li><a href="../three/Chunk.html"><div class="icon-class"></div>Chunk</a></li>
<li><a href="../three/CircleGeometry.html"><div class="icon-class"></div>CircleGeometry</a></li>
<li><a href="../three/ClosedSplineCurve3.html"><div class="icon-class"></div>ClosedSplineCurve3</a></li>
<li><a href="../three/Color.html"><div class="icon-class"></div>Color</a></li>
<li><a href="../three/CompressedTexture.html"><div class="icon-class"></div>CompressedTexture</a></li>
<li><a href="../three/ConvexGeometry.html"><div class="icon-class"></div>ConvexGeometry</a></li>
<li><a href="../three/CSS3DObject.html"><div class="icon-class"></div>CSS3DObject</a></li>
<li><a href="../three/CSS3DRenderer.html"><div class="icon-class"></div>CSS3DRenderer</a></li>
<li><a href="../three/CubeGeometry.html"><div class="icon-class"></div>CubeGeometry</a></li>
<li><a href="../three/CubeGeomSides.html"><div class="icon-class"></div>CubeGeomSides</a></li>
<li><a href="../three/CubeReflectionMapping.html"><div class="icon-class"></div>CubeReflectionMapping</a></li>
<li><a href="../three/CubeRefractionMapping.html"><div class="icon-class"></div>CubeRefractionMapping</a></li>
<li><a href="../three/CubicBezierCurve.html"><div class="icon-class"></div>CubicBezierCurve</a></li>
<li><a href="../three/CubicBezierCurve3.html"><div class="icon-class"></div>CubicBezierCurve3</a></li>
<li><a href="../three/Curve.html"><div class="icon-class"></div>Curve&lt;V&gt;</a></li>
<li><a href="../three/Curve2D.html"><div class="icon-class"></div>Curve2D</a></li>
<li><a href="../three/Curve3D.html"><div class="icon-class"></div>Curve3D</a></li>
<li><a href="../three/CurvePath.html"><div class="icon-class"></div>CurvePath</a></li>
<li><a href="../three/CylinderGeometry.html"><div class="icon-class"></div>CylinderGeometry</a></li>
<li><a href="../three/DataTexture.html"><div class="icon-class"></div>DataTexture</a></li>
<li><a href="../three/DirectionalLight.html"><div class="icon-class"></div>DirectionalLight</a></li>
<li><a href="../three/EllipseCurve.html"><div class="icon-class"></div>EllipseCurve</a></li>
<li><a href="../three/EventEmitter.html"><div class="icon-class"></div>EventEmitter</a></li>
<li><a href="../three/EventEmitterEvent.html"><div class="icon-class"></div>EventEmitterEvent</a></li>
<li><a href="../three/ExtrudeGeometry.html"><div class="icon-class"></div>ExtrudeGeometry</a></li>
<li><a href="../three/ExtrudeGeometryWorldUVGenerator.html"><div class="icon-class"></div>ExtrudeGeometryWorldUVGenerator</a></li>
<li><a href="../three/Face.html"><div class="icon-class"></div>Face</a></li>
<li><a href="../three/Face3.html"><div class="icon-class"></div>Face3</a></li>
<li><a href="../three/Face4.html"><div class="icon-class"></div>Face4</a></li>
<li><a href="../three/Fog.html"><div class="icon-class"></div>Fog</a></li>
<li><a href="../three/FogExp2.html"><div class="icon-class"></div>FogExp2</a></li>
<li><a href="../three/FogLinear.html"><div class="icon-class"></div>FogLinear</a></li>
<li><a href="../three/Frustum.html"><div class="icon-class"></div>Frustum</a></li>
<li><a href="../three/Geometry.html"><div class="icon-class"></div>Geometry</a></li>
<li><a href="../three/GeometryAttribute.html"><div class="icon-class"></div>GeometryAttribute&lt;T&gt;</a></li>
<li><a href="../three/Gyroscope.html"><div class="icon-class"></div>Gyroscope</a></li>
<li><a href="../three/HemisphereLight.html"><div class="icon-class"></div>HemisphereLight</a></li>
<li><a href="../three/IcosahedronGeometry.html"><div class="icon-class"></div>IcosahedronGeometry</a></li>
<li><a href="../three/ImageList.html"><div class="icon-class"></div>ImageList</a></li>
<li><a href="../three/ImageLoader.html"><div class="icon-class"></div>ImageLoader</a></li>
<li><a href="../three/IMaterial.html"><div class="icon-class"></div>IMaterial</a></li>
<li><a href="../three/ImmediateRenderObject.html"><div class="icon-class"></div>ImmediateRenderObject</a></li>
<li><a href="../three/Intersect.html"><div class="icon-class"></div>Intersect</a></li>
<li><a href="../three/IParticleMaterial.html"><div class="icon-class"></div>IParticleMaterial</a></li>
<li><a href="../three/IRenderable.html"><div class="icon-class"></div>IRenderable</a></li>
<li><a href="../three/ITextureMapMaterial.html"><div class="icon-class"></div>ITextureMapMaterial</a></li>
<li><a href="../three/JSONLoader.html"><div class="icon-class"></div>JSONLoader</a></li>
<li><a href="../three/LatheGeometry.html"><div class="icon-class"></div>LatheGeometry</a></li>
<li><a href="../three/LensFlare.html"><div class="icon-class"></div>LensFlare</a></li>
<li><a href="../three/Light.html"><div class="icon-class"></div>Light</a></li>
<li><a href="../three/Line.html"><div class="icon-class"></div>Line</a></li>
<li><a href="../three/LineBasicMaterial.html"><div class="icon-class"></div>LineBasicMaterial</a></li>
<li><a href="../three/LineCurve.html"><div class="icon-class"></div>LineCurve</a></li>
<li><a href="../three/LineCurve3.html"><div class="icon-class"></div>LineCurve3</a></li>
<li><a href="../three/LoadCompleteCallback.html"><div class="icon-interface"></div>LoadCompleteCallback</a></li>
<li><a href="../three/LoadedCallback.html"><div class="icon-interface"></div>LoadedCallback</a></li>
<li><a href="../three/Loader.html"><div class="icon-class"></div>Loader</a></li>
<li><a href="../three/LoadProgressCallback.html"><div class="icon-interface"></div>LoadProgressCallback</a></li>
<li><a href="../three/LoadStartCallback.html"><div class="icon-interface"></div>LoadStartCallback</a></li>
<li><a href="../three/LOD.html"><div class="icon-class"></div>LOD</a></li>
<li><a href="../three/Material.html"><div class="icon-class"></div>Material</a></li>
<li><a href="../three/Mesh.html"><div class="icon-class"></div>Mesh</a></li>
<li><a href="../three/MeshBasicMaterial.html"><div class="icon-class"></div>MeshBasicMaterial</a></li>
<li><a href="../three/MeshDepthMaterial.html"><div class="icon-class"></div>MeshDepthMaterial</a></li>
<li><a href="../three/MeshFaceMaterial.html"><div class="icon-class"></div>MeshFaceMaterial</a></li>
<li><a href="../three/MeshLambertMaterial.html"><div class="icon-class"></div>MeshLambertMaterial</a></li>
<li><a href="../three/MeshNormalMaterial.html"><div class="icon-class"></div>MeshNormalMaterial</a></li>
<li><a href="../three/MeshPhongMaterial.html"><div class="icon-class"></div>MeshPhongMaterial</a></li>
<li><a href="../three/MorphAnimMesh.html"><div class="icon-class"></div>MorphAnimMesh</a></li>
<li><a href="../three/MorphColors.html"><div class="icon-class"></div>MorphColors</a></li>
<li><a href="../three/MorphTarget.html"><div class="icon-class"></div>MorphTarget</a></li>
<li><a href="../three/Object3D.html"><div class="icon-class"></div>Object3D</a></li>
<li><a href="../three/OctahedronGeometry.html"><div class="icon-class"></div>OctahedronGeometry</a></li>
<li><a href="../three/OrthographicCamera.html"><div class="icon-class"></div>OrthographicCamera</a></li>
<li><a href="../three/ParametricGeometry.html"><div class="icon-class"></div>ParametricGeometry</a></li>
<li><a href="../three/Particle.html"><div class="icon-class"></div>Particle</a></li>
<li><a href="../three/ParticleBasicMaterial.html"><div class="icon-class"></div>ParticleBasicMaterial</a></li>
<li><a href="../three/ParticleCanvasMaterial.html"><div class="icon-class"></div>ParticleCanvasMaterial</a></li>
<li><a href="../three/ParticleCanvasMaterialProgram.html"><div class="icon-interface"></div>ParticleCanvasMaterialProgram</a></li>
<li><a href="../three/ParticleSystem.html"><div class="icon-class"></div>ParticleSystem</a></li>
<li><a href="../three/Path.html"><div class="icon-class"></div>Path</a></li>
<li><a href="../three/PathAction.html"><div class="icon-class"></div>PathAction</a></li>
<li><a href="../three/PerspectiveCamera.html"><div class="icon-class"></div>PerspectiveCamera</a></li>
<li><a href="../three/PlaneGeometry.html"><div class="icon-class"></div>PlaneGeometry</a></li>
<li><a href="../three/PointLight.html"><div class="icon-class"></div>PointLight</a></li>
<li><a href="../three/PolyhedronGeometry.html"><div class="icon-class"></div>PolyhedronGeometry</a></li>
<li><a href="../three/PolyhedronGeometryVertex.html"><div class="icon-class"></div>PolyhedronGeometryVertex</a></li>
<li><a href="../three/Program.html"><div class="icon-class"></div>Program</a></li>
<li><div class="icon-class"></div><strong>Projector</strong></li>
<li><a href="../three/ProjectorRenderData.html"><div class="icon-class"></div>ProjectorRenderData</a></li>
<li><a href="../three/QuadraticBezierCurve.html"><div class="icon-class"></div>QuadraticBezierCurve</a></li>
<li><a href="../three/QuadraticBezierCurve3.html"><div class="icon-class"></div>QuadraticBezierCurve3</a></li>
<li><a href="../three/Ray.html"><div class="icon-class"></div>Ray</a></li>
<li><a href="../three/Rectangle.html"><div class="icon-class"></div>Rectangle</a></li>
<li><a href="../three/RenderableFace.html"><div class="icon-class"></div>RenderableFace</a></li>
<li><a href="../three/RenderableFace3.html"><div class="icon-class"></div>RenderableFace3</a></li>
<li><a href="../three/RenderableFace4.html"><div class="icon-class"></div>RenderableFace4</a></li>
<li><a href="../three/RenderableLine.html"><div class="icon-class"></div>RenderableLine</a></li>
<li><a href="../three/RenderableObject.html"><div class="icon-class"></div>RenderableObject</a></li>
<li><a href="../three/RenderableParticle.html"><div class="icon-class"></div>RenderableParticle</a></li>
<li><a href="../three/RenderableVertex.html"><div class="icon-class"></div>RenderableVertex</a></li>
<li><a href="../three/Renderer.html"><div class="icon-class"></div>Renderer</a></li>
<li><a href="../three/RenderInts.html"><div class="icon-class"></div>RenderInts</a></li>
<li><a href="../three/Ribbon.html"><div class="icon-class"></div>Ribbon</a></li>
<li><a href="../three/Scene.html"><div class="icon-class"></div>Scene</a></li>
<li><a href="../three/ShaderMaterial.html"><div class="icon-class"></div>ShaderMaterial</a></li>
<li><a href="../three/ShadowCaster.html"><div class="icon-class"></div>ShadowCaster</a></li>
<li><a href="../three/ShadowMapPlugin.html"><div class="icon-class"></div>ShadowMapPlugin</a></li>
<li><a href="../three/Shape.html"><div class="icon-class"></div>Shape</a></li>
<li><a href="../three/ShapeGeometry.html"><div class="icon-class"></div>ShapeGeometry</a></li>
<li><a href="../three/SkinnedMesh.html"><div class="icon-class"></div>SkinnedMesh</a></li>
<li><a href="../three/SphereGeometry.html"><div class="icon-class"></div>SphereGeometry</a></li>
<li><a href="../three/SphericalReflectionMapping.html"><div class="icon-class"></div>SphericalReflectionMapping</a></li>
<li><a href="../three/SphericalRefractionMapping.html"><div class="icon-class"></div>SphericalRefractionMapping</a></li>
<li><a href="../three/SplineCurve.html"><div class="icon-class"></div>SplineCurve</a></li>
<li><a href="../three/SplineCurve3.html"><div class="icon-class"></div>SplineCurve3</a></li>
<li><a href="../three/SpotLight.html"><div class="icon-class"></div>SpotLight</a></li>
<li><a href="../three/Sprite.html"><div class="icon-class"></div>Sprite</a></li>
<li><a href="../three/SpriteAlignment.html"><div class="icon-class"></div>SpriteAlignment</a></li>
<li><a href="../three/TetrahedronGeometry.html"><div class="icon-class"></div>TetrahedronGeometry</a></li>
<li><a href="../three/TextGeometry.html"><div class="icon-class"></div>TextGeometry</a></li>
<li><a href="../three/Texture.html"><div class="icon-class"></div>Texture</a></li>
<li><a href="../three/TorusGeometry.html"><div class="icon-class"></div>TorusGeometry</a></li>
<li><a href="../three/TorusKnotGeometry.html"><div class="icon-class"></div>TorusKnotGeometry</a></li>
<li><a href="../three/TubeGeometry.html"><div class="icon-class"></div>TubeGeometry</a></li>
<li><a href="../three/Uniform.html"><div class="icon-class"></div>Uniform&lt;T&gt;</a></li>
<li><a href="../three/UniformsUtils.html"><div class="icon-class"></div>UniformsUtils</a></li>
<li><a href="../three/UV.html"><div class="icon-class"></div>UV</a></li>
<li><a href="../three/UVMapping.html"><div class="icon-class"></div>UVMapping</a></li>
<li><a href="../three/VirtualLight.html"><div class="icon-class"></div>VirtualLight</a></li>
<li><a href="../three/WebGLCamera.html"><div class="icon-class"></div>WebGLCamera</a></li>
<li><a href="../three/WebGLGeometry.html"><div class="icon-class"></div>WebGLGeometry</a></li>
<li><a href="../three/WebGLImageList.html"><div class="icon-class"></div>WebGLImageList</a></li>
<li><a href="../three/WebGLMaterial.html"><div class="icon-class"></div>WebGLMaterial</a></li>
<li><a href="../three/WebGLObject.html"><div class="icon-class"></div>WebGLObject</a></li>
<li><a href="../three/WebGLRenderer.html"><div class="icon-class"></div>WebGLRenderer</a></li>
<li><a href="../three/WebGLRendererInfo.html"><div class="icon-class"></div>WebGLRendererInfo</a></li>
<li><a href="../three/WebGLRendererMemoryInfo.html"><div class="icon-class"></div>WebGLRendererMemoryInfo</a></li>
<li><a href="../three/WebGLRendererRenderInfo.html"><div class="icon-class"></div>WebGLRendererRenderInfo</a></li>
<li><a href="../three/WebGLRenderTarget.html"><div class="icon-class"></div>WebGLRenderTarget</a></li>
<li><a href="../three/WebGLRenderTargetCube.html"><div class="icon-class"></div>WebGLRenderTargetCube</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../ThreeMath.html">ThreeMath</a></h2><h2><div class="icon-library"></div><a href="../TrackballControls.html">TrackballControls</a></h2><h2><div class="icon-library"></div><a href="../tween.html">tween</a></h2><h2><div class="icon-library"></div><a href="../vector_math.html">vector_math</a></h2></div>
<div class="content">
        <h2><strong>Projector</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>@author mr.doob / http://mrdoob.com/
@author supereggbert / http://www.paulbrunt.co.uk/
@author julianwa / https://github.com/julianwa</p>
<p>Ported to Dart from JS by:
@author rob silverton / http://www.unwrong.com/
@author nelson silva / http://www.inevo.pt</p>
<p>updated to 81ef5c3b32 - Made Projector.projectObject more open for custom rendererers.</p>
<pre class="source">
class Projector {
 List&lt;RenderableObject&gt;_objectPool;
 List&lt;RenderableVertex&gt; _vertexPool;
 List&lt;RenderableFace4&gt; _face4Pool;
 List&lt;RenderableFace3&gt; _face3Pool;
 List&lt;RenderableLine&gt; _linePool;
 List&lt;RenderableParticle&gt; _particlePool;

 int _objectCount, _vertexCount, _face3Count, _face4Count, _lineCount, _particleCount;

 RenderableObject _object;
 RenderableVertex _vertex;
 RenderableLine _line;
 RenderableParticle _particle;

 Vector3 _vector3;
 Vector4 _vector4;

 Vector4 _clippedVertex1PositionScreen;
 Vector4 _clippedVertex2PositionScreen;

 ProjectorRenderData _renderData;

 Matrix4 _viewProjectionMatrix, _modelViewProjectionMatrix;

 Frustum _frustum;

 Projector()
     : _objectPool = [],
       _vertexPool = [],
       _face3Pool = [],
       _face4Pool = [],
       _linePool = [],
       _particlePool = [],

       //_renderData = { "objects": [], "sprites": [], "lights": [], "elements": [] };
       _renderData = new ProjectorRenderData(),

       _vector3 = new Vector3.zero(),
       _vector4 = new Vector4(0.0, 0.0, 0.0, 1.0),

       _viewProjectionMatrix = new Matrix4.identity(),
       _modelViewProjectionMatrix = new Matrix4.identity(),

       _frustum = new Frustum(),

       _clippedVertex1PositionScreen = new Vector4(0.0, 0.0, 0.0, 1.0),
       _clippedVertex2PositionScreen = new Vector4(0.0, 0.0, 0.0, 1.0);

 Vector3 projectVector( Vector3 vector, Camera camera ) {
   camera.matrixWorldInverse.copyInverse(camera.matrixWorld);

   _viewProjectionMatrix = camera.projectionMatrix * camera.matrixWorldInverse;

   return vector.applyProjection(_viewProjectionMatrix);
 }

 Vector3 unprojectVector( Vector3 vector, Camera camera ) {
   camera.projectionMatrixInverse.copyInverse(camera.projectionMatrix);

   _viewProjectionMatrix = camera.matrixWorld * camera.projectionMatrixInverse;

   return vector.applyProjection(_viewProjectionMatrix);
 }

 /**
  * Translates a 2D point from NDC to a THREE.Ray
  * that can be used for picking.
  * @vector - THREE.Vector3 that represents 2D point
  * @camera - THREE.Camera
  */
 Ray pickingRay( Vector3 vector, Camera camera ) {
   Vector3 end, ray, t;

   // set two vectors with opposing z values
   vector.z = -1.0;
   end = new Vector3( vector.x, vector.y, 1.0 );

   unprojectVector( vector, camera );
   unprojectVector( end, camera );

   // find direction from vector to end
   end.sub( vector ).normalize();

   return new Ray( vector, end );
 }

 _projectObject( Object3D parent ) {
   var cl = parent.children.length;
   for ( var c = 0; c &lt; cl; c ++ ) {

     var object = parent.children[ c ];

     if ( !object.visible ) continue;

     if ( object is Light ) {

       _renderData.lights.add( object );

     } else if ( object is Mesh || object is Line ) {

       if ( !object.frustumCulled || _frustum.contains( object ) ) {

         _object = getNextObjectInPool();
         _object.object = object;

         if ( object.renderDepth != null ) {

           _object.z = object.renderDepth;

         } else {

           _vector3 = object.matrixWorld.getTranslation();
           _vector3.applyProjection(_viewProjectionMatrix);
           _object.z = _vector3.z;

         }

         _renderData.objects.add( _object );

       }

     } else if ( object is Sprite || object is Particle ) {

       _object = getNextObjectInPool();
       _object.object = object;

       // TODO: Find an elegant and performant solution and remove this dupe code.

       if ( object.renderDepth != null ) {

         _object.z = object.renderDepth;

       } else {

         _vector3 = object.matrixWorld.getTranslation();
         _vector3.applyProjection(_viewProjectionMatrix);
         _object.z = _vector3.z;

       }

       _renderData.sprites.add( _object );

     } else {

       _object = getNextObjectInPool();
       _object.object = object;

       if ( object.renderDepth != null ) {

         _object.z = object.renderDepth;

       } else {

         _vector3 = object.matrixWorld.getTranslation();
         _vector3.applyProjection(_viewProjectionMatrix);
         _object.z = _vector3.z;

       }

       _renderData.objects.add( _object );

     }

     _projectObject( object );
   }
 }

 ProjectorRenderData projectGraph( Object3D root, bool sort ) {
   _objectCount = 0;

   _renderData.objects = [];
   _renderData.sprites = [];
   _renderData.lights = [];

   _projectObject( root );

   //TODO: assuming this is a form of 'if' statement.
   //sort &amp;&amp; _renderData.objects.sort( painterSort );

   if (sort) {
     _renderData.objects.sort( painterSort );
   }

   return _renderData;
 }


 ProjectorRenderData projectScene( Scene scene, Camera camera, bool sort ) {
   num near = camera.near, far = camera.far;
   bool visible = false;
   int o, ol, v, vl, f, fl, n, nl, c, cl, u, ul;
   Object3D object;
   Matrix4 modelMatrix, rotationMatrix;
   Geometry geometry;
   List geometryMaterials;
   List&lt;Vector3&gt; vertices;
   Vector3 vertex;
   Vector3 vertexPositionScreen, normal;
   List&lt;Face&gt; faces;
   Face face;
   RenderableFace _face;
   List faceVertexNormals;
   List&lt;List&gt; faceVertexUvs;
   RenderableVertex v1, v2, v3, v4;
   bool isFaceMaterial;
   Material material;
   int side;

   _face3Count = 0;
   _face4Count = 0;
   _lineCount = 0;
   _particleCount = 0;

   _renderData.elements = [];

   scene.updateMatrixWorld();

   if ( camera.parent == null ) {
     // console.warn( 'DEPRECATED: Camera hasn\'t been added to a Scene. Adding it...' );
     // scene.add( camera );
     camera.updateMatrixWorld();
   }

   camera.matrixWorldInverse.copyInverse(camera.matrixWorld);

   _viewProjectionMatrix = camera.projectionMatrix * camera.matrixWorldInverse;

   _frustum.setFromMatrix( _viewProjectionMatrix );

   _renderData = projectGraph( scene, false );

   _renderData.objects.forEach((o) {

     object = o.object;

     modelMatrix = object.matrixWorld;

     _vertexCount = 0;

     if ( object is Mesh ) {

       geometry = object.geometry;
       geometryMaterials = object.geometry.materials;
       vertices = geometry.vertices;
       faces = geometry.faces;
       faceVertexUvs = geometry.faceVertexUvs;

       extractRotation( object.matrixRotationWorld, modelMatrix );
       rotationMatrix = object.matrixRotationWorld;

       isFaceMaterial = (object.material is MeshFaceMaterial);
       side = object.material.side;

       vertices.forEach((Vector3 v) {
         _vertex = getNextVertexInPool();
         _vertex.positionWorld.setFrom(v);

         _vertex.positionWorld.applyProjection(modelMatrix);
         _vertex.positionScreen = new Vector4(_vertex.positionWorld.x,
             _vertex.positionWorld.y,
             _vertex.positionWorld.z, 1.0); //  _vertex.positionWorld.clone();
         _viewProjectionMatrix.transform( _vertex.positionScreen );
         _vertex.positionScreen.x /= _vertex.positionScreen.w;
         _vertex.positionScreen.y /= _vertex.positionScreen.w;

         _vertex.visible = _vertex.positionScreen.z &gt; near &amp;&amp; _vertex.positionScreen.z &lt; far;
       });

       fl = faces.length;
       for ( f = 0; f &lt; fl; f ++ ) {

         face = faces[ f ];

         material = isFaceMaterial == true ? geometryMaterials[ face.materialIndex ] : object.material;

         if ( material == null ) continue;

         side = material.side;

         var vtx = face.indices.map((idx) =&gt; _vertexPool[idx]).toList();

         var allVtxVisible = vtx.every((v) =&gt; v.visible);

         if (allVtxVisible) {
           if (face.size == 3) {
             visible = (
                 ( ( vtx[2].positionScreen.x - vtx[0].positionScreen.x ) * ( vtx[1].positionScreen.y - vtx[0].positionScreen.y ) -
                   ( vtx[2].positionScreen.y - vtx[0].positionScreen.y ) * ( vtx[1].positionScreen.x - vtx[0].positionScreen.x ) ) &lt; 0);
           } else if (face.size == 4) {
             visible = ( vtx[3].positionScreen.x - vtx[0].positionScreen.x ) * ( vtx[1].positionScreen.y - vtx[0].positionScreen.y ) -
                 ( vtx[3].positionScreen.y - vtx[0].positionScreen.y ) * ( vtx[1].positionScreen.x - vtx[0].positionScreen.x ) &lt; 0 ||
                 ( vtx[1].positionScreen.x - vtx[2].positionScreen.x ) * ( vtx[3].positionScreen.y - vtx[2].positionScreen.y ) -
                 ( vtx[1].positionScreen.y - vtx[2].positionScreen.y ) * ( vtx[3].positionScreen.x - vtx[2].positionScreen.x ) &lt; 0;
           }

           if ( side == DoubleSide || visible == ( side == FrontSide ) ) {

               _face = (face.size == 3) ? getNextFace3InPool() : getNextFace4InPool();

               _face.vertices = vtx.map((v) =&gt; v.clone()).toList(growable: false);

           } else {
             continue;
           }
         } else {
           continue;
         }

         _face.normalWorld.setFrom( face.normal );

		      if ( visible == false &amp;&amp; ( side == BackSide || side == DoubleSide ) ) _face.normalWorld.negate();
		      _face.normalWorld.applyProjection(rotationMatrix);

         _face.centroidWorld.setFrom( face.centroid );
         _face.centroidWorld.applyProjection(modelMatrix);

         _face.centroidScreen.setFrom( _face.centroidWorld );
         _face.centroidScreen.applyProjection(_viewProjectionMatrix);

         faceVertexNormals = face.vertexNormals;

         nl = faceVertexNormals.length;
         for ( n = 0; n &lt; nl; n ++ ) {
           normal = _face.vertexNormalsWorld[ n ];
           normal.setFrom( faceVertexNormals[ n ] );

           if ( !visible &amp;&amp; ( side == BackSide || side == DoubleSide ) ) normal.negate();

           normal.applyProjection(rotationMatrix);
         }

         cl = faceVertexUvs.length;
         for ( c = 0; c &lt; cl; c ++ ) {
           if ( faceVertexUvs[c].length == 0 ) continue;

           List&lt;UV&gt; uvs = faceVertexUvs[ c ][ f ];

           if ( uvs == null ) continue;

           //TODO: interpreting this code as dynamically creating arrays.
           ul = uvs.length;
           for ( u = 0; u &lt; ul; u ++ ) {
             List faceUVs = _face.uvs[c];
             faceUVs.add(uvs[u]);
             //_face.uvs[ c ][ u ] = uvs[ u ];
           }
         }

         _face.material = material;
         _face.faceMaterial = face.materialIndex != null ? geometryMaterials[ face.materialIndex ] : null;

         _face.z = _face.centroidScreen.z;

         _renderData.elements.add( _face );
       }

     } else if ( object is Line ) {
       _modelViewProjectionMatrix = _viewProjectionMatrix * modelMatrix;

       vertices = object.geometry.vertices;

       v1 = getNextVertexInPool();
       Vector3 vec = vertices[ 0 ];
       v1.positionScreen = new Vector4(vec.x, vec.y, vec.z, 1.0);
       _modelViewProjectionMatrix.transform( v1.positionScreen );

     // Handle LineStrip and LinePieces
       var step = object.type == LinePieces ? 2 : 1;

       vl = vertices.length;
       for ( v = 1; v &lt; vl; v++ ) {

         v1 = getNextVertexInPool();
         Vector3 vec = vertices[ v ];
         v1.positionScreen = new Vector4(vec.x, vec.y, vec.z, 1.0);
         _modelViewProjectionMatrix.transform( v1.positionScreen );

         if ( ( v + 1 ) % step &gt; 0 ) continue;

         v2 = _vertexPool[ _vertexCount - 2 ];

         _clippedVertex1PositionScreen.setFrom(v1.positionScreen);
         _clippedVertex2PositionScreen.setFrom(v2.positionScreen);

         if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) ) {
           // Perform the perspective divide
           _clippedVertex1PositionScreen /= _clippedVertex1PositionScreen.w;
           _clippedVertex2PositionScreen /= _clippedVertex2PositionScreen.w;

           _line = getNextLineInPool();
           _line.v1.positionScreen.setFrom(_clippedVertex1PositionScreen);
           _line.v2.positionScreen.setFrom(_clippedVertex2PositionScreen);

           _line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

           _line.material = object.material;

           _renderData.elements.add( _line );
         }
       }
     }
   });

  _renderData.sprites.forEach((o) {

     object = o.object;

     modelMatrix = object.matrixWorld;

     if ( object is Particle ) {
       _vector4.setValues ( modelMatrix[12], modelMatrix[13], modelMatrix[14], 1.0 );
       _viewProjectionMatrix.transform( _vector4 );

       _vector4.z /= _vector4.w;

       if ( _vector4.z &gt; 0 &amp;&amp; _vector4.z &lt; 1 ) {
         _particle = getNextParticleInPool();
         _particle.x = _vector4.x / _vector4.w;
         _particle.y = _vector4.y / _vector4.w;
         _particle.z = _vector4.z;

         _particle.rotation = object.rotation.z;

         _particle.scale.x = object.scale.x * ( _particle.x - ( _vector4.x + camera.projectionMatrix[0] ) / ( _vector4.w + camera.projectionMatrix[12] ) ).abs();
         _particle.scale.y = object.scale.y * ( _particle.y - ( _vector4.y + camera.projectionMatrix[5] ) / ( _vector4.w + camera.projectionMatrix[13] ) ).abs();

         _particle.material = object.material as Material;

         _renderData.elements.add( _particle );
       }
     }
   });

   if ( sort ) {
     _renderData.elements.sort( painterSort );
   }

   return _renderData;
 }

 // Pools
 RenderableObject getNextObjectInPool() {
   //TODO: make sure I've interpreted this logic correctly
   // RenderableObject object = _objectPool[ _objectCount ] = _objectPool[ _objectCount ] || new RenderableObject();

   RenderableObject object;
   if ( _objectCount &lt; _objectPool.length ) {
     object = ( _objectPool[ _objectCount ] != null ) ? _objectPool[ _objectCount ] : new RenderableObject();
   } else {
     object = new RenderableObject();
     _objectPool.add(object);
   }

   _objectCount ++;

   return object;
 }

 RenderableVertex getNextVertexInPool() {
   //TODO: make sure I've interpreted this logic correctly
   // var vertex = _vertexPool[ _vertexCount ] = _vertexPool[ _vertexCount ] || new THREE.RenderableVertex();
   RenderableVertex vertex;

   // Vertex is already within List
   if ( _vertexCount &lt; _vertexPool.length ) {
     vertex = ( _vertexPool[ _vertexCount ] != null ) ? _vertexPool[ _vertexCount ] : new RenderableVertex();
   } else {
     vertex = new RenderableVertex();
     _vertexPool.add(vertex);
   }

   _vertexCount ++;

   return vertex;
 }

 RenderableFace getNextFace3InPool() {
   //TODO: make sure I've interpreted this logic correctly
   // RenderableFace3 face = _face3Pool[ _face3Count ] = _face3Pool[ _face3Count ] || new RenderableFace3();
   RenderableFace3 face;
   if ( _face3Count &lt; _face3Pool.length ) {
     face = ( _face3Pool[ _face3Count ] != null ) ? _face3Pool[ _face3Count ] : new RenderableFace3();
   } else {
     face = new RenderableFace3();
     _face3Pool.add(face);
   }

   _face3Count ++;

   return face;
 }

 RenderableFace getNextFace4InPool() {

   RenderableFace4 face;
   if ( _face4Count &lt; _face4Pool.length ) {
     face = ( _face4Pool[ _face4Count ] != null ) ? _face4Pool[ _face4Count ] : new RenderableFace4();
   } else {
     face = new RenderableFace4();
     _face4Pool.add(face);
   }

   _face4Count ++;

   return face;
 }

 RenderableLine getNextLineInPool() {
   //TODO: make sure I've interpreted this logic correctly
   //RenderableLine line = _linePool[ _lineCount ] = _linePool[ _lineCount ] || new RenderableLine();
   RenderableLine line;
   if ( _lineCount &lt; _linePool.length ) {
     line = ( _linePool[ _lineCount ] != null ) ? _linePool[ _lineCount ] : new RenderableLine();
   } else {
     line = new RenderableLine();
     _linePool.add(line);
   }

   _lineCount ++;

   return line;
 }

 RenderableParticle getNextParticleInPool() {
   //TODO: make sure I've interpreted this logic correctly
   //RenderableParticle particle = _particlePool[ _particleCount ] = _particlePool[ _particleCount ] || new RenderableParticle();
   RenderableParticle particle;
   if ( _particleCount &lt; _particlePool.length ) {
     particle = ( _particlePool[ _particleCount ] != null ) ? _particlePool[ _particleCount ] : new RenderableParticle();
   } else {
     particle = new RenderableParticle();
     _particlePool.add(particle);
   }

   _particleCount ++;
   return particle;
 }

 int painterSort( a, b ) =&gt; b.z.compareTo(a.z);

 bool clipLine( Vector4 s1, Vector4 s2 ) {
   double alpha1 = 0.0, alpha2 = 1.0,

   // Calculate the boundary coordinate of each vertex for the near and far clip planes,
   // Z = -1 and Z = +1, respectively.
   bc1near =  s1.z + s1.w,
   bc2near =  s2.z + s2.w,
   bc1far =  - s1.z + s1.w,
   bc2far =  - s2.z + s2.w;

   if ( bc1near &gt;= 0 &amp;&amp; bc2near &gt;= 0 &amp;&amp; bc1far &gt;= 0 &amp;&amp; bc2far &gt;= 0 ) {
     // Both vertices lie entirely within all clip planes.
     return true;
   } else if ( ( bc1near &lt; 0 &amp;&amp; bc2near &lt; 0) || (bc1far &lt; 0 &amp;&amp; bc2far &lt; 0 ) ) {
     // Both vertices lie entirely outside one of the clip planes.
     return false;
   } else {
     // The line segment spans at least one clip plane.
     if ( bc1near &lt; 0 ) {
       // v1 lies outside the near plane, v2 inside
       alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );
     } else if ( bc2near &lt; 0 ) {
       // v2 lies outside the near plane, v1 inside
       alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );
     }

     if ( bc1far &lt; 0 ) {
       // v1 lies outside the far plane, v2 inside
       alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );
     } else if ( bc2far &lt; 0 ) {
       // v2 lies outside the far plane, v2 inside
       alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );
     }

     if ( alpha2 &lt; alpha1 ) {
       // The line segment spans two boundaries, but is outside both of them.
       // (This can't happen when we're only clipping against just near/far but good
       //  to leave the check here for future usage if other clip planes are added.)
       return false;
     } else {
       // Update the s1 and s2 vertices to match the clipped line segment.
       s1 = lerp4(s1, s2, alpha1 );
       s2 = lerp4(s2, s1, 1.0 - alpha2 );

       return true;
     }
   }
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Projector</strong>() <a class="anchor-link" href="#"
              title="Permalink to Projector.Projector">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="../dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="../dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="../dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html">Object</a> </div></div>
<pre class="source">
Projector()
   : _objectPool = [],
     _vertexPool = [],
     _face3Pool = [],
     _face4Pool = [],
     _linePool = [],
     _particlePool = [],

     //_renderData = { "objects": [], "sprites": [], "lights": [], "elements": [] };
     _renderData = new ProjectorRenderData(),

     _vector3 = new Vector3.zero(),
     _vector4 = new Vector4(0.0, 0.0, 0.0, 1.0),

     _viewProjectionMatrix = new Matrix4.identity(),
     _modelViewProjectionMatrix = new Matrix4.identity(),

     _frustum = new Frustum(),

     _clippedVertex1PositionScreen = new Vector4(0.0, 0.0, 0.0, 1.0),
     _clippedVertex2PositionScreen = new Vector4(0.0, 0.0, 0.0, 1.0);
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="clipLine">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>clipLine</strong>(<a href="../vector_math/Vector4.html">Vector4</a> s1, <a href="../vector_math/Vector4.html">Vector4</a> s2) <a class="anchor-link" href="#clipLine"
              title="Permalink to Projector.clipLine">#</a></h4>
<div class="doc">
<pre class="source">
bool clipLine( Vector4 s1, Vector4 s2 ) {
 double alpha1 = 0.0, alpha2 = 1.0,

 // Calculate the boundary coordinate of each vertex for the near and far clip planes,
 // Z = -1 and Z = +1, respectively.
 bc1near =  s1.z + s1.w,
 bc2near =  s2.z + s2.w,
 bc1far =  - s1.z + s1.w,
 bc2far =  - s2.z + s2.w;

 if ( bc1near &gt;= 0 &amp;&amp; bc2near &gt;= 0 &amp;&amp; bc1far &gt;= 0 &amp;&amp; bc2far &gt;= 0 ) {
   // Both vertices lie entirely within all clip planes.
   return true;
 } else if ( ( bc1near &lt; 0 &amp;&amp; bc2near &lt; 0) || (bc1far &lt; 0 &amp;&amp; bc2far &lt; 0 ) ) {
   // Both vertices lie entirely outside one of the clip planes.
   return false;
 } else {
   // The line segment spans at least one clip plane.
   if ( bc1near &lt; 0 ) {
     // v1 lies outside the near plane, v2 inside
     alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );
   } else if ( bc2near &lt; 0 ) {
     // v2 lies outside the near plane, v1 inside
     alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );
   }

   if ( bc1far &lt; 0 ) {
     // v1 lies outside the far plane, v2 inside
     alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );
   } else if ( bc2far &lt; 0 ) {
     // v2 lies outside the far plane, v2 inside
     alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );
   }

   if ( alpha2 &lt; alpha1 ) {
     // The line segment spans two boundaries, but is outside both of them.
     // (This can't happen when we're only clipping against just near/far but good
     //  to leave the check here for future usage if other clip planes are added.)
     return false;
   } else {
     // Update the s1 and s2 vertices to match the clipped line segment.
     s1 = lerp4(s1, s2, alpha1 );
     s2 = lerp4(s2, s1, 1.0 - alpha2 );

     return true;
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="getNextFace3InPool">
<button class="show-code">Code</button>
<a href="../three/RenderableFace.html">RenderableFace</a> <strong>getNextFace3InPool</strong>() <a class="anchor-link" href="#getNextFace3InPool"
              title="Permalink to Projector.getNextFace3InPool">#</a></h4>
<div class="doc">
<pre class="source">
RenderableFace getNextFace3InPool() {
 //TODO: make sure I've interpreted this logic correctly
 // RenderableFace3 face = _face3Pool[ _face3Count ] = _face3Pool[ _face3Count ] || new RenderableFace3();
 RenderableFace3 face;
 if ( _face3Count &lt; _face3Pool.length ) {
   face = ( _face3Pool[ _face3Count ] != null ) ? _face3Pool[ _face3Count ] : new RenderableFace3();
 } else {
   face = new RenderableFace3();
   _face3Pool.add(face);
 }

 _face3Count ++;

 return face;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getNextFace4InPool">
<button class="show-code">Code</button>
<a href="../three/RenderableFace.html">RenderableFace</a> <strong>getNextFace4InPool</strong>() <a class="anchor-link" href="#getNextFace4InPool"
              title="Permalink to Projector.getNextFace4InPool">#</a></h4>
<div class="doc">
<pre class="source">
RenderableFace getNextFace4InPool() {

 RenderableFace4 face;
 if ( _face4Count &lt; _face4Pool.length ) {
   face = ( _face4Pool[ _face4Count ] != null ) ? _face4Pool[ _face4Count ] : new RenderableFace4();
 } else {
   face = new RenderableFace4();
   _face4Pool.add(face);
 }

 _face4Count ++;

 return face;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getNextLineInPool">
<button class="show-code">Code</button>
<a href="../three/RenderableLine.html">RenderableLine</a> <strong>getNextLineInPool</strong>() <a class="anchor-link" href="#getNextLineInPool"
              title="Permalink to Projector.getNextLineInPool">#</a></h4>
<div class="doc">
<pre class="source">
RenderableLine getNextLineInPool() {
 //TODO: make sure I've interpreted this logic correctly
 //RenderableLine line = _linePool[ _lineCount ] = _linePool[ _lineCount ] || new RenderableLine();
 RenderableLine line;
 if ( _lineCount &lt; _linePool.length ) {
   line = ( _linePool[ _lineCount ] != null ) ? _linePool[ _lineCount ] : new RenderableLine();
 } else {
   line = new RenderableLine();
   _linePool.add(line);
 }

 _lineCount ++;

 return line;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getNextObjectInPool">
<button class="show-code">Code</button>
<a href="../three/RenderableObject.html">RenderableObject</a> <strong>getNextObjectInPool</strong>() <a class="anchor-link" href="#getNextObjectInPool"
              title="Permalink to Projector.getNextObjectInPool">#</a></h4>
<div class="doc">
<pre class="source">
RenderableObject getNextObjectInPool() {
 //TODO: make sure I've interpreted this logic correctly
 // RenderableObject object = _objectPool[ _objectCount ] = _objectPool[ _objectCount ] || new RenderableObject();

 RenderableObject object;
 if ( _objectCount &lt; _objectPool.length ) {
   object = ( _objectPool[ _objectCount ] != null ) ? _objectPool[ _objectCount ] : new RenderableObject();
 } else {
   object = new RenderableObject();
   _objectPool.add(object);
 }

 _objectCount ++;

 return object;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getNextParticleInPool">
<button class="show-code">Code</button>
<a href="../three/RenderableParticle.html">RenderableParticle</a> <strong>getNextParticleInPool</strong>() <a class="anchor-link" href="#getNextParticleInPool"
              title="Permalink to Projector.getNextParticleInPool">#</a></h4>
<div class="doc">
<pre class="source">
RenderableParticle getNextParticleInPool() {
 //TODO: make sure I've interpreted this logic correctly
 //RenderableParticle particle = _particlePool[ _particleCount ] = _particlePool[ _particleCount ] || new RenderableParticle();
 RenderableParticle particle;
 if ( _particleCount &lt; _particlePool.length ) {
   particle = ( _particlePool[ _particleCount ] != null ) ? _particlePool[ _particleCount ] : new RenderableParticle();
 } else {
   particle = new RenderableParticle();
   _particlePool.add(particle);
 }

 _particleCount ++;
 return particle;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getNextVertexInPool">
<button class="show-code">Code</button>
<a href="../three/RenderableVertex.html">RenderableVertex</a> <strong>getNextVertexInPool</strong>() <a class="anchor-link" href="#getNextVertexInPool"
              title="Permalink to Projector.getNextVertexInPool">#</a></h4>
<div class="doc">
<pre class="source">
RenderableVertex getNextVertexInPool() {
 //TODO: make sure I've interpreted this logic correctly
 // var vertex = _vertexPool[ _vertexCount ] = _vertexPool[ _vertexCount ] || new THREE.RenderableVertex();
 RenderableVertex vertex;

 // Vertex is already within List
 if ( _vertexCount &lt; _vertexPool.length ) {
   vertex = ( _vertexPool[ _vertexCount ] != null ) ? _vertexPool[ _vertexCount ] : new RenderableVertex();
 } else {
   vertex = new RenderableVertex();
   _vertexPool.add(vertex);
 }

 _vertexCount ++;

 return vertex;
}
</pre>
</div>
</div>
<div class="method"><h4 id="painterSort">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a> <strong>painterSort</strong>(a, b) <a class="anchor-link" href="#painterSort"
              title="Permalink to Projector.painterSort">#</a></h4>
<div class="doc">
<pre class="source">
int painterSort( a, b ) =&gt; b.z.compareTo(a.z);
</pre>
</div>
</div>
<div class="method"><h4 id="pickingRay">
<button class="show-code">Code</button>
<a href="../three/Ray.html">Ray</a> <strong>pickingRay</strong>(<a href="../vector_math/Vector3.html">Vector3</a> vector, <a href="../three/Camera.html">Camera</a> camera) <a class="anchor-link" href="#pickingRay"
              title="Permalink to Projector.pickingRay">#</a></h4>
<div class="doc">
<p>Translates a 2D point from NDC to a THREE.Ray
that can be used for picking.
@vector - THREE.Vector3 that represents 2D point
@camera - THREE.Camera</p>
<pre class="source">
Ray pickingRay( Vector3 vector, Camera camera ) {
 Vector3 end, ray, t;

 // set two vectors with opposing z values
 vector.z = -1.0;
 end = new Vector3( vector.x, vector.y, 1.0 );

 unprojectVector( vector, camera );
 unprojectVector( end, camera );

 // find direction from vector to end
 end.sub( vector ).normalize();

 return new Ray( vector, end );
}
</pre>
</div>
</div>
<div class="method"><h4 id="projectGraph">
<button class="show-code">Code</button>
<a href="../three/ProjectorRenderData.html">ProjectorRenderData</a> <strong>projectGraph</strong>(<a href="../three/Object3D.html">Object3D</a> root, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> sort) <a class="anchor-link" href="#projectGraph"
              title="Permalink to Projector.projectGraph">#</a></h4>
<div class="doc">
<pre class="source">
ProjectorRenderData projectGraph( Object3D root, bool sort ) {
 _objectCount = 0;

 _renderData.objects = [];
 _renderData.sprites = [];
 _renderData.lights = [];

 _projectObject( root );

 //TODO: assuming this is a form of 'if' statement.
 //sort &amp;&amp; _renderData.objects.sort( painterSort );

 if (sort) {
   _renderData.objects.sort( painterSort );
 }

 return _renderData;
}
</pre>
</div>
</div>
<div class="method"><h4 id="projectScene">
<button class="show-code">Code</button>
<a href="../three/ProjectorRenderData.html">ProjectorRenderData</a> <strong>projectScene</strong>(<a href="../three/Scene.html">Scene</a> scene, <a href="../three/Camera.html">Camera</a> camera, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> sort) <a class="anchor-link" href="#projectScene"
              title="Permalink to Projector.projectScene">#</a></h4>
<div class="doc">
<pre class="source">
ProjectorRenderData projectScene( Scene scene, Camera camera, bool sort ) {
 num near = camera.near, far = camera.far;
 bool visible = false;
 int o, ol, v, vl, f, fl, n, nl, c, cl, u, ul;
 Object3D object;
 Matrix4 modelMatrix, rotationMatrix;
 Geometry geometry;
 List geometryMaterials;
 List&lt;Vector3&gt; vertices;
 Vector3 vertex;
 Vector3 vertexPositionScreen, normal;
 List&lt;Face&gt; faces;
 Face face;
 RenderableFace _face;
 List faceVertexNormals;
 List&lt;List&gt; faceVertexUvs;
 RenderableVertex v1, v2, v3, v4;
 bool isFaceMaterial;
 Material material;
 int side;

 _face3Count = 0;
 _face4Count = 0;
 _lineCount = 0;
 _particleCount = 0;

 _renderData.elements = [];

 scene.updateMatrixWorld();

 if ( camera.parent == null ) {
   // console.warn( 'DEPRECATED: Camera hasn\'t been added to a Scene. Adding it...' );
   // scene.add( camera );
   camera.updateMatrixWorld();
 }

 camera.matrixWorldInverse.copyInverse(camera.matrixWorld);

 _viewProjectionMatrix = camera.projectionMatrix * camera.matrixWorldInverse;

 _frustum.setFromMatrix( _viewProjectionMatrix );

 _renderData = projectGraph( scene, false );

 _renderData.objects.forEach((o) {

   object = o.object;

   modelMatrix = object.matrixWorld;

   _vertexCount = 0;

   if ( object is Mesh ) {

     geometry = object.geometry;
     geometryMaterials = object.geometry.materials;
     vertices = geometry.vertices;
     faces = geometry.faces;
     faceVertexUvs = geometry.faceVertexUvs;

     extractRotation( object.matrixRotationWorld, modelMatrix );
     rotationMatrix = object.matrixRotationWorld;

     isFaceMaterial = (object.material is MeshFaceMaterial);
     side = object.material.side;

     vertices.forEach((Vector3 v) {
       _vertex = getNextVertexInPool();
       _vertex.positionWorld.setFrom(v);

       _vertex.positionWorld.applyProjection(modelMatrix);
       _vertex.positionScreen = new Vector4(_vertex.positionWorld.x,
           _vertex.positionWorld.y,
           _vertex.positionWorld.z, 1.0); //  _vertex.positionWorld.clone();
       _viewProjectionMatrix.transform( _vertex.positionScreen );
       _vertex.positionScreen.x /= _vertex.positionScreen.w;
       _vertex.positionScreen.y /= _vertex.positionScreen.w;

       _vertex.visible = _vertex.positionScreen.z &gt; near &amp;&amp; _vertex.positionScreen.z &lt; far;
     });

     fl = faces.length;
     for ( f = 0; f &lt; fl; f ++ ) {

       face = faces[ f ];

       material = isFaceMaterial == true ? geometryMaterials[ face.materialIndex ] : object.material;

       if ( material == null ) continue;

       side = material.side;

       var vtx = face.indices.map((idx) =&gt; _vertexPool[idx]).toList();

       var allVtxVisible = vtx.every((v) =&gt; v.visible);

       if (allVtxVisible) {
         if (face.size == 3) {
           visible = (
               ( ( vtx[2].positionScreen.x - vtx[0].positionScreen.x ) * ( vtx[1].positionScreen.y - vtx[0].positionScreen.y ) -
                 ( vtx[2].positionScreen.y - vtx[0].positionScreen.y ) * ( vtx[1].positionScreen.x - vtx[0].positionScreen.x ) ) &lt; 0);
         } else if (face.size == 4) {
           visible = ( vtx[3].positionScreen.x - vtx[0].positionScreen.x ) * ( vtx[1].positionScreen.y - vtx[0].positionScreen.y ) -
               ( vtx[3].positionScreen.y - vtx[0].positionScreen.y ) * ( vtx[1].positionScreen.x - vtx[0].positionScreen.x ) &lt; 0 ||
               ( vtx[1].positionScreen.x - vtx[2].positionScreen.x ) * ( vtx[3].positionScreen.y - vtx[2].positionScreen.y ) -
               ( vtx[1].positionScreen.y - vtx[2].positionScreen.y ) * ( vtx[3].positionScreen.x - vtx[2].positionScreen.x ) &lt; 0;
         }

         if ( side == DoubleSide || visible == ( side == FrontSide ) ) {

             _face = (face.size == 3) ? getNextFace3InPool() : getNextFace4InPool();

             _face.vertices = vtx.map((v) =&gt; v.clone()).toList(growable: false);

         } else {
           continue;
         }
       } else {
         continue;
       }

       _face.normalWorld.setFrom( face.normal );

		      if ( visible == false &amp;&amp; ( side == BackSide || side == DoubleSide ) ) _face.normalWorld.negate();
		      _face.normalWorld.applyProjection(rotationMatrix);

       _face.centroidWorld.setFrom( face.centroid );
       _face.centroidWorld.applyProjection(modelMatrix);

       _face.centroidScreen.setFrom( _face.centroidWorld );
       _face.centroidScreen.applyProjection(_viewProjectionMatrix);

       faceVertexNormals = face.vertexNormals;

       nl = faceVertexNormals.length;
       for ( n = 0; n &lt; nl; n ++ ) {
         normal = _face.vertexNormalsWorld[ n ];
         normal.setFrom( faceVertexNormals[ n ] );

         if ( !visible &amp;&amp; ( side == BackSide || side == DoubleSide ) ) normal.negate();

         normal.applyProjection(rotationMatrix);
       }

       cl = faceVertexUvs.length;
       for ( c = 0; c &lt; cl; c ++ ) {
         if ( faceVertexUvs[c].length == 0 ) continue;

         List&lt;UV&gt; uvs = faceVertexUvs[ c ][ f ];

         if ( uvs == null ) continue;

         //TODO: interpreting this code as dynamically creating arrays.
         ul = uvs.length;
         for ( u = 0; u &lt; ul; u ++ ) {
           List faceUVs = _face.uvs[c];
           faceUVs.add(uvs[u]);
           //_face.uvs[ c ][ u ] = uvs[ u ];
         }
       }

       _face.material = material;
       _face.faceMaterial = face.materialIndex != null ? geometryMaterials[ face.materialIndex ] : null;

       _face.z = _face.centroidScreen.z;

       _renderData.elements.add( _face );
     }

   } else if ( object is Line ) {
     _modelViewProjectionMatrix = _viewProjectionMatrix * modelMatrix;

     vertices = object.geometry.vertices;

     v1 = getNextVertexInPool();
     Vector3 vec = vertices[ 0 ];
     v1.positionScreen = new Vector4(vec.x, vec.y, vec.z, 1.0);
     _modelViewProjectionMatrix.transform( v1.positionScreen );

   // Handle LineStrip and LinePieces
     var step = object.type == LinePieces ? 2 : 1;

     vl = vertices.length;
     for ( v = 1; v &lt; vl; v++ ) {

       v1 = getNextVertexInPool();
       Vector3 vec = vertices[ v ];
       v1.positionScreen = new Vector4(vec.x, vec.y, vec.z, 1.0);
       _modelViewProjectionMatrix.transform( v1.positionScreen );

       if ( ( v + 1 ) % step &gt; 0 ) continue;

       v2 = _vertexPool[ _vertexCount - 2 ];

       _clippedVertex1PositionScreen.setFrom(v1.positionScreen);
       _clippedVertex2PositionScreen.setFrom(v2.positionScreen);

       if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) ) {
         // Perform the perspective divide
         _clippedVertex1PositionScreen /= _clippedVertex1PositionScreen.w;
         _clippedVertex2PositionScreen /= _clippedVertex2PositionScreen.w;

         _line = getNextLineInPool();
         _line.v1.positionScreen.setFrom(_clippedVertex1PositionScreen);
         _line.v2.positionScreen.setFrom(_clippedVertex2PositionScreen);

         _line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

         _line.material = object.material;

         _renderData.elements.add( _line );
       }
     }
   }
 });

_renderData.sprites.forEach((o) {

   object = o.object;

   modelMatrix = object.matrixWorld;

   if ( object is Particle ) {
     _vector4.setValues ( modelMatrix[12], modelMatrix[13], modelMatrix[14], 1.0 );
     _viewProjectionMatrix.transform( _vector4 );

     _vector4.z /= _vector4.w;

     if ( _vector4.z &gt; 0 &amp;&amp; _vector4.z &lt; 1 ) {
       _particle = getNextParticleInPool();
       _particle.x = _vector4.x / _vector4.w;
       _particle.y = _vector4.y / _vector4.w;
       _particle.z = _vector4.z;

       _particle.rotation = object.rotation.z;

       _particle.scale.x = object.scale.x * ( _particle.x - ( _vector4.x + camera.projectionMatrix[0] ) / ( _vector4.w + camera.projectionMatrix[12] ) ).abs();
       _particle.scale.y = object.scale.y * ( _particle.y - ( _vector4.y + camera.projectionMatrix[5] ) / ( _vector4.w + camera.projectionMatrix[13] ) ).abs();

       _particle.material = object.material as Material;

       _renderData.elements.add( _particle );
     }
   }
 });

 if ( sort ) {
   _renderData.elements.sort( painterSort );
 }

 return _renderData;
}
</pre>
</div>
</div>
<div class="method"><h4 id="projectVector">
<button class="show-code">Code</button>
<a href="../vector_math/Vector3.html">Vector3</a> <strong>projectVector</strong>(<a href="../vector_math/Vector3.html">Vector3</a> vector, <a href="../three/Camera.html">Camera</a> camera) <a class="anchor-link" href="#projectVector"
              title="Permalink to Projector.projectVector">#</a></h4>
<div class="doc">
<pre class="source">
Vector3 projectVector( Vector3 vector, Camera camera ) {
 camera.matrixWorldInverse.copyInverse(camera.matrixWorld);

 _viewProjectionMatrix = camera.projectionMatrix * camera.matrixWorldInverse;

 return vector.applyProjection(_viewProjectionMatrix);
}
</pre>
</div>
</div>
<div class="method"><h4 id="unprojectVector">
<button class="show-code">Code</button>
<a href="../vector_math/Vector3.html">Vector3</a> <strong>unprojectVector</strong>(<a href="../vector_math/Vector3.html">Vector3</a> vector, <a href="../three/Camera.html">Camera</a> camera) <a class="anchor-link" href="#unprojectVector"
              title="Permalink to Projector.unprojectVector">#</a></h4>
<div class="doc">
<pre class="source">
Vector3 unprojectVector( Vector3 vector, Camera camera ) {
 camera.projectionMatrixInverse.copyInverse(camera.projectionMatrix);

 _viewProjectionMatrix = camera.matrixWorld * camera.projectionMatrixInverse;

 return vector.applyProjection(_viewProjectionMatrix);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-11-08 17:35:34.114</div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
