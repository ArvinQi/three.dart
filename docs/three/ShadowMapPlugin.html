        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ShadowMapPlugin class / three Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="three" data-type="ShadowMapPlugin">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../three.html">three</a> &rsaquo; <a href="../three/ShadowMapPlugin.html">ShadowMapPlugin</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../CurveUtils.html">CurveUtils</a></h2><h2><div class="icon-library"></div><a href="../FirstPersonControls.html">FirstPersonControls</a></h2><h2><div class="icon-library"></div><a href="../FontUtils.html">FontUtils</a></h2><h2><div class="icon-library"></div><a href="../GeometryUtils.html">GeometryUtils</a></h2><h2><div class="icon-library"></div><a href="../ImageUtils.html">ImageUtils</a></h2><h2><div class="icon-library"></div><a href="../SceneUtils.html">SceneUtils</a></h2><h2><div class="icon-library"></div><a href="../ShaderUtils.html">ShaderUtils</a></h2><h2><div class="icon-library"></div><a href="../ShapeUtils.html">ShapeUtils</a></h2><h2><div class="icon-library"></div><a href="../three.html">three</a></h2><ul class="icon">
<li><a href="../three/AmbientLight.html"><div class="icon-class"></div>AmbientLight</a></li>
<li><a href="../three/ArcCurve.html"><div class="icon-class"></div>ArcCurve</a></li>
<li><a href="../three/ArrowHelper.html"><div class="icon-class"></div>ArrowHelper</a></li>
<li><a href="../three/Attribute.html"><div class="icon-class"></div>Attribute&lt;T&gt;</a></li>
<li><a href="../three/AxisHelper.html"><div class="icon-class"></div>AxisHelper</a></li>
<li><a href="../three/Bone.html"><div class="icon-class"></div>Bone</a></li>
<li><a href="../three/BoundingBox.html"><div class="icon-class"></div>BoundingBox</a></li>
<li><a href="../three/BoundingSphere.html"><div class="icon-class"></div>BoundingSphere</a></li>
<li><a href="../three/Buffer.html"><div class="icon-class"></div>Buffer</a></li>
<li><a href="../three/BufferGeometry.html"><div class="icon-class"></div>BufferGeometry</a></li>
<li><a href="../three/Camera.html"><div class="icon-class"></div>Camera</a></li>
<li><a href="../three/CameraHelper.html"><div class="icon-class"></div>CameraHelper</a></li>
<li><a href="../three/CanvasRenderData.html"><div class="icon-class"></div>CanvasRenderData</a></li>
<li><a href="../three/CanvasRenderer.html"><div class="icon-class"></div>CanvasRenderer</a></li>
<li><a href="../three/Chunk.html"><div class="icon-class"></div>Chunk</a></li>
<li><a href="../three/CircleGeometry.html"><div class="icon-class"></div>CircleGeometry</a></li>
<li><a href="../three/ClosedSplineCurve3.html"><div class="icon-class"></div>ClosedSplineCurve3</a></li>
<li><a href="../three/Color.html"><div class="icon-class"></div>Color</a></li>
<li><a href="../three/CompressedTexture.html"><div class="icon-class"></div>CompressedTexture</a></li>
<li><a href="../three/ConvexGeometry.html"><div class="icon-class"></div>ConvexGeometry</a></li>
<li><a href="../three/CSS3DObject.html"><div class="icon-class"></div>CSS3DObject</a></li>
<li><a href="../three/CSS3DRenderer.html"><div class="icon-class"></div>CSS3DRenderer</a></li>
<li><a href="../three/CubeGeometry.html"><div class="icon-class"></div>CubeGeometry</a></li>
<li><a href="../three/CubeGeomSides.html"><div class="icon-class"></div>CubeGeomSides</a></li>
<li><a href="../three/CubeReflectionMapping.html"><div class="icon-class"></div>CubeReflectionMapping</a></li>
<li><a href="../three/CubeRefractionMapping.html"><div class="icon-class"></div>CubeRefractionMapping</a></li>
<li><a href="../three/CubicBezierCurve.html"><div class="icon-class"></div>CubicBezierCurve</a></li>
<li><a href="../three/CubicBezierCurve3.html"><div class="icon-class"></div>CubicBezierCurve3</a></li>
<li><a href="../three/Curve.html"><div class="icon-class"></div>Curve&lt;V&gt;</a></li>
<li><a href="../three/Curve2D.html"><div class="icon-class"></div>Curve2D</a></li>
<li><a href="../three/Curve3D.html"><div class="icon-class"></div>Curve3D</a></li>
<li><a href="../three/CurvePath.html"><div class="icon-class"></div>CurvePath</a></li>
<li><a href="../three/CylinderGeometry.html"><div class="icon-class"></div>CylinderGeometry</a></li>
<li><a href="../three/DataTexture.html"><div class="icon-class"></div>DataTexture</a></li>
<li><a href="../three/DirectionalLight.html"><div class="icon-class"></div>DirectionalLight</a></li>
<li><a href="../three/EllipseCurve.html"><div class="icon-class"></div>EllipseCurve</a></li>
<li><a href="../three/EventEmitter.html"><div class="icon-class"></div>EventEmitter</a></li>
<li><a href="../three/EventEmitterEvent.html"><div class="icon-class"></div>EventEmitterEvent</a></li>
<li><a href="../three/ExtrudeGeometry.html"><div class="icon-class"></div>ExtrudeGeometry</a></li>
<li><a href="../three/ExtrudeGeometryWorldUVGenerator.html"><div class="icon-class"></div>ExtrudeGeometryWorldUVGenerator</a></li>
<li><a href="../three/Face.html"><div class="icon-class"></div>Face</a></li>
<li><a href="../three/Face3.html"><div class="icon-class"></div>Face3</a></li>
<li><a href="../three/Face4.html"><div class="icon-class"></div>Face4</a></li>
<li><a href="../three/Fog.html"><div class="icon-class"></div>Fog</a></li>
<li><a href="../three/FogExp2.html"><div class="icon-class"></div>FogExp2</a></li>
<li><a href="../three/FogLinear.html"><div class="icon-class"></div>FogLinear</a></li>
<li><a href="../three/Frustum.html"><div class="icon-class"></div>Frustum</a></li>
<li><a href="../three/Geometry.html"><div class="icon-class"></div>Geometry</a></li>
<li><a href="../three/GeometryAttribute.html"><div class="icon-class"></div>GeometryAttribute&lt;T&gt;</a></li>
<li><a href="../three/Gyroscope.html"><div class="icon-class"></div>Gyroscope</a></li>
<li><a href="../three/HemisphereLight.html"><div class="icon-class"></div>HemisphereLight</a></li>
<li><a href="../three/IcosahedronGeometry.html"><div class="icon-class"></div>IcosahedronGeometry</a></li>
<li><a href="../three/ImageList.html"><div class="icon-class"></div>ImageList</a></li>
<li><a href="../three/ImageLoader.html"><div class="icon-class"></div>ImageLoader</a></li>
<li><a href="../three/IMaterial.html"><div class="icon-class"></div>IMaterial</a></li>
<li><a href="../three/ImmediateRenderObject.html"><div class="icon-class"></div>ImmediateRenderObject</a></li>
<li><a href="../three/Intersect.html"><div class="icon-class"></div>Intersect</a></li>
<li><a href="../three/IParticleMaterial.html"><div class="icon-class"></div>IParticleMaterial</a></li>
<li><a href="../three/IRenderable.html"><div class="icon-class"></div>IRenderable</a></li>
<li><a href="../three/ITextureMapMaterial.html"><div class="icon-class"></div>ITextureMapMaterial</a></li>
<li><a href="../three/JSONLoader.html"><div class="icon-class"></div>JSONLoader</a></li>
<li><a href="../three/LatheGeometry.html"><div class="icon-class"></div>LatheGeometry</a></li>
<li><a href="../three/LensFlare.html"><div class="icon-class"></div>LensFlare</a></li>
<li><a href="../three/Light.html"><div class="icon-class"></div>Light</a></li>
<li><a href="../three/Line.html"><div class="icon-class"></div>Line</a></li>
<li><a href="../three/LineBasicMaterial.html"><div class="icon-class"></div>LineBasicMaterial</a></li>
<li><a href="../three/LineCurve.html"><div class="icon-class"></div>LineCurve</a></li>
<li><a href="../three/LineCurve3.html"><div class="icon-class"></div>LineCurve3</a></li>
<li><a href="../three/LoadCompleteCallback.html"><div class="icon-interface"></div>LoadCompleteCallback</a></li>
<li><a href="../three/LoadedCallback.html"><div class="icon-interface"></div>LoadedCallback</a></li>
<li><a href="../three/Loader.html"><div class="icon-class"></div>Loader</a></li>
<li><a href="../three/LoadProgressCallback.html"><div class="icon-interface"></div>LoadProgressCallback</a></li>
<li><a href="../three/LoadStartCallback.html"><div class="icon-interface"></div>LoadStartCallback</a></li>
<li><a href="../three/LOD.html"><div class="icon-class"></div>LOD</a></li>
<li><a href="../three/Material.html"><div class="icon-class"></div>Material</a></li>
<li><a href="../three/Mesh.html"><div class="icon-class"></div>Mesh</a></li>
<li><a href="../three/MeshBasicMaterial.html"><div class="icon-class"></div>MeshBasicMaterial</a></li>
<li><a href="../three/MeshDepthMaterial.html"><div class="icon-class"></div>MeshDepthMaterial</a></li>
<li><a href="../three/MeshFaceMaterial.html"><div class="icon-class"></div>MeshFaceMaterial</a></li>
<li><a href="../three/MeshLambertMaterial.html"><div class="icon-class"></div>MeshLambertMaterial</a></li>
<li><a href="../three/MeshNormalMaterial.html"><div class="icon-class"></div>MeshNormalMaterial</a></li>
<li><a href="../three/MeshPhongMaterial.html"><div class="icon-class"></div>MeshPhongMaterial</a></li>
<li><a href="../three/MorphAnimMesh.html"><div class="icon-class"></div>MorphAnimMesh</a></li>
<li><a href="../three/MorphColors.html"><div class="icon-class"></div>MorphColors</a></li>
<li><a href="../three/MorphTarget.html"><div class="icon-class"></div>MorphTarget</a></li>
<li><a href="../three/Object3D.html"><div class="icon-class"></div>Object3D</a></li>
<li><a href="../three/OctahedronGeometry.html"><div class="icon-class"></div>OctahedronGeometry</a></li>
<li><a href="../three/OrthographicCamera.html"><div class="icon-class"></div>OrthographicCamera</a></li>
<li><a href="../three/ParametricGeometry.html"><div class="icon-class"></div>ParametricGeometry</a></li>
<li><a href="../three/Particle.html"><div class="icon-class"></div>Particle</a></li>
<li><a href="../three/ParticleBasicMaterial.html"><div class="icon-class"></div>ParticleBasicMaterial</a></li>
<li><a href="../three/ParticleCanvasMaterial.html"><div class="icon-class"></div>ParticleCanvasMaterial</a></li>
<li><a href="../three/ParticleCanvasMaterialProgram.html"><div class="icon-interface"></div>ParticleCanvasMaterialProgram</a></li>
<li><a href="../three/ParticleSystem.html"><div class="icon-class"></div>ParticleSystem</a></li>
<li><a href="../three/Path.html"><div class="icon-class"></div>Path</a></li>
<li><a href="../three/PathAction.html"><div class="icon-class"></div>PathAction</a></li>
<li><a href="../three/PerspectiveCamera.html"><div class="icon-class"></div>PerspectiveCamera</a></li>
<li><a href="../three/PlaneGeometry.html"><div class="icon-class"></div>PlaneGeometry</a></li>
<li><a href="../three/PointLight.html"><div class="icon-class"></div>PointLight</a></li>
<li><a href="../three/PolyhedronGeometry.html"><div class="icon-class"></div>PolyhedronGeometry</a></li>
<li><a href="../three/PolyhedronGeometryVertex.html"><div class="icon-class"></div>PolyhedronGeometryVertex</a></li>
<li><a href="../three/Program.html"><div class="icon-class"></div>Program</a></li>
<li><a href="../three/Projector.html"><div class="icon-class"></div>Projector</a></li>
<li><a href="../three/ProjectorRenderData.html"><div class="icon-class"></div>ProjectorRenderData</a></li>
<li><a href="../three/QuadraticBezierCurve.html"><div class="icon-class"></div>QuadraticBezierCurve</a></li>
<li><a href="../three/QuadraticBezierCurve3.html"><div class="icon-class"></div>QuadraticBezierCurve3</a></li>
<li><a href="../three/Ray.html"><div class="icon-class"></div>Ray</a></li>
<li><a href="../three/Rectangle.html"><div class="icon-class"></div>Rectangle</a></li>
<li><a href="../three/RenderableFace.html"><div class="icon-class"></div>RenderableFace</a></li>
<li><a href="../three/RenderableFace3.html"><div class="icon-class"></div>RenderableFace3</a></li>
<li><a href="../three/RenderableFace4.html"><div class="icon-class"></div>RenderableFace4</a></li>
<li><a href="../three/RenderableLine.html"><div class="icon-class"></div>RenderableLine</a></li>
<li><a href="../three/RenderableObject.html"><div class="icon-class"></div>RenderableObject</a></li>
<li><a href="../three/RenderableParticle.html"><div class="icon-class"></div>RenderableParticle</a></li>
<li><a href="../three/RenderableVertex.html"><div class="icon-class"></div>RenderableVertex</a></li>
<li><a href="../three/Renderer.html"><div class="icon-class"></div>Renderer</a></li>
<li><a href="../three/RenderInts.html"><div class="icon-class"></div>RenderInts</a></li>
<li><a href="../three/Ribbon.html"><div class="icon-class"></div>Ribbon</a></li>
<li><a href="../three/Scene.html"><div class="icon-class"></div>Scene</a></li>
<li><a href="../three/ShaderMaterial.html"><div class="icon-class"></div>ShaderMaterial</a></li>
<li><a href="../three/ShadowCaster.html"><div class="icon-class"></div>ShadowCaster</a></li>
<li><div class="icon-class"></div><strong>ShadowMapPlugin</strong></li>
<li><a href="../three/Shape.html"><div class="icon-class"></div>Shape</a></li>
<li><a href="../three/ShapeGeometry.html"><div class="icon-class"></div>ShapeGeometry</a></li>
<li><a href="../three/SkinnedMesh.html"><div class="icon-class"></div>SkinnedMesh</a></li>
<li><a href="../three/SphereGeometry.html"><div class="icon-class"></div>SphereGeometry</a></li>
<li><a href="../three/SphericalReflectionMapping.html"><div class="icon-class"></div>SphericalReflectionMapping</a></li>
<li><a href="../three/SphericalRefractionMapping.html"><div class="icon-class"></div>SphericalRefractionMapping</a></li>
<li><a href="../three/SplineCurve.html"><div class="icon-class"></div>SplineCurve</a></li>
<li><a href="../three/SplineCurve3.html"><div class="icon-class"></div>SplineCurve3</a></li>
<li><a href="../three/SpotLight.html"><div class="icon-class"></div>SpotLight</a></li>
<li><a href="../three/Sprite.html"><div class="icon-class"></div>Sprite</a></li>
<li><a href="../three/SpriteAlignment.html"><div class="icon-class"></div>SpriteAlignment</a></li>
<li><a href="../three/TetrahedronGeometry.html"><div class="icon-class"></div>TetrahedronGeometry</a></li>
<li><a href="../three/TextGeometry.html"><div class="icon-class"></div>TextGeometry</a></li>
<li><a href="../three/Texture.html"><div class="icon-class"></div>Texture</a></li>
<li><a href="../three/TorusGeometry.html"><div class="icon-class"></div>TorusGeometry</a></li>
<li><a href="../three/TorusKnotGeometry.html"><div class="icon-class"></div>TorusKnotGeometry</a></li>
<li><a href="../three/TubeGeometry.html"><div class="icon-class"></div>TubeGeometry</a></li>
<li><a href="../three/Uniform.html"><div class="icon-class"></div>Uniform&lt;T&gt;</a></li>
<li><a href="../three/UniformsUtils.html"><div class="icon-class"></div>UniformsUtils</a></li>
<li><a href="../three/UV.html"><div class="icon-class"></div>UV</a></li>
<li><a href="../three/UVMapping.html"><div class="icon-class"></div>UVMapping</a></li>
<li><a href="../three/VirtualLight.html"><div class="icon-class"></div>VirtualLight</a></li>
<li><a href="../three/WebGLCamera.html"><div class="icon-class"></div>WebGLCamera</a></li>
<li><a href="../three/WebGLGeometry.html"><div class="icon-class"></div>WebGLGeometry</a></li>
<li><a href="../three/WebGLImageList.html"><div class="icon-class"></div>WebGLImageList</a></li>
<li><a href="../three/WebGLMaterial.html"><div class="icon-class"></div>WebGLMaterial</a></li>
<li><a href="../three/WebGLObject.html"><div class="icon-class"></div>WebGLObject</a></li>
<li><a href="../three/WebGLRenderer.html"><div class="icon-class"></div>WebGLRenderer</a></li>
<li><a href="../three/WebGLRendererInfo.html"><div class="icon-class"></div>WebGLRendererInfo</a></li>
<li><a href="../three/WebGLRendererMemoryInfo.html"><div class="icon-class"></div>WebGLRendererMemoryInfo</a></li>
<li><a href="../three/WebGLRendererRenderInfo.html"><div class="icon-class"></div>WebGLRendererRenderInfo</a></li>
<li><a href="../three/WebGLRenderTarget.html"><div class="icon-class"></div>WebGLRenderTarget</a></li>
<li><a href="../three/WebGLRenderTargetCube.html"><div class="icon-class"></div>WebGLRenderTargetCube</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../ThreeMath.html">ThreeMath</a></h2><h2><div class="icon-library"></div><a href="../TrackballControls.html">TrackballControls</a></h2><h2><div class="icon-library"></div><a href="../tween.html">tween</a></h2><h2><div class="icon-library"></div><a href="../vector_math.html">vector_math</a></h2></div>
<div class="content">
        <h2><strong>ShadowMapPlugin</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>@author alteredq / http://alteredqualia.com/</p>
<pre class="source">
class ShadowMapPlugin {

 static Projector __projector = new Projector();

 Frustum _frustum;
 Matrix4 _projScreenMatrix;
 Vector3 _min, _max;

 gl.RenderingContext _gl;
 WebGLRenderer _renderer;
 WebGLMaterial _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin;

 ShadowMapPlugin() :
   _frustum = new Frustum(),
   _projScreenMatrix = new Matrix4.identity(),
   _min = new Vector3.zero(),
   _max = new Vector3.zero();


 init( WebGLRenderer renderer ) {

   _gl = renderer.context;
   _renderer = renderer;

   var depthShader = ShaderLib[ "depthRGBA" ];
   var depthUniforms = UniformsUtils.clone( depthShader["uniforms"] );

   _depthMaterial = new WebGLMaterial.from(new ShaderMaterial( fragmentShader: depthShader["fragmentShader"], vertexShader: depthShader["vertexShader"], uniforms: depthUniforms ));
   _depthMaterialMorph =  new WebGLMaterial.from(new ShaderMaterial( fragmentShader: depthShader["fragmentShader"], vertexShader: depthShader["vertexShader"], uniforms: depthUniforms, morphTargets: true ));
   _depthMaterialSkin =  new WebGLMaterial.from(new ShaderMaterial( fragmentShader: depthShader["fragmentShader"], vertexShader: depthShader["vertexShader"], uniforms: depthUniforms, skinning: true ));
   _depthMaterialMorphSkin =  new WebGLMaterial.from(new ShaderMaterial( fragmentShader: depthShader["fragmentShader"], vertexShader: depthShader["vertexShader"], uniforms: depthUniforms, morphTargets: true, skinning: true ));

   _depthMaterial.shadowPass = true;
   _depthMaterialMorph.shadowPass = true;
   _depthMaterialSkin.shadowPass = true;
   _depthMaterialMorphSkin.shadowPass = true;

 }

 render( Scene scene, Camera camera, [num width, num height] ) {

   if ( ! ( _renderer.shadowMapEnabled &amp;&amp; _renderer.shadowMapAutoUpdate ) ) return;

   update( scene, camera );

 }

 update( Scene scene, Camera camera ) {

   var i, il, j, jl, n,

   shadowMap, shadowMatrix, shadowCamera,
   program, buffer, material,
   webglObject, object, light, virtualLight,
   renderList,

   lights = [],

   fog = null;

   // set GL state for depth map

   _gl.clearColor( 1, 1, 1, 1 );
   _gl.disable( gl.BLEND );

   _gl.enable( gl.CULL_FACE );
   _gl.frontFace( gl.CCW );

   if ( _renderer.shadowMapCullFrontFaces == CullFaceFront) {

     _gl.cullFace( gl.FRONT );

   } else {

     _gl.cullFace( gl.BACK );

   }

   _renderer.setDepthTest( true );

   // preprocess lights
   //  - skip lights that are not casting shadows
   //  - create virtual lights for cascaded shadow maps
   il = scene.lights.length;
   for ( i = 0; i &lt; il; i ++ ) {

     light = scene.lights[ i ];

     if ( ! light.castShadow ) continue;

     if ( ( light is DirectionalLight ) &amp;&amp; light.shadowCascade ) {

       for ( n = 0; n &lt; light.shadowCascadeCount; n ++ ) {

         if ( ! light.shadowCascadeArray[ n ] ) {

           virtualLight = createVirtualLight( light, n );
           virtualLight.originalCamera = camera;

           var gyro = new Gyroscope();
           gyro.position = light.shadowCascadeOffset;

           gyro.add( virtualLight );
           gyro.add( virtualLight.target );

           camera.add( gyro );

           light.shadowCascadeArray[ n ] = virtualLight;

           print( "Created virtualLight $virtualLight" );

         } else {

           virtualLight = light.shadowCascadeArray[ n ];

         }

         updateVirtualLight( light, n );

         lights.add(virtualLight);

       }

     } else {

       lights.add(light);

     }

   }

   // render depth map
   il = lights.length;
   for ( i = 0; i &lt; il; i ++ ) {

     light = lights[ i ];

     if ( light.shadowMap == null ) {

       var shadowFilter = LinearFilter;

       if ( _renderer.shadowMapType == PCFSoftShadowMap ) {

         shadowFilter = NearestFilter;

       }

       light.shadowMap = new WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, minFilter: shadowFilter, magFilter: shadowFilter, format: RGBAFormat );
       light.shadowMapSize = new Vector2( light.shadowMapWidth.toDouble(), light.shadowMapHeight.toDouble() );

       light.shadowMatrix = new Matrix4.identity();

     }

     if ( light.shadowCamera == null ) {

       if ( light is SpotLight ) {

         light.shadowCamera = new PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

       } else if ( light is DirectionalLight ) {

         light.shadowCamera = new OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

       } else {

         print( "Unsupported light type for shadow" );
         continue;

       }

       scene.add( light.shadowCamera );

       if ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();

     }

     if ( light.shadowCameraVisible &amp;&amp; light.cameraHelper == null ) {

       light.cameraHelper = new CameraHelper( light.shadowCamera );
       light.shadowCamera.add( light.cameraHelper );

     }

     if ( light is VirtualLight &amp;&amp; virtualLight.originalCamera == camera ) {

       updateShadowCamera( camera, light );

     }

     shadowMap = light.shadowMap;
     shadowMatrix = light.shadowMatrix;
     shadowCamera = light.shadowCamera;

     shadowCamera.position = light.matrixWorld.getTranslation();
     shadowCamera.lookAt( light.target.matrixWorld.getTranslation() );
     shadowCamera.updateMatrixWorld();

     shadowCamera.matrixWorldInverse.copyInverse(shadowCamera.matrixWorld);

     if ( light.cameraHelper != null ) light.cameraHelper.visible = light.shadowCameraVisible;
     if ( light.shadowCameraVisible ) light.cameraHelper.update();

     // compute shadow matrix

     shadowMatrix.setValues( 0.5, 0.0, 0.0, 0.5,
               0.0, 0.5, 0.0, 0.5,
               0.0, 0.0, 0.5, 0.5,
               0.0, 0.0, 0.0, 1.0 );

     shadowMatrix.multiply( shadowCamera.projectionMatrix );
     shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

     // update camera matrices and frustum

     _projScreenMatrix = shadowCamera.projectionMatrix * shadowCamera.matrixWorldInverse;
     _frustum.setFromMatrix( _projScreenMatrix );

     // render shadow map

     _renderer.setRenderTarget( shadowMap );
     _renderer.clear();

     // set object matrices &amp; frustum culling

     renderList = scene["__webglObjects"];

     jl = renderList.length;
     for ( j = 0; j &lt; jl; j ++ ) {

       webglObject = renderList[ j ];
       object = webglObject.object;

       webglObject.render = false;

       if ( object.visible &amp;&amp; object.castShadow ) {

         if ( ! ( object is Mesh ) || (object is ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.contains( object ) ) {

           webglObject._modelViewMatrix = shadowCamera.matrixWorldInverse * object.matrixWorld;

           webglObject.render = true;

         }

       }

     }

     // render regular objects

     var objectMaterial, useMorphing, useSkinning;

     jl = renderList.length;
     for ( j = 0; j &lt; jl; j ++ ) {

       webglObject = renderList[ j ];

       if ( webglObject.render ) {

         object = webglObject.object;
         buffer = webglObject.buffer;

         // culling is overriden globally for all objects
         // while rendering depth map

         // need to deal with MeshFaceMaterial somehow
         // in that case just use the first of geometry.materials for now
         // (proper solution would require to break objects by materials
         //  similarly to regular rendering and then set corresponding
         //  depth materials per each chunk instead of just once per object)

         objectMaterial = getObjectMaterial( object );

         useMorphing = object.geometry.morphTargets.length &gt; 0 &amp;&amp; objectMaterial.morphTargets;
         useSkinning = object is SkinnedMesh &amp;&amp; objectMaterial.skinning;

         if ( object.customDepthMaterial != null ) {

           material = object.customDepthMaterial;

         } else if ( useSkinning ) {

           material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

         } else if ( useMorphing ) {

           material = _depthMaterialMorph;

         } else {

           material = _depthMaterial;

         }

         if ( buffer is BufferGeometry ) {

           _renderer.renderBufferDirect( shadowCamera, scene.lights, fog, material, buffer, object );

         } else {

           _renderer.renderBuffer( shadowCamera, scene.lights, fog, material, buffer, object );

         }

       }

     }

     // set matrices and render immediate objects

     renderList = scene["__webglObjectsImmediate"];

     jl = renderList.length;
     for ( j = 0; j &lt; jl; j ++ ) {

       webglObject = renderList[ j ];
       object = webglObject.object;

       if ( object.visible &amp;&amp; object.castShadow ) {

         object._modelViewMatrix.multiply( shadowCamera.matrixWorldInverse, object.matrixWorld );

         _renderer.renderImmediateObject( shadowCamera, scene.lights, fog, _depthMaterial, object );

       }

     }

   }

   // restore GL state

   var clearColor = _renderer._clearColor;
   var clearAlpha = _renderer._clearAlpha;

   _gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
   _gl.enable( gl.BLEND );

   if ( _renderer.shadowMapCullFrontFaces == CullFaceFront ) {

     _gl.cullFace( gl.BACK );

   }

 }

 createVirtualLight( light, cascade ) {

   var virtualLight = new VirtualLight();

   virtualLight.onlyShadow = true;
   virtualLight.castShadow = true;

   virtualLight.shadowCameraNear = light.shadowCameraNear;
   virtualLight.shadowCameraFar = light.shadowCameraFar;

   virtualLight.shadowCameraLeft = light.shadowCameraLeft;
   virtualLight.shadowCameraRight = light.shadowCameraRight;
   virtualLight.shadowCameraBottom = light.shadowCameraBottom;
   virtualLight.shadowCameraTop = light.shadowCameraTop;

   virtualLight.shadowCameraVisible = light.shadowCameraVisible;

   virtualLight.shadowDarkness = light.shadowDarkness;

   virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
   virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
   virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

   virtualLight.pointsWorld = [];
   virtualLight.pointsFrustum = [];

   var pointsWorld = virtualLight.pointsWorld,
     pointsFrustum = virtualLight.pointsFrustum;

   for ( var i = 0; i &lt; 8; i ++ ) {

     pointsWorld[ i ] = new Vector3.zero();
     pointsFrustum[ i ] = new Vector3.zero();

   }

   var nearZ = light.shadowCascadeNearZ[ cascade ];
   var farZ = light.shadowCascadeFarZ[ cascade ];

   pointsFrustum[ 0 ].set( -1, -1, nearZ );
   pointsFrustum[ 1 ].set(  1, -1, nearZ );
   pointsFrustum[ 2 ].set( -1,  1, nearZ );
   pointsFrustum[ 3 ].set(  1,  1, nearZ );

   pointsFrustum[ 4 ].set( -1, -1, farZ );
   pointsFrustum[ 5 ].set(  1, -1, farZ );
   pointsFrustum[ 6 ].set( -1,  1, farZ );
   pointsFrustum[ 7 ].set(  1,  1, farZ );

   return virtualLight;

 }

 // Synchronize virtual light with the original light

 updateVirtualLight( light, cascade ) {

   var virtualLight = light.shadowCascadeArray[ cascade ];

   virtualLight.position.copy( light.position );
   virtualLight.target.position.copy( light.target.position );
   virtualLight.lookAt( virtualLight.target );

   virtualLight.shadowCameraVisible = light.shadowCameraVisible;
   virtualLight.shadowDarkness = light.shadowDarkness;

   virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

   var nearZ = light.shadowCascadeNearZ[ cascade ];
   var farZ = light.shadowCascadeFarZ[ cascade ];

   var pointsFrustum = virtualLight.pointsFrustum;

   pointsFrustum[ 0 ].z = nearZ;
   pointsFrustum[ 1 ].z = nearZ;
   pointsFrustum[ 2 ].z = nearZ;
   pointsFrustum[ 3 ].z = nearZ;

   pointsFrustum[ 4 ].z = farZ;
   pointsFrustum[ 5 ].z = farZ;
   pointsFrustum[ 6 ].z = farZ;
   pointsFrustum[ 7 ].z = farZ;

 }

 // Fit shadow camera's ortho frustum to camera frustum

 updateShadowCamera( camera, light ) {

   var shadowCamera = light.shadowCamera,
     pointsFrustum = light.pointsFrustum,
     pointsWorld = light.pointsWorld;

   _min.setValues( double.INFINITY, double.INFINITY, double.INFINITY );
   _max.setValues( double.NEGATIVE_INFINITY, double.NEGATIVE_INFINITY, double.NEGATIVE_INFINITY );

   for ( var i = 0; i &lt; 8; i ++ ) {

     var p = pointsWorld[ i ];

     p.copy( pointsFrustum[ i ] );
     __projector.unprojectVector( p, camera );

     shadowCamera.matrixWorldInverse.multiplyVector3( p );

     if ( p.x &lt; _min.x ) _min.x = p.x;
     if ( p.x &gt; _max.x ) _max.x = p.x;

     if ( p.y &lt; _min.y ) _min.y = p.y;
     if ( p.y &gt; _max.y ) _max.y = p.y;

     if ( p.z &lt; _min.z ) _min.z = p.z;
     if ( p.z &gt; _max.z ) _max.z = p.z;

   }

   shadowCamera.left = _min.x;
   shadowCamera.right = _max.x;
   shadowCamera.top = _max.y;
   shadowCamera.bottom = _min.y;

   // can't really fit near/far
   //shadowCamera.near = _min.z;
   //shadowCamera.far = _max.z;

   shadowCamera.updateProjectionMatrix();

 }

 // For the moment just ignore objects that have multiple materials with different animation methods
 // Only the first material will be taken into account for deciding which depth material to use for shadow maps

 getObjectMaterial( object ) {

   return object.material is MeshFaceMaterial ? object.geometry.materials[ 0 ] : object.material;

 }

}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>ShadowMapPlugin</strong>() <a class="anchor-link" href="#"
              title="Permalink to ShadowMapPlugin.ShadowMapPlugin">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="../dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="../dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="../dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html">Object</a> </div></div>
<pre class="source">
ShadowMapPlugin() :
 _frustum = new Frustum(),
 _projScreenMatrix = new Matrix4.identity(),
 _min = new Vector3.zero(),
 _max = new Vector3.zero();
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="createVirtualLight">
<button class="show-code">Code</button>
dynamic <strong>createVirtualLight</strong>(light, cascade) <a class="anchor-link" href="#createVirtualLight"
              title="Permalink to ShadowMapPlugin.createVirtualLight">#</a></h4>
<div class="doc">
<pre class="source">
createVirtualLight( light, cascade ) {

 var virtualLight = new VirtualLight();

 virtualLight.onlyShadow = true;
 virtualLight.castShadow = true;

 virtualLight.shadowCameraNear = light.shadowCameraNear;
 virtualLight.shadowCameraFar = light.shadowCameraFar;

 virtualLight.shadowCameraLeft = light.shadowCameraLeft;
 virtualLight.shadowCameraRight = light.shadowCameraRight;
 virtualLight.shadowCameraBottom = light.shadowCameraBottom;
 virtualLight.shadowCameraTop = light.shadowCameraTop;

 virtualLight.shadowCameraVisible = light.shadowCameraVisible;

 virtualLight.shadowDarkness = light.shadowDarkness;

 virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
 virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
 virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

 virtualLight.pointsWorld = [];
 virtualLight.pointsFrustum = [];

 var pointsWorld = virtualLight.pointsWorld,
   pointsFrustum = virtualLight.pointsFrustum;

 for ( var i = 0; i &lt; 8; i ++ ) {

   pointsWorld[ i ] = new Vector3.zero();
   pointsFrustum[ i ] = new Vector3.zero();

 }

 var nearZ = light.shadowCascadeNearZ[ cascade ];
 var farZ = light.shadowCascadeFarZ[ cascade ];

 pointsFrustum[ 0 ].set( -1, -1, nearZ );
 pointsFrustum[ 1 ].set(  1, -1, nearZ );
 pointsFrustum[ 2 ].set( -1,  1, nearZ );
 pointsFrustum[ 3 ].set(  1,  1, nearZ );

 pointsFrustum[ 4 ].set( -1, -1, farZ );
 pointsFrustum[ 5 ].set(  1, -1, farZ );
 pointsFrustum[ 6 ].set( -1,  1, farZ );
 pointsFrustum[ 7 ].set(  1,  1, farZ );

 return virtualLight;

}
</pre>
</div>
</div>
<div class="method"><h4 id="getObjectMaterial">
<button class="show-code">Code</button>
dynamic <strong>getObjectMaterial</strong>(object) <a class="anchor-link" href="#getObjectMaterial"
              title="Permalink to ShadowMapPlugin.getObjectMaterial">#</a></h4>
<div class="doc">
<pre class="source">
getObjectMaterial( object ) {

 return object.material is MeshFaceMaterial ? object.geometry.materials[ 0 ] : object.material;

}
</pre>
</div>
</div>
<div class="method"><h4 id="init">
<button class="show-code">Code</button>
dynamic <strong>init</strong>(<a href="../three/WebGLRenderer.html">WebGLRenderer</a> renderer) <a class="anchor-link" href="#init"
              title="Permalink to ShadowMapPlugin.init">#</a></h4>
<div class="doc">
<pre class="source">
init( WebGLRenderer renderer ) {

 _gl = renderer.context;
 _renderer = renderer;

 var depthShader = ShaderLib[ "depthRGBA" ];
 var depthUniforms = UniformsUtils.clone( depthShader["uniforms"] );

 _depthMaterial = new WebGLMaterial.from(new ShaderMaterial( fragmentShader: depthShader["fragmentShader"], vertexShader: depthShader["vertexShader"], uniforms: depthUniforms ));
 _depthMaterialMorph =  new WebGLMaterial.from(new ShaderMaterial( fragmentShader: depthShader["fragmentShader"], vertexShader: depthShader["vertexShader"], uniforms: depthUniforms, morphTargets: true ));
 _depthMaterialSkin =  new WebGLMaterial.from(new ShaderMaterial( fragmentShader: depthShader["fragmentShader"], vertexShader: depthShader["vertexShader"], uniforms: depthUniforms, skinning: true ));
 _depthMaterialMorphSkin =  new WebGLMaterial.from(new ShaderMaterial( fragmentShader: depthShader["fragmentShader"], vertexShader: depthShader["vertexShader"], uniforms: depthUniforms, morphTargets: true, skinning: true ));

 _depthMaterial.shadowPass = true;
 _depthMaterialMorph.shadowPass = true;
 _depthMaterialSkin.shadowPass = true;
 _depthMaterialMorphSkin.shadowPass = true;

}
</pre>
</div>
</div>
<div class="method"><h4 id="render">
<button class="show-code">Code</button>
dynamic <strong>render</strong>(<a href="../three/Scene.html">Scene</a> scene, <a href="../three/Camera.html">Camera</a> camera, [<a href="http://api.dartlang.org/dart_core/num.html">num</a> width, <a href="http://api.dartlang.org/dart_core/num.html">num</a> height]) <a class="anchor-link" href="#render"
              title="Permalink to ShadowMapPlugin.render">#</a></h4>
<div class="doc">
<pre class="source">
render( Scene scene, Camera camera, [num width, num height] ) {

 if ( ! ( _renderer.shadowMapEnabled &amp;&amp; _renderer.shadowMapAutoUpdate ) ) return;

 update( scene, camera );

}
</pre>
</div>
</div>
<div class="method"><h4 id="update">
<button class="show-code">Code</button>
dynamic <strong>update</strong>(<a href="../three/Scene.html">Scene</a> scene, <a href="../three/Camera.html">Camera</a> camera) <a class="anchor-link" href="#update"
              title="Permalink to ShadowMapPlugin.update">#</a></h4>
<div class="doc">
<pre class="source">
update( Scene scene, Camera camera ) {

 var i, il, j, jl, n,

 shadowMap, shadowMatrix, shadowCamera,
 program, buffer, material,
 webglObject, object, light, virtualLight,
 renderList,

 lights = [],

 fog = null;

 // set GL state for depth map

 _gl.clearColor( 1, 1, 1, 1 );
 _gl.disable( gl.BLEND );

 _gl.enable( gl.CULL_FACE );
 _gl.frontFace( gl.CCW );

 if ( _renderer.shadowMapCullFrontFaces == CullFaceFront) {

   _gl.cullFace( gl.FRONT );

 } else {

   _gl.cullFace( gl.BACK );

 }

 _renderer.setDepthTest( true );

 // preprocess lights
 //  - skip lights that are not casting shadows
 //  - create virtual lights for cascaded shadow maps
 il = scene.lights.length;
 for ( i = 0; i &lt; il; i ++ ) {

   light = scene.lights[ i ];

   if ( ! light.castShadow ) continue;

   if ( ( light is DirectionalLight ) &amp;&amp; light.shadowCascade ) {

     for ( n = 0; n &lt; light.shadowCascadeCount; n ++ ) {

       if ( ! light.shadowCascadeArray[ n ] ) {

         virtualLight = createVirtualLight( light, n );
         virtualLight.originalCamera = camera;

         var gyro = new Gyroscope();
         gyro.position = light.shadowCascadeOffset;

         gyro.add( virtualLight );
         gyro.add( virtualLight.target );

         camera.add( gyro );

         light.shadowCascadeArray[ n ] = virtualLight;

         print( "Created virtualLight $virtualLight" );

       } else {

         virtualLight = light.shadowCascadeArray[ n ];

       }

       updateVirtualLight( light, n );

       lights.add(virtualLight);

     }

   } else {

     lights.add(light);

   }

 }

 // render depth map
 il = lights.length;
 for ( i = 0; i &lt; il; i ++ ) {

   light = lights[ i ];

   if ( light.shadowMap == null ) {

     var shadowFilter = LinearFilter;

     if ( _renderer.shadowMapType == PCFSoftShadowMap ) {

       shadowFilter = NearestFilter;

     }

     light.shadowMap = new WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, minFilter: shadowFilter, magFilter: shadowFilter, format: RGBAFormat );
     light.shadowMapSize = new Vector2( light.shadowMapWidth.toDouble(), light.shadowMapHeight.toDouble() );

     light.shadowMatrix = new Matrix4.identity();

   }

   if ( light.shadowCamera == null ) {

     if ( light is SpotLight ) {

       light.shadowCamera = new PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

     } else if ( light is DirectionalLight ) {

       light.shadowCamera = new OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

     } else {

       print( "Unsupported light type for shadow" );
       continue;

     }

     scene.add( light.shadowCamera );

     if ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();

   }

   if ( light.shadowCameraVisible &amp;&amp; light.cameraHelper == null ) {

     light.cameraHelper = new CameraHelper( light.shadowCamera );
     light.shadowCamera.add( light.cameraHelper );

   }

   if ( light is VirtualLight &amp;&amp; virtualLight.originalCamera == camera ) {

     updateShadowCamera( camera, light );

   }

   shadowMap = light.shadowMap;
   shadowMatrix = light.shadowMatrix;
   shadowCamera = light.shadowCamera;

   shadowCamera.position = light.matrixWorld.getTranslation();
   shadowCamera.lookAt( light.target.matrixWorld.getTranslation() );
   shadowCamera.updateMatrixWorld();

   shadowCamera.matrixWorldInverse.copyInverse(shadowCamera.matrixWorld);

   if ( light.cameraHelper != null ) light.cameraHelper.visible = light.shadowCameraVisible;
   if ( light.shadowCameraVisible ) light.cameraHelper.update();

   // compute shadow matrix

   shadowMatrix.setValues( 0.5, 0.0, 0.0, 0.5,
             0.0, 0.5, 0.0, 0.5,
             0.0, 0.0, 0.5, 0.5,
             0.0, 0.0, 0.0, 1.0 );

   shadowMatrix.multiply( shadowCamera.projectionMatrix );
   shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

   // update camera matrices and frustum

   _projScreenMatrix = shadowCamera.projectionMatrix * shadowCamera.matrixWorldInverse;
   _frustum.setFromMatrix( _projScreenMatrix );

   // render shadow map

   _renderer.setRenderTarget( shadowMap );
   _renderer.clear();

   // set object matrices &amp; frustum culling

   renderList = scene["__webglObjects"];

   jl = renderList.length;
   for ( j = 0; j &lt; jl; j ++ ) {

     webglObject = renderList[ j ];
     object = webglObject.object;

     webglObject.render = false;

     if ( object.visible &amp;&amp; object.castShadow ) {

       if ( ! ( object is Mesh ) || (object is ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.contains( object ) ) {

         webglObject._modelViewMatrix = shadowCamera.matrixWorldInverse * object.matrixWorld;

         webglObject.render = true;

       }

     }

   }

   // render regular objects

   var objectMaterial, useMorphing, useSkinning;

   jl = renderList.length;
   for ( j = 0; j &lt; jl; j ++ ) {

     webglObject = renderList[ j ];

     if ( webglObject.render ) {

       object = webglObject.object;
       buffer = webglObject.buffer;

       // culling is overriden globally for all objects
       // while rendering depth map

       // need to deal with MeshFaceMaterial somehow
       // in that case just use the first of geometry.materials for now
       // (proper solution would require to break objects by materials
       //  similarly to regular rendering and then set corresponding
       //  depth materials per each chunk instead of just once per object)

       objectMaterial = getObjectMaterial( object );

       useMorphing = object.geometry.morphTargets.length &gt; 0 &amp;&amp; objectMaterial.morphTargets;
       useSkinning = object is SkinnedMesh &amp;&amp; objectMaterial.skinning;

       if ( object.customDepthMaterial != null ) {

         material = object.customDepthMaterial;

       } else if ( useSkinning ) {

         material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

       } else if ( useMorphing ) {

         material = _depthMaterialMorph;

       } else {

         material = _depthMaterial;

       }

       if ( buffer is BufferGeometry ) {

         _renderer.renderBufferDirect( shadowCamera, scene.lights, fog, material, buffer, object );

       } else {

         _renderer.renderBuffer( shadowCamera, scene.lights, fog, material, buffer, object );

       }

     }

   }

   // set matrices and render immediate objects

   renderList = scene["__webglObjectsImmediate"];

   jl = renderList.length;
   for ( j = 0; j &lt; jl; j ++ ) {

     webglObject = renderList[ j ];
     object = webglObject.object;

     if ( object.visible &amp;&amp; object.castShadow ) {

       object._modelViewMatrix.multiply( shadowCamera.matrixWorldInverse, object.matrixWorld );

       _renderer.renderImmediateObject( shadowCamera, scene.lights, fog, _depthMaterial, object );

     }

   }

 }

 // restore GL state

 var clearColor = _renderer._clearColor;
 var clearAlpha = _renderer._clearAlpha;

 _gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
 _gl.enable( gl.BLEND );

 if ( _renderer.shadowMapCullFrontFaces == CullFaceFront ) {

   _gl.cullFace( gl.BACK );

 }

}
</pre>
</div>
</div>
<div class="method"><h4 id="updateShadowCamera">
<button class="show-code">Code</button>
dynamic <strong>updateShadowCamera</strong>(camera, light) <a class="anchor-link" href="#updateShadowCamera"
              title="Permalink to ShadowMapPlugin.updateShadowCamera">#</a></h4>
<div class="doc">
<pre class="source">
updateShadowCamera( camera, light ) {

 var shadowCamera = light.shadowCamera,
   pointsFrustum = light.pointsFrustum,
   pointsWorld = light.pointsWorld;

 _min.setValues( double.INFINITY, double.INFINITY, double.INFINITY );
 _max.setValues( double.NEGATIVE_INFINITY, double.NEGATIVE_INFINITY, double.NEGATIVE_INFINITY );

 for ( var i = 0; i &lt; 8; i ++ ) {

   var p = pointsWorld[ i ];

   p.copy( pointsFrustum[ i ] );
   __projector.unprojectVector( p, camera );

   shadowCamera.matrixWorldInverse.multiplyVector3( p );

   if ( p.x &lt; _min.x ) _min.x = p.x;
   if ( p.x &gt; _max.x ) _max.x = p.x;

   if ( p.y &lt; _min.y ) _min.y = p.y;
   if ( p.y &gt; _max.y ) _max.y = p.y;

   if ( p.z &lt; _min.z ) _min.z = p.z;
   if ( p.z &gt; _max.z ) _max.z = p.z;

 }

 shadowCamera.left = _min.x;
 shadowCamera.right = _max.x;
 shadowCamera.top = _max.y;
 shadowCamera.bottom = _min.y;

 // can't really fit near/far
 //shadowCamera.near = _min.z;
 //shadowCamera.far = _max.z;

 shadowCamera.updateProjectionMatrix();

}
</pre>
</div>
</div>
<div class="method"><h4 id="updateVirtualLight">
<button class="show-code">Code</button>
dynamic <strong>updateVirtualLight</strong>(light, cascade) <a class="anchor-link" href="#updateVirtualLight"
              title="Permalink to ShadowMapPlugin.updateVirtualLight">#</a></h4>
<div class="doc">
<pre class="source">
updateVirtualLight( light, cascade ) {

 var virtualLight = light.shadowCascadeArray[ cascade ];

 virtualLight.position.copy( light.position );
 virtualLight.target.position.copy( light.target.position );
 virtualLight.lookAt( virtualLight.target );

 virtualLight.shadowCameraVisible = light.shadowCameraVisible;
 virtualLight.shadowDarkness = light.shadowDarkness;

 virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

 var nearZ = light.shadowCascadeNearZ[ cascade ];
 var farZ = light.shadowCascadeFarZ[ cascade ];

 var pointsFrustum = virtualLight.pointsFrustum;

 pointsFrustum[ 0 ].z = nearZ;
 pointsFrustum[ 1 ].z = nearZ;
 pointsFrustum[ 2 ].z = nearZ;
 pointsFrustum[ 3 ].z = nearZ;

 pointsFrustum[ 4 ].z = farZ;
 pointsFrustum[ 5 ].z = farZ;
 pointsFrustum[ 6 ].z = farZ;
 pointsFrustum[ 7 ].z = farZ;

}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-11-08 17:35:32.603</div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
