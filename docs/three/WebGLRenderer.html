        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>WebGLRenderer class / three Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="three" data-type="WebGLRenderer">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../three.html">three</a> &rsaquo; <a href="../three/WebGLRenderer.html">WebGLRenderer</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../CurveUtils.html">CurveUtils</a></h2><h2><div class="icon-library"></div><a href="../FirstPersonControls.html">FirstPersonControls</a></h2><h2><div class="icon-library"></div><a href="../FontUtils.html">FontUtils</a></h2><h2><div class="icon-library"></div><a href="../GeometryUtils.html">GeometryUtils</a></h2><h2><div class="icon-library"></div><a href="../ImageUtils.html">ImageUtils</a></h2><h2><div class="icon-library"></div><a href="../SceneUtils.html">SceneUtils</a></h2><h2><div class="icon-library"></div><a href="../ShaderUtils.html">ShaderUtils</a></h2><h2><div class="icon-library"></div><a href="../ShapeUtils.html">ShapeUtils</a></h2><h2><div class="icon-library"></div><a href="../three.html">three</a></h2><ul class="icon">
<li><a href="../three/AmbientLight.html"><div class="icon-class"></div>AmbientLight</a></li>
<li><a href="../three/ArcCurve.html"><div class="icon-class"></div>ArcCurve</a></li>
<li><a href="../three/ArrowHelper.html"><div class="icon-class"></div>ArrowHelper</a></li>
<li><a href="../three/Attribute.html"><div class="icon-class"></div>Attribute&lt;T&gt;</a></li>
<li><a href="../three/AxisHelper.html"><div class="icon-class"></div>AxisHelper</a></li>
<li><a href="../three/Bone.html"><div class="icon-class"></div>Bone</a></li>
<li><a href="../three/BoundingBox.html"><div class="icon-class"></div>BoundingBox</a></li>
<li><a href="../three/BoundingSphere.html"><div class="icon-class"></div>BoundingSphere</a></li>
<li><a href="../three/Buffer.html"><div class="icon-class"></div>Buffer</a></li>
<li><a href="../three/BufferGeometry.html"><div class="icon-class"></div>BufferGeometry</a></li>
<li><a href="../three/Camera.html"><div class="icon-class"></div>Camera</a></li>
<li><a href="../three/CameraHelper.html"><div class="icon-class"></div>CameraHelper</a></li>
<li><a href="../three/CanvasRenderData.html"><div class="icon-class"></div>CanvasRenderData</a></li>
<li><a href="../three/CanvasRenderer.html"><div class="icon-class"></div>CanvasRenderer</a></li>
<li><a href="../three/Chunk.html"><div class="icon-class"></div>Chunk</a></li>
<li><a href="../three/CircleGeometry.html"><div class="icon-class"></div>CircleGeometry</a></li>
<li><a href="../three/ClosedSplineCurve3.html"><div class="icon-class"></div>ClosedSplineCurve3</a></li>
<li><a href="../three/Color.html"><div class="icon-class"></div>Color</a></li>
<li><a href="../three/CompressedTexture.html"><div class="icon-class"></div>CompressedTexture</a></li>
<li><a href="../three/ConvexGeometry.html"><div class="icon-class"></div>ConvexGeometry</a></li>
<li><a href="../three/CSS3DObject.html"><div class="icon-class"></div>CSS3DObject</a></li>
<li><a href="../three/CSS3DRenderer.html"><div class="icon-class"></div>CSS3DRenderer</a></li>
<li><a href="../three/CubeGeometry.html"><div class="icon-class"></div>CubeGeometry</a></li>
<li><a href="../three/CubeGeomSides.html"><div class="icon-class"></div>CubeGeomSides</a></li>
<li><a href="../three/CubeReflectionMapping.html"><div class="icon-class"></div>CubeReflectionMapping</a></li>
<li><a href="../three/CubeRefractionMapping.html"><div class="icon-class"></div>CubeRefractionMapping</a></li>
<li><a href="../three/CubicBezierCurve.html"><div class="icon-class"></div>CubicBezierCurve</a></li>
<li><a href="../three/CubicBezierCurve3.html"><div class="icon-class"></div>CubicBezierCurve3</a></li>
<li><a href="../three/Curve.html"><div class="icon-class"></div>Curve&lt;V&gt;</a></li>
<li><a href="../three/Curve2D.html"><div class="icon-class"></div>Curve2D</a></li>
<li><a href="../three/Curve3D.html"><div class="icon-class"></div>Curve3D</a></li>
<li><a href="../three/CurvePath.html"><div class="icon-class"></div>CurvePath</a></li>
<li><a href="../three/CylinderGeometry.html"><div class="icon-class"></div>CylinderGeometry</a></li>
<li><a href="../three/DataTexture.html"><div class="icon-class"></div>DataTexture</a></li>
<li><a href="../three/DirectionalLight.html"><div class="icon-class"></div>DirectionalLight</a></li>
<li><a href="../three/EllipseCurve.html"><div class="icon-class"></div>EllipseCurve</a></li>
<li><a href="../three/EventEmitter.html"><div class="icon-class"></div>EventEmitter</a></li>
<li><a href="../three/EventEmitterEvent.html"><div class="icon-class"></div>EventEmitterEvent</a></li>
<li><a href="../three/ExtrudeGeometry.html"><div class="icon-class"></div>ExtrudeGeometry</a></li>
<li><a href="../three/ExtrudeGeometryWorldUVGenerator.html"><div class="icon-class"></div>ExtrudeGeometryWorldUVGenerator</a></li>
<li><a href="../three/Face.html"><div class="icon-class"></div>Face</a></li>
<li><a href="../three/Face3.html"><div class="icon-class"></div>Face3</a></li>
<li><a href="../three/Face4.html"><div class="icon-class"></div>Face4</a></li>
<li><a href="../three/Fog.html"><div class="icon-class"></div>Fog</a></li>
<li><a href="../three/FogExp2.html"><div class="icon-class"></div>FogExp2</a></li>
<li><a href="../three/FogLinear.html"><div class="icon-class"></div>FogLinear</a></li>
<li><a href="../three/Frustum.html"><div class="icon-class"></div>Frustum</a></li>
<li><a href="../three/Geometry.html"><div class="icon-class"></div>Geometry</a></li>
<li><a href="../three/GeometryAttribute.html"><div class="icon-class"></div>GeometryAttribute&lt;T&gt;</a></li>
<li><a href="../three/Gyroscope.html"><div class="icon-class"></div>Gyroscope</a></li>
<li><a href="../three/HemisphereLight.html"><div class="icon-class"></div>HemisphereLight</a></li>
<li><a href="../three/IcosahedronGeometry.html"><div class="icon-class"></div>IcosahedronGeometry</a></li>
<li><a href="../three/ImageList.html"><div class="icon-class"></div>ImageList</a></li>
<li><a href="../three/ImageLoader.html"><div class="icon-class"></div>ImageLoader</a></li>
<li><a href="../three/IMaterial.html"><div class="icon-class"></div>IMaterial</a></li>
<li><a href="../three/ImmediateRenderObject.html"><div class="icon-class"></div>ImmediateRenderObject</a></li>
<li><a href="../three/Intersect.html"><div class="icon-class"></div>Intersect</a></li>
<li><a href="../three/IParticleMaterial.html"><div class="icon-class"></div>IParticleMaterial</a></li>
<li><a href="../three/IRenderable.html"><div class="icon-class"></div>IRenderable</a></li>
<li><a href="../three/ITextureMapMaterial.html"><div class="icon-class"></div>ITextureMapMaterial</a></li>
<li><a href="../three/JSONLoader.html"><div class="icon-class"></div>JSONLoader</a></li>
<li><a href="../three/LatheGeometry.html"><div class="icon-class"></div>LatheGeometry</a></li>
<li><a href="../three/LensFlare.html"><div class="icon-class"></div>LensFlare</a></li>
<li><a href="../three/Light.html"><div class="icon-class"></div>Light</a></li>
<li><a href="../three/Line.html"><div class="icon-class"></div>Line</a></li>
<li><a href="../three/LineBasicMaterial.html"><div class="icon-class"></div>LineBasicMaterial</a></li>
<li><a href="../three/LineCurve.html"><div class="icon-class"></div>LineCurve</a></li>
<li><a href="../three/LineCurve3.html"><div class="icon-class"></div>LineCurve3</a></li>
<li><a href="../three/LoadCompleteCallback.html"><div class="icon-interface"></div>LoadCompleteCallback</a></li>
<li><a href="../three/LoadedCallback.html"><div class="icon-interface"></div>LoadedCallback</a></li>
<li><a href="../three/Loader.html"><div class="icon-class"></div>Loader</a></li>
<li><a href="../three/LoadProgressCallback.html"><div class="icon-interface"></div>LoadProgressCallback</a></li>
<li><a href="../three/LoadStartCallback.html"><div class="icon-interface"></div>LoadStartCallback</a></li>
<li><a href="../three/LOD.html"><div class="icon-class"></div>LOD</a></li>
<li><a href="../three/Material.html"><div class="icon-class"></div>Material</a></li>
<li><a href="../three/Mesh.html"><div class="icon-class"></div>Mesh</a></li>
<li><a href="../three/MeshBasicMaterial.html"><div class="icon-class"></div>MeshBasicMaterial</a></li>
<li><a href="../three/MeshDepthMaterial.html"><div class="icon-class"></div>MeshDepthMaterial</a></li>
<li><a href="../three/MeshFaceMaterial.html"><div class="icon-class"></div>MeshFaceMaterial</a></li>
<li><a href="../three/MeshLambertMaterial.html"><div class="icon-class"></div>MeshLambertMaterial</a></li>
<li><a href="../three/MeshNormalMaterial.html"><div class="icon-class"></div>MeshNormalMaterial</a></li>
<li><a href="../three/MeshPhongMaterial.html"><div class="icon-class"></div>MeshPhongMaterial</a></li>
<li><a href="../three/MorphAnimMesh.html"><div class="icon-class"></div>MorphAnimMesh</a></li>
<li><a href="../three/MorphColors.html"><div class="icon-class"></div>MorphColors</a></li>
<li><a href="../three/MorphTarget.html"><div class="icon-class"></div>MorphTarget</a></li>
<li><a href="../three/Object3D.html"><div class="icon-class"></div>Object3D</a></li>
<li><a href="../three/OctahedronGeometry.html"><div class="icon-class"></div>OctahedronGeometry</a></li>
<li><a href="../three/OrthographicCamera.html"><div class="icon-class"></div>OrthographicCamera</a></li>
<li><a href="../three/ParametricGeometry.html"><div class="icon-class"></div>ParametricGeometry</a></li>
<li><a href="../three/Particle.html"><div class="icon-class"></div>Particle</a></li>
<li><a href="../three/ParticleBasicMaterial.html"><div class="icon-class"></div>ParticleBasicMaterial</a></li>
<li><a href="../three/ParticleCanvasMaterial.html"><div class="icon-class"></div>ParticleCanvasMaterial</a></li>
<li><a href="../three/ParticleCanvasMaterialProgram.html"><div class="icon-interface"></div>ParticleCanvasMaterialProgram</a></li>
<li><a href="../three/ParticleSystem.html"><div class="icon-class"></div>ParticleSystem</a></li>
<li><a href="../three/Path.html"><div class="icon-class"></div>Path</a></li>
<li><a href="../three/PathAction.html"><div class="icon-class"></div>PathAction</a></li>
<li><a href="../three/PerspectiveCamera.html"><div class="icon-class"></div>PerspectiveCamera</a></li>
<li><a href="../three/PlaneGeometry.html"><div class="icon-class"></div>PlaneGeometry</a></li>
<li><a href="../three/PointLight.html"><div class="icon-class"></div>PointLight</a></li>
<li><a href="../three/PolyhedronGeometry.html"><div class="icon-class"></div>PolyhedronGeometry</a></li>
<li><a href="../three/PolyhedronGeometryVertex.html"><div class="icon-class"></div>PolyhedronGeometryVertex</a></li>
<li><a href="../three/Program.html"><div class="icon-class"></div>Program</a></li>
<li><a href="../three/Projector.html"><div class="icon-class"></div>Projector</a></li>
<li><a href="../three/ProjectorRenderData.html"><div class="icon-class"></div>ProjectorRenderData</a></li>
<li><a href="../three/QuadraticBezierCurve.html"><div class="icon-class"></div>QuadraticBezierCurve</a></li>
<li><a href="../three/QuadraticBezierCurve3.html"><div class="icon-class"></div>QuadraticBezierCurve3</a></li>
<li><a href="../three/Ray.html"><div class="icon-class"></div>Ray</a></li>
<li><a href="../three/Rectangle.html"><div class="icon-class"></div>Rectangle</a></li>
<li><a href="../three/RenderableFace.html"><div class="icon-class"></div>RenderableFace</a></li>
<li><a href="../three/RenderableFace3.html"><div class="icon-class"></div>RenderableFace3</a></li>
<li><a href="../three/RenderableFace4.html"><div class="icon-class"></div>RenderableFace4</a></li>
<li><a href="../three/RenderableLine.html"><div class="icon-class"></div>RenderableLine</a></li>
<li><a href="../three/RenderableObject.html"><div class="icon-class"></div>RenderableObject</a></li>
<li><a href="../three/RenderableParticle.html"><div class="icon-class"></div>RenderableParticle</a></li>
<li><a href="../three/RenderableVertex.html"><div class="icon-class"></div>RenderableVertex</a></li>
<li><a href="../three/Renderer.html"><div class="icon-class"></div>Renderer</a></li>
<li><a href="../three/RenderInts.html"><div class="icon-class"></div>RenderInts</a></li>
<li><a href="../three/Ribbon.html"><div class="icon-class"></div>Ribbon</a></li>
<li><a href="../three/Scene.html"><div class="icon-class"></div>Scene</a></li>
<li><a href="../three/ShaderMaterial.html"><div class="icon-class"></div>ShaderMaterial</a></li>
<li><a href="../three/ShadowCaster.html"><div class="icon-class"></div>ShadowCaster</a></li>
<li><a href="../three/ShadowMapPlugin.html"><div class="icon-class"></div>ShadowMapPlugin</a></li>
<li><a href="../three/Shape.html"><div class="icon-class"></div>Shape</a></li>
<li><a href="../three/ShapeGeometry.html"><div class="icon-class"></div>ShapeGeometry</a></li>
<li><a href="../three/SkinnedMesh.html"><div class="icon-class"></div>SkinnedMesh</a></li>
<li><a href="../three/SphereGeometry.html"><div class="icon-class"></div>SphereGeometry</a></li>
<li><a href="../three/SphericalReflectionMapping.html"><div class="icon-class"></div>SphericalReflectionMapping</a></li>
<li><a href="../three/SphericalRefractionMapping.html"><div class="icon-class"></div>SphericalRefractionMapping</a></li>
<li><a href="../three/SplineCurve.html"><div class="icon-class"></div>SplineCurve</a></li>
<li><a href="../three/SplineCurve3.html"><div class="icon-class"></div>SplineCurve3</a></li>
<li><a href="../three/SpotLight.html"><div class="icon-class"></div>SpotLight</a></li>
<li><a href="../three/Sprite.html"><div class="icon-class"></div>Sprite</a></li>
<li><a href="../three/SpriteAlignment.html"><div class="icon-class"></div>SpriteAlignment</a></li>
<li><a href="../three/TetrahedronGeometry.html"><div class="icon-class"></div>TetrahedronGeometry</a></li>
<li><a href="../three/TextGeometry.html"><div class="icon-class"></div>TextGeometry</a></li>
<li><a href="../three/Texture.html"><div class="icon-class"></div>Texture</a></li>
<li><a href="../three/TorusGeometry.html"><div class="icon-class"></div>TorusGeometry</a></li>
<li><a href="../three/TorusKnotGeometry.html"><div class="icon-class"></div>TorusKnotGeometry</a></li>
<li><a href="../three/TubeGeometry.html"><div class="icon-class"></div>TubeGeometry</a></li>
<li><a href="../three/Uniform.html"><div class="icon-class"></div>Uniform&lt;T&gt;</a></li>
<li><a href="../three/UniformsUtils.html"><div class="icon-class"></div>UniformsUtils</a></li>
<li><a href="../three/UV.html"><div class="icon-class"></div>UV</a></li>
<li><a href="../three/UVMapping.html"><div class="icon-class"></div>UVMapping</a></li>
<li><a href="../three/VirtualLight.html"><div class="icon-class"></div>VirtualLight</a></li>
<li><a href="../three/WebGLCamera.html"><div class="icon-class"></div>WebGLCamera</a></li>
<li><a href="../three/WebGLGeometry.html"><div class="icon-class"></div>WebGLGeometry</a></li>
<li><a href="../three/WebGLImageList.html"><div class="icon-class"></div>WebGLImageList</a></li>
<li><a href="../three/WebGLMaterial.html"><div class="icon-class"></div>WebGLMaterial</a></li>
<li><a href="../three/WebGLObject.html"><div class="icon-class"></div>WebGLObject</a></li>
<li><div class="icon-class"></div><strong>WebGLRenderer</strong></li>
<li><a href="../three/WebGLRendererInfo.html"><div class="icon-class"></div>WebGLRendererInfo</a></li>
<li><a href="../three/WebGLRendererMemoryInfo.html"><div class="icon-class"></div>WebGLRendererMemoryInfo</a></li>
<li><a href="../three/WebGLRendererRenderInfo.html"><div class="icon-class"></div>WebGLRendererRenderInfo</a></li>
<li><a href="../three/WebGLRenderTarget.html"><div class="icon-class"></div>WebGLRenderTarget</a></li>
<li><a href="../three/WebGLRenderTargetCube.html"><div class="icon-class"></div>WebGLRenderTargetCube</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../ThreeMath.html">ThreeMath</a></h2><h2><div class="icon-library"></div><a href="../TrackballControls.html">TrackballControls</a></h2><h2><div class="icon-library"></div><a href="../tween.html">tween</a></h2><h2><div class="icon-library"></div><a href="../vector_math.html">vector_math</a></h2></div>
<div class="content">
        <h2><strong>WebGLRenderer</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class WebGLRenderer implements Renderer {

 static const String PRECISION_HIGH = 'highp';

 CanvasElement canvas;
 gl.RenderingContext _gl;

 String precision;

 Color _clearColor;
 num _clearAlpha;
 double devicePixelRatio;

	bool alpha,
		   premultipliedAlpha,
		   antialias,
		   stencil,
		   preserveDrawingBuffer;

 bool autoClear,
		autoClearColor,
		autoClearDepth,
		autoClearStencil;

	// scene graph

 bool sortObjects,
	autoUpdateObjects,
	autoUpdateScene;

	// physically based shading

	bool gammaInput,
	gammaOutput,
	physicallyBasedShading;

	// shadow map

	bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapDebug,
	shadowMapCascade;
	int shadowMapType,
	shadowMapCullFrontFaces;

	// morphs

	int maxMorphTargets,
		maxMorphNormals;

	// flags

	bool autoScaleCubemaps;

	// custom render plugins

	List renderPluginsPre,
		renderPluginsPost;


	WebGLRendererInfo info;

	/** Internal properties **/

	List&lt;Program&gt; _programs;
	int _programs_counter;

	// internal state cache
	var _currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = -1,
		_currentGeometryGroupHash = null,
		_currentCamera = null,
		_geometryGroupCounter = 0,
	  _usedTextureUnits = 0,
	  _enabledAttributes = {};

	// GL state cache
	var _oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = 0,
	_viewportHeight = 0,
	_currentWidth = 0,
	_currentHeight = 0;

	 // frustum
	Frustum _frustum;

  // camera matrices cache
 Matrix4 _projScreenMatrix,
         _projScreenMatrixPS;

 Vector3 _vector3;

 // light arrays cache
 Vector3 _direction;

 Map _lights;
 bool _lightsNeedUpdate;

 // GL Extensions
 gl.OesTextureFloat _glExtensionTextureFloat;
 gl.OesStandardDerivatives _glExtensionStandardDerivatives;
 gl.ExtTextureFilterAnisotropic _glExtensionTextureFilterAnisotropic;
 gl.CompressedTextureS3TC _glExtensionCompressedTextureS3TC;

 var maxAnisotropy;

 bool supportsVertexTextures,
 	   supportsBoneTextures;

 var shadowMapPlugin;

 num maxTextures, maxVertexTextures, maxTextureSize, maxCubemapSize;

 WebGLRenderer( {	this.canvas,
 					this.precision: PRECISION_HIGH,
 					this.alpha: true,
			      this.premultipliedAlpha: true,
		        this.antialias: true,
	          this.stencil: true,
 					this.preserveDrawingBuffer: false,
 					num clearColorHex: 0x000000,
 					num clearAlpha: 0,
 					num devicePixelRatio} )
 		:

 		_clearColor = new Color(clearColorHex),
 		_clearAlpha = clearAlpha,

			// clearing
			autoClear = true,
			autoClearColor = true,
			autoClearDepth = true,
			autoClearStencil = true,

			// scene graph
			sortObjects = true,
			autoUpdateObjects = true,
			autoUpdateScene = true,

			// physically based shading
			gammaInput = false,
			gammaOutput = false,
			physicallyBasedShading = false,

			// shadow map
			shadowMapEnabled = false,
			shadowMapAutoUpdate = true,
			shadowMapType = PCFShadowMap,
			shadowMapCullFrontFaces = CullFaceFront,
			shadowMapDebug = false,
			shadowMapCascade = false,

			// morphs
			maxMorphTargets = 8,
			maxMorphNormals = 4,

			// flags
			autoScaleCubemaps = true,

			// custom render plugins
			renderPluginsPre = [],
			renderPluginsPost = [],

			info = new WebGLRendererInfo(),

			// internal properties

	_programs = [],
	_programs_counter = 0,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_currentCamera = null,
	_geometryGroupCounter = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = 0,
	_viewportHeight = 0,
	_currentWidth = 0,
	_currentHeight = 0 ,

 _enabledAttributes = {},

	// frustum
 _frustum = new Frustum(),

  // camera matrices cache
 _projScreenMatrix = new Matrix4.identity(),
 _projScreenMatrixPS = new Matrix4.identity(),

 _vector3 = new Vector3.zero(),

 // light arrays cache

 _direction = new Vector3.zero(),

 _lightsNeedUpdate = true

 {

   this.devicePixelRatio = (devicePixelRatio != null) ? devicePixelRatio : ( (window.devicePixelRatio != null) ? window.devicePixelRatio : 1);

   _lights = {

	    "ambient": [ 0, 0, 0 ],
	    "directional": { "length": 0, "colors": [], "positions": [] },
	    "point": { "length": 0, "colors": [], "positions": [], "distances": [] },
	    "spot": { "length": 0, "colors": [], "positions": [], "distances": [], "directions": [], "anglesCos": [], "exponents": [] },
	    "hemi": { "length": 0, "skyColors": [], "groundColors": [], "positions": [] }
	  };



   if (canvas == null) {
       canvas = new CanvasElement();
   }

 	// initialize

 	initGL();

 	setDefaultGLState();


 	// GPU capabilities
 	maxTextures = _gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
 	maxVertexTextures = _gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	maxTextureSize = _gl.getParameter( gl.MAX_TEXTURE_SIZE );
	maxCubemapSize = _gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

 	maxAnisotropy = (_glExtensionTextureFilterAnisotropic != null) ? _gl.getParameter( gl.ExtTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

 	supportsVertexTextures = ( maxVertexTextures &gt; 0 );
 	supportsBoneTextures = supportsVertexTextures &amp;&amp; (_glExtensionTextureFloat != null);

 	var _compressedTextureFormats = (_glExtensionCompressedTextureS3TC != null) ? _gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS ) : [];

   //

   var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT );
   var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT );
   var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.LOW_FLOAT );

   var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT );
   var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT );
   var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.LOW_FLOAT );

   var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_INT );
   var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_INT );
   var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.LOW_INT );

   var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_INT );
   var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_INT );
   var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.LOW_INT );

   // clamp precision to maximum available

   var highpAvailable = _vertexShaderPrecisionHighpFloat.precision &gt; 0 &amp;&amp; _fragmentShaderPrecisionHighpFloat.precision &gt; 0;
   var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision &gt; 0 &amp;&amp; _fragmentShaderPrecisionMediumpFloat.precision &gt; 0;

   if ( precision == "highp" &amp;&amp; ! highpAvailable ) {

     if ( mediumpAvailable ) {

       precision = "mediump";
       print( "WebGLRenderer: highp not supported, using mediump" );

     } else {

       precision = "lowp";
       print( "WebGLRenderer: highp and mediump not supported, using lowp" );

     }

   }

   if ( precision == "mediump" &amp;&amp; ! mediumpAvailable ) {

     precision = "lowp";
     print( "WebGLRenderer: mediump not supported, using lowp" );

   }

 	// default plugins (order is important)

 	shadowMapPlugin = new ShadowMapPlugin();
 	addPrePlugin( shadowMapPlugin );

 	//addPostPlugin( new SpritePlugin() );
 	//addPostPlugin( new LensFlarePlugin() );

 }

 Element get domElement =&gt; canvas;

	// API

	get context =&gt; _gl;


	setSize( width, height ) {
		canvas.width = (width * devicePixelRatio).toInt();
		canvas.height = (height * devicePixelRatio).toInt();

		canvas.style.width = "${width}px";
		canvas.style.height = "${height}px";

		setViewport( 0, 0, canvas.width, canvas.height );

	}

	setViewport( [x = 0, y = 0, width = -1, height = -1] ) {

		_viewportX = x;
		_viewportY = y;


		_viewportWidth = (width != -1) ? width : canvas.width;
		_viewportHeight = (height != -1)? height : canvas.height;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	}

	setScissor( x, y, width, height ) {
		_gl.scissor( x, y, width, height );
	}

	enableScissorTest( enable ) {
		enable ? _gl.enable( gl.SCISSOR_TEST ) : _gl.disable( gl.SCISSOR_TEST );
	}

	// Clearing
	setClearColorHex( hex, alpha ) {

		_clearColor.setHex( hex );
		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	setClearColor( color, alpha ) {

		_clearColor.copy( color );
		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}


	clear( [ bool color = true, bool depth = true, bool stencil = true] ) {

		var bits = 0;

		if ( color ) bits |= gl.COLOR_BUFFER_BIT;
		if ( depth ) bits |= gl.DEPTH_BUFFER_BIT;
		if ( stencil ) bits |= gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	}

	clearTarget( renderTarget, color, depth, stencil ) {
		setRenderTarget( renderTarget );
		clear( color, depth, stencil );
	}

	// Plugins
	addPostPlugin( plugin ) {
		plugin.init( this );
		renderPluginsPost.add( plugin );
	}

	addPrePlugin( plugin ) {
		plugin.init( this );
		renderPluginsPre.add( plugin );
	}

	// Rendering

	updateShadowMap( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		shadowMapPlugin.update( scene, camera );

	}

	// Internal functions

	// Buffer allocation

	createParticleBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		info.memory.geometries++;

	}

	createLineBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		info.memory.geometries ++;

	}

	createRibbonBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglNormalBuffer = _gl.createBuffer();

		info.memory.geometries ++;

	}

	createMeshBuffers ( WebGLGeometry geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets != null ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			 ml = geometryGroup.numMorphTargets;

			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.add( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals != null ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			ml = geometryGroup.numMorphNormals;

			for ( m = 0; m &lt; ml; m ++ ) {
				geometryGroup.__webglMorphNormalsBuffers.add( _gl.createBuffer() );

			}

		}

		info.memory.geometries++;

	}

	// Events

	onGeometryDispose( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

		info.memory.geometries --;

	}

	onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		info.memory.textures --;

	}

	onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}

	onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation
	deallocateGeometry( geometry ) {

		geometry.__webglInit = null;

		if ( geometry.__webglVertexBuffer != null ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer != null  ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer != null  ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer != null  ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer != null  ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer != null  ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer != null  ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer != null  ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer != null  ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer != null  ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer != null  ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );

		// geometry groups

		if ( geometry.geometryGroups != null  ) {

			for ( var g in geometry.geometryGroups ) {

				var geometryGroup = geometry.geometryGroups[ g ];

				if ( geometryGroup.numMorphTargets != null  ) {

					for ( var m = 0, ml = geometryGroup.numMorphTargets; m &lt; ml; m ++ ) {

						_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

					}

				}

				if ( geometryGroup.numMorphNormals != null  ) {

					for ( var m = 0, ml = geometryGroup.numMorphNormals; m &lt; ml; m ++ ) {

						_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

					}

				}

				deleteCustomAttributesBuffers( geometryGroup );

			}

		}

		deleteCustomAttributesBuffers( geometry );

	}

	deallocateTexture( texture ) {

		if ( texture.image &amp;&amp; texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture["__webglInit"] ) return;

			texture["__webglInit"] = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	}

	deallocateRenderTarget( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		if ( renderTarget is WebGLRenderTargetCube ) {

			for ( var i = 0; i &lt; 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

	}

	deallocateMaterial( material ) {

		var program = material.program;

		if ( program == null ) return;

		material.program = null;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il;
		Program programInfo;
		var deleteProgram = false;

		for ( var i = 0, il = _programs.length; i &lt; il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.glProgram == program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes == 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram == true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( var i = 0, il = _programs.length; i &lt; il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.glProgram != program ) {

					newPrograms.add( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			info.memory.programs --;

		}

	}

	deleteCustomAttributesBuffers( geometry ) {

		if ( geometry.__webglCustomAttributesList ) {

			for ( var id in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );

			}

		}

	}

	// Buffer initialization

	initCustomAttributes ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		var material = object.webglmaterial;

		if ( material.attributes != null ) {

			if ( geometry.__webglCustomAttributesList == null ) {

				geometry.__webglCustomAttributesList = [];

			}

			material.attributes.forEach((key, attribute) {

				if( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					attribute.array = new Float32List( nvertices * attribute.size );

					attribute.buffer = new Buffer(_gl);
					attribute.buffer.belongsToAttribute = key;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.add( attribute );

			});

		}

	}

	initParticleBuffers ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32List( nvertices * 3 );
		geometry.__colorArray = new Float32List( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	}

	initLineBuffers ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32List( nvertices * 3 );
		geometry.__colorArray = new Float32List( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32List( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	}

	initRibbonBuffers ( WebGLGeometry geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32List( nvertices * 3 );
		geometry.__colorArray = new Float32List( nvertices * 3 );
		geometry.__normalArray = new Float32List( nvertices * 3 );

		geometry.__webglVertexCount = nvertices;

		initCustomAttributes ( geometry, object );

	}

	initMeshBuffers ( WebGLGeometry geometryGroup, WebGLObject object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,
			faces4 = geometryGroup.faces4,

			nvertices = faces3.length * 3 + faces4.length * 4,
			ntris     = faces3.length * 1 + faces4.length * 2,
			nlines    = faces3.length * 3 + faces4.length * 4;

		WebGLMaterial material = getBufferMaterial( object, geometryGroup );

		var uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		//console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32List( nvertices * 3 );

		if ( normalType != NoShading ) {

			geometryGroup.__normalArray = new Float32List( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32List( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32List( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceUvs.length &gt; 0 || geometry.faceVertexUvs.length &gt; 0 ) {

				geometryGroup.__uvArray = new Float32List( nvertices * 2 );

			}

			if ( geometry.faceUvs.length &gt; 1 || geometry.faceVertexUvs.length &gt; 1 ) {

				geometryGroup.__uv2Array = new Float32List( nvertices * 2 );

			}

		}

		if ( !object.geometry.skinWeights.isEmpty &amp;&amp; !object.geometry.skinIndices.isEmpty ) {

			geometryGroup.__skinIndexArray = new Float32List( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32List( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16List( ntris * 3 );
		geometryGroup.__lineArray = new Uint16List( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets != null ) {

			geometryGroup.__morphTargetsArrays = [];

			ml = geometryGroup.numMorphTargets;

			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.add( new Float32List( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals != null ) {

			geometryGroup.__morphNormalsArrays = [];

			ml = geometryGroup.numMorphNormals;

			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.add( new Float32List( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes != null) {

			if ( geometryGroup.__webglCustomAttributesList == null ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			material.attributes.forEach((key, attribute) {

				if( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;
					attribute.array = new Float32List( nvertices * attribute.size );

					var buffer = new Buffer(_gl);
					buffer.belongsToAttribute = key;
					attribute.buffer = buffer;

         // Do a shallow copy of the attribute object so different geometryGroup chunks use different
	        // attribute buffers which are correctly indexed in the setMeshBuffers function

	        var originalAttribute = attribute.clone();
					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.add( attribute );

			});

		}

		geometryGroup.__inittedArrays = true;

	}

	WebGLMaterial getBufferMaterial( WebGLObject object, WebGLGeometry geometryGroup ) {

	  Material material = (object.material is MeshFaceMaterial)
			? (object.material as MeshFaceMaterial).materials[ geometryGroup.materialIndex ]
			: object.material;

		return new WebGLMaterial.from(material);
	}


	bool materialNeedsSmoothNormals ( material ) {

		return material != null &amp;&amp; material.shading != null &amp;&amp; material.shading == SmoothShading;

	}

	int bufferGuessNormalType ( WebGLMaterial material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( !material.needsNormals  ) {
			return NoShading;
		}

		if ( material.needsSmoothNormals ) {

			return SmoothShading;

		} else {

			return FlatShading;

		}

	}

	bufferGuessVertexColorType ( material ) {

		if ( ((material.vertexColors is bool) &amp;&amp; material.vertexColors) ||
		     ((material.vertexColors is int) &amp;&amp; (material.vertexColors != NoColors))) {

			return material.vertexColors;

		}

		return false;

	}

	bool bufferGuessUVType ( material ) {

		// material must use some texture to require uvs

		if ((material.map != null) ||
		    (material.lightMap != null) ||
		    (material.bumpMap != null) ||
		    (material.normalMap != null) ||
		    (material.specularMap != null) ||
		    (material.isShaderMaterial)) {

			return true;

		}

		return false;

	}

	//

	initDirectBuffers( BufferGeometry geometry ) {

		var a, attribute, type;

		geometry.attributes.forEach((a, v) {

			if ( a == "index" ) {

				type = gl.ELEMENT_ARRAY_BUFFER;

			} else {

				type = gl.ARRAY_BUFFER;

			}

			attribute = v;

			attribute.buffer = new Buffer(_gl);
			attribute.buffer.bind(type);
			_gl.bufferDataTyped(type, attribute.array, gl.STATIC_DRAW);

		});

	}

	// Buffer setting

	setParticleBuffers ( WebGLGeometry geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.setFrom( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.setFrom(vertex);
				_vector3.applyProjection(_projScreenMatrixPS);

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c &lt; cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes != null ) {

				il = customAttributes.length;
				for ( i = 0; i &lt; il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size == 1 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size == 2 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size == 3 ) {

						if ( customAttribute.type == "c" ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size == 4 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v &lt; vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c &lt; cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes != null) {

				il = customAttributes.length;
				for ( i = 0; i &lt; il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &amp;&amp;
						 ( customAttribute.boundTo == null ||
						   customAttribute.boundTo == "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size == 1 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size == 2 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size == 3 ) {

							if ( customAttribute.type == "c" ) {

								for ( ca = 0; ca &lt; cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca &lt; cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size == 4 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes != null) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					customAttribute.buffer.bind( gl.ARRAY_BUFFER );
					_gl.bufferDataTyped( gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	}

	setLineBuffers ( WebGLGeometry geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c &lt; cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d &lt; dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes != null ) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &amp;&amp;
					 ( customAttribute.boundTo == null ||
					   customAttribute.boundTo == "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size == 1 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size == 2 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size == 3 ) {

						if ( customAttribute.type == "c" ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size == 4 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					customAttribute.buffer.bind( gl.ARRAY_BUFFER );
					_gl.bufferDataTyped( gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	setRibbonBuffers ( WebGLGeometry geometry, hint ) {

		var v, c, n, vertex, offset, color, normal,

		i, il, ca, cal, customAttribute, value,

		vertices = geometry.vertices,
		colors = geometry.colors,
		normals = geometry.normals,

		vl = vertices.length,
		cl = colors.length,
		nl = normals.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		normalArray = geometry.__normalArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList;

		if ( dirtyVertices ) {

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c &lt; cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyNormals ) {

			for ( n = 0; n &lt; nl; n ++ ) {

				normal = normals[ n ];

				offset = n * 3;

				normalArray[ offset ]     = normal.x;
				normalArray[ offset + 1 ] = normal.y;
				normalArray[ offset + 2 ] = normal.z;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglNormalBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( customAttributes ) {

			for ( var i = 0, il = customAttributes.length; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &amp;&amp;
					 ( customAttribute.boundTo == null ||
					   customAttribute.boundTo == "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size == 1 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size == 2 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size == 3 ) {

						if ( customAttribute.type == "c" ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size == 4 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					customAttribute.buffer.bind( gl.ARRAY_BUFFER );
					_gl.bufferDataTyped( gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	setMeshBuffers( WebGLGeometry geometryGroup, WebGLObject object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType == SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.webglgeometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		chunk_faces4 = geometryGroup.faces4,
		obj_faces = geometry.faces,

		obj_uvs  = (geometry.faceVertexUvs.length == 0) ? [] : geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = (geometry.faceVertexUvs.length &gt; 1) ? geometry.faceVertexUvs[ 1 ] : null,

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;


		if ( dirtyVertices ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];
				v4 = vertices[ face.d ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				vertexArray[ offset + 9 ]  = v4.x;
				vertexArray[ offset + 10 ] = v4.y;
				vertexArray[ offset + 11 ] = v4.z;

				offset += 12;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, vertexArray, hint);

		}

		if ( dirtyMorphTargets ) {

			vkl = morphTargets.length;
			for ( vk = 0; vk &lt; vkl; vk ++ ) {

				offset_morphTarget = 0;

				fl = chunk_faces3.length;
				for ( f = 0; f &lt; fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				fl = chunk_faces4.length;
				for ( f = 0; f &lt; fl; f ++ ) {

					chf = chunk_faces4[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];
					v4 = morphTargets[ vk ].vertices[ face.d ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					vka[ offset_morphTarget + 9 ]  = v4.x;
					vka[ offset_morphTarget + 10 ] = v4.y;
					vka[ offset_morphTarget + 11 ] = v4.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;
							n4 = faceVertexNormals.d;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;
							n4 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

						nka[ offset_morphTarget + 9 ]  = n4.x;
						nka[ offset_morphTarget + 10 ] = n4.y;
						nka[ offset_morphTarget + 11 ] = n4.z;

					}

					//

					offset_morphTarget += 12;

				}

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferDataTyped( gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( !obj_skinWeights.isEmpty) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];
				sw4 = obj_skinWeights[ face.d ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				skinWeightArray[ offset_skin + 12 ] = sw4.x;
				skinWeightArray[ offset_skin + 13 ] = sw4.y;
				skinWeightArray[ offset_skin + 14 ] = sw4.z;
				skinWeightArray[ offset_skin + 15 ] = sw4.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];
				si4 = obj_skinIndices[ face.d ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				skinIndexArray[ offset_skin + 12 ] = si4.x;
				skinIndexArray[ offset_skin + 13 ] = si4.y;
				skinIndexArray[ offset_skin + 14 ] = si4.z;
				skinIndexArray[ offset_skin + 15 ] = si4.w;

				offset_skin += 16;

			}

			if ( offset_skin &gt; 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors &amp;&amp; vertexColorType) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length == 3 &amp;&amp; vertexColorType == VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length == 4 &amp;&amp; vertexColorType == VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];
					c4 = vertexColors[ 3 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;
					c4 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				colorArray[ offset_color + 9 ]  = c4.r;
				colorArray[ offset_color + 10 ] = c4.g;
				colorArray[ offset_color + 11 ] = c4.b;

				offset_color += 12;

			}

			if ( offset_color &gt; 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents &amp;&amp; geometry.hasTangents ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];
				t4 = vertexTangents[ 3 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				tangentArray[ offset_tangent + 12 ] = t4.x;
				tangentArray[ offset_tangent + 13 ] = t4.y;
				tangentArray[ offset_tangent + 14 ] = t4.z;
				tangentArray[ offset_tangent + 15 ] = t4.w;

				offset_tangent += 16;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals &amp;&amp; (normalType != NoShading) ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length == 3 &amp;&amp; needsSmoothNormals ) {

					for ( i = 0; i &lt; 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i &lt; 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length == 4 &amp;&amp; needsSmoothNormals ) {

					for ( i = 0; i &lt; 4; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i &lt; 4; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs &amp;&amp; !obj_uvs.isEmpty &amp;&amp; uvType ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv == null ) continue;

				for ( i = 0; i &lt; 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.u;
					uvArray[ offset_uv + 1 ] = uvi.v;

					offset_uv += 2;

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces4[ f ];

				uv = obj_uvs[ fi ];

				if ( uv == null ) continue;

				for ( i = 0; i &lt; 4; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.u;
					uvArray[ offset_uv + 1 ] = uvi.v;

					offset_uv += 2;

				}

			}

			if ( offset_uv &gt; 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs &amp;&amp; (obj_uvs2 != null) &amp;&amp; uvType ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 == null ) continue;

				for ( i = 0; i &lt; 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.u;
					uv2Array[ offset_uv2 + 1 ] = uv2i.v;

					offset_uv2 += 2;

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces4[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 == null ) continue;

				for ( i = 0; i &lt; 4; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.u;
					uv2Array[ offset_uv2 + 1 ] = uv2i.v;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 &gt; 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			 fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				faceArray[ offset_face ]     = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 3;

				faceArray[ offset_face + 3 ] = vertexIndex + 1;
				faceArray[ offset_face + 4 ] = vertexIndex + 2;
				faceArray[ offset_face + 5 ] = vertexIndex + 3;

				offset_face += 6;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 3;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				lineArray[ offset_line + 6 ] = vertexIndex + 2;
				lineArray[ offset_line + 7 ] = vertexIndex + 3;

				offset_line += 8;

				vertexIndex += 4;

			}

			_gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferDataTyped( gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferDataTyped( gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes != null) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size == 1 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
							customAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];

							offset_custom += 4;

						}

					} else if ( customAttribute.boundTo == "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;
							customAttribute.array[ offset_custom + 3 ] = value;

							offset_custom += 4;

						}

					}

				} else if ( customAttribute.size == 2 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					} else if ( customAttribute.boundTo == "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					}

				} else if ( customAttribute.size == 3 ) {

					var pp;

					if ( customAttribute.type == "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo == "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo == "faceVertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];
							v4 = value[ 3 ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					}

				} else if ( customAttribute.size == 4 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo == "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo == "faceVertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];
							v4 = value[ 3 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					}

				}

				customAttribute.buffer.bind(gl.ARRAY_BUFFER);

       		_gl.bufferDataTyped(gl.ARRAY_BUFFER, customAttribute.array, hint);

			}

		}

		if ( dispose ) {

			geometryGroup.__inittedArrays = false; //delete geometryGroup.__inittedArrays"];
			geometryGroup.__colorArray = null; //delete geometryGroup.__colorArray"];
			geometryGroup.__normalArray = null; //delete geometryGroup.__normalArray"];
			geometryGroup.__tangentArray = null; //delete geometryGroup.__tangentArray"];
			geometryGroup.__uvArray = null; //delete geometryGroup.__uvArray"];
			geometryGroup.__uv2Array = null; //delete geometryGroup.__uv2Array"];
			geometryGroup.__faceArray = null; //delete geometryGroup.__faceArray"];
			geometryGroup.__vertexArray = null; //delete geometryGroup.__vertexArray"];
			geometryGroup.__lineArray = null; //delete geometryGroup.__lineArray"];
			geometryGroup.__skinIndexArray = null; //delete geometryGroup.__skinIndexArray"];
			geometryGroup.__skinWeightArray = null; //delete geometryGroup.__skinWeightArray"];

		}

	}

	setDirectBuffers ( WebGLGeometry webglgeometry, int hint, bool dispose ) {

	  BufferGeometry geometry = webglgeometry._geometry;

		var attributes = geometry.attributes;

		var index = geometry.aIndex;
		var position = geometry.aPosition;
		var normal = geometry.aNormal;
		var uv = geometry.aUV;
		var color = geometry.aColor;
		var tangent = geometry.aTangent;

		if ( webglgeometry.elementsNeedUpdate &amp;&amp; index != null ) {

			index.buffer.bind( gl.ELEMENT_ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ELEMENT_ARRAY_BUFFER, index.array, hint );

		}

		if ( webglgeometry.verticesNeedUpdate &amp;&amp; position != null ) {

			position.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, position.array, hint );

		}

		if ( webglgeometry.normalsNeedUpdate &amp;&amp; normal != null ) {

			normal.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, normal.array, hint );

		}

		if ( webglgeometry.uvsNeedUpdate &amp;&amp; uv != null ) {

			uv.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, uv.array, hint );

		}

		if ( webglgeometry.colorsNeedUpdate &amp;&amp; color != null ) {

			color.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, color.array, hint );

		}

		if ( webglgeometry.tangentsNeedUpdate &amp;&amp; tangent != null ) {

			tangent.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, tangent.array, hint );

		}

		if ( dispose ) {

		  geometry.attributes.forEach((_, attribute) {
			 attribute.array = null; //delete geometry.attributes[ i ].array;
			});

		}

	}

	// Buffer rendering

	renderBufferImmediate ( object, program, material ) {

		if ( object.hasPositions &amp;&amp; ! object["__webglVertexBuffer"] ) object["__webglVertexBuffer"] = _gl.createBuffer();
		if ( object.hasNormals &amp;&amp; ! object["__webglNormalBuffer"] ) object["__webglNormalBuffer"] = _gl.createBuffer();
		if ( object.hasUvs &amp;&amp; ! object["__webglUVBuffer"] ) object["__webglUVBuffer"] = _gl.createBuffer();
		if ( object.hasColors &amp;&amp; ! object["__webglColorBuffer"] ) object["__webglColorBuffer"] = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, object["__webglVertexBuffer"] );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, object.positionArray, gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["position"] );
			_gl.vertexAttribPointer( program.attributes["position"], 3, gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, object["__webglNormalBuffer"] );

			if ( material.shading == FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i &lt; il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferDataTyped( gl.ARRAY_BUFFER, object.normalArray, gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["normal"] );
			_gl.vertexAttribPointer( program.attributes["normal"], 3, gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs &amp;&amp; material.map ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, object["__webglUVBuffer"] );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, object.uvArray, gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["uv"] );
			_gl.vertexAttribPointer( program.attributes["uv"], 2, gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors &amp;&amp; material.vertexColors != NoColors ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, object["__webglColorBuffer"] );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, object.colorArray, gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["color"] );
			_gl.vertexAttribPointer( program.attributes["color"], 3, gl.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( gl.TRIANGLES, 0, object.count );

		object.count = 0;

	}

	renderBufferDirect ( WebGLCamera camera, List lights, fog, WebGLMaterial material, WebGLGeometry webglgeometry, WebGLObject webglobject ) {

		if ( !material.visible ) return;

		var program, attributes, linewidth, primitives, a, attribute;

		program = setProgram( camera, lights, fog, material, webglobject );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( webglgeometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash != _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// render mesh
   	var object = webglobject.object;

   	BufferGeometry geometry = webglgeometry._geometry;

		if ( object is Mesh ) {

			var index = geometry.aIndex;

			// indexed triangles

			if ( index != null) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length &gt; 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i &lt; il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						// vertices

						var position = geometry.attributes[ "position" ];
						var positionSize = position.itemSize;

						position.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["position"] );
						_gl.vertexAttribPointer( attributes["position"], positionSize, gl.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32

						// normals

						var normal = geometry.attributes[ "normal" ];

						if ( attributes["normal"] &gt;= 0 &amp;&amp; normal != null) {

							var normalSize = normal.itemSize;

							normal.buffer.bind( gl.ARRAY_BUFFER );
							enableAttribute( attributes["normal"] );
							_gl.vertexAttribPointer( attributes["normal"], normalSize, gl.FLOAT, false, 0, startIndex * normalSize * 4 );

						}

						// uvs

						var uv = geometry.attributes[ "uv" ];

						if ( attributes["uv"] &gt;= 0 &amp;&amp; uv != null ) {

							var uvSize = uv.itemSize;

							uv.buffer.bind( gl.ARRAY_BUFFER );
							enableAttribute( attributes["uv"]);
							_gl.vertexAttribPointer( attributes["uv"], uvSize, gl.FLOAT, false, 0, startIndex * uvSize * 4 );

						}

						// colors

						var color = geometry.attributes[ "color" ];

						if ( attributes["color"] &gt;= 0 &amp;&amp; color != null ) {

							var colorSize = color.itemSize;

							color.buffer.bind( gl.ARRAY_BUFFER );
							enableAttribute( attributes["color"] );
							_gl.vertexAttribPointer( attributes["color"], colorSize, gl.FLOAT, false, 0, startIndex * colorSize * 4 );

						}

						// tangents

						var tangent = geometry.attributes[ "tangent" ];

						if ( attributes["tangent"] &gt;= 0 &amp;&amp; tangent != null ) {

							var tangentSize = tangent.itemSize;

							tangent.buffer.bind( gl.ARRAY_BUFFER );
							enableAttribute( attributes["tangent"] );
							_gl.vertexAttribPointer( attributes["tangent"], tangentSize, gl.FLOAT, false, 0, startIndex * tangentSize * 4 );

						}

						// indices

						index.buffer.bind( gl.ELEMENT_ARRAY_BUFFER );

					}

					// render indexed triangles

					_gl.drawElements( gl.TRIANGLES, offsets[ i ].count, gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

					info.render.calls ++;
					info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
					info.render.faces += offsets[ i ].count ~/ 3;

				}

			// non-indexed triangles

			} else {

			  GeometryAttribute&lt;Float32List&gt; position = geometry.aPosition;

				if ( updateBuffers ) {

					// vertices


					var positionSize = position.itemSize;

					position.buffer.bind( gl.ARRAY_BUFFER );
					enableAttribute( attributes["position"] );
					_gl.vertexAttribPointer( attributes["position"], positionSize, gl.FLOAT, false, 0, 0 );

					// normals

					GeometryAttribute&lt;Float32List&gt; normal = geometry.aNormal;

					if ( attributes["normal"] &gt;= 0 &amp;&amp; normal != null ) {

						var normalSize = normal.itemSize;

						normal.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["normal"] );
						_gl.vertexAttribPointer( attributes["normal"], normalSize, gl.FLOAT, false, 0, 0 );

					}

					// uvs

					GeometryAttribute&lt;Float32List&gt; uv = geometry.aUV;

					if ( attributes["uv"] &gt;= 0 &amp;&amp; uv != null ) {

						var uvSize = uv.itemSize;

						uv.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["uv"] );
						_gl.vertexAttribPointer( attributes["uv"], uvSize, gl.FLOAT, false, 0, 0 );

					}

					// colors

					GeometryAttribute&lt;Float32List&gt; color = geometry.aColor;

					if ( attributes["color"] &gt;= 0 &amp;&amp; color != null ) {

						var colorSize = color.itemSize;

						color.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["color"] );
						_gl.vertexAttribPointer( attributes["color"], colorSize, gl.FLOAT, false, 0, 0 );

					}

					// tangents

					GeometryAttribute&lt;Float32List&gt; tangent = geometry.aTangent;

					if ( attributes["tangent"] &gt;= 0 &amp;&amp; tangent != null ) {

						var tangentSize = tangent.itemSize;

						tangent.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["tangent"] );
						_gl.vertexAttribPointer( attributes["tangent"], tangentSize, gl.FLOAT, false, 0, 0 );

					}
				}

				// render non-indexed triangles

				_gl.drawArrays( gl.TRIANGLES, 0, position.numItems ~/ 3 );

				info.render.calls ++;
				info.render.vertices += position.numItems ~/ 3;
				info.render.faces += position.numItems ~/ 3 ~/ 3;

			}

		// render particles

		} else if ( object is ParticleSystem ) {

			if ( updateBuffers ) {

				// vertices

				var position = geometry.attributes[ "position" ];
				var positionSize = position.itemSize;

				position.buffer.bind( gl.ARRAY_BUFFER );
				enableAttribute( attributes["position"] );
				_gl.vertexAttribPointer( attributes["position"], positionSize, gl.FLOAT, false, 0, 0 );

				// colors

				var color = geometry.attributes[ "color" ];

				if ( attributes["color"] &gt;= 0 &amp;&amp; color != null ) {

					var colorSize = color.itemSize;

					color.buffer.bind( gl.ARRAY_BUFFER );
					enableAttribute( attributes["color"] );
					_gl.vertexAttribPointer( attributes["color"], colorSize, gl.FLOAT, false, 0, 0 );

				}

				// render particles

				_gl.drawArrays( gl.POINTS, 0, position.numItems ~/ 3);

				info.render.calls ++;
				info.render.points += position.numItems ~/ 3;

			}

		}

	}

	renderBuffer ( camera, lights, fog, WebGLMaterial material, WebGLGeometry geometryGroup, object ) {

	  // Wrap these into proper WebGL objects since this method is called from plugins
	  WebGLObject webglobject = (object is WebGLObject) ? object : new WebGLObject(object);
     object = webglobject.object;

     WebGLCamera webglcamera = (camera is WebGLCamera) ? camera : new WebGLCamera(camera);
     camera = webglcamera._camera;

		if ( !material.visible ) return;

		var program, attributes, linewidth, primitives, a, attribute, i, il;

		program = setProgram( webglcamera, lights, fog, material, webglobject );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash != _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

       if ( updateBuffers ) {

			disableAttributes();

		}
		// vertices

		if ( !material.morphTargets &amp;&amp; attributes["position"] &gt;= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes["position"] );
				_gl.vertexAttribPointer( attributes["position"], 3, gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( webglobject.morphTargetBase != 0 ) {

				setupMorphTargets( material, geometryGroup, webglobject );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList != null) {

			  il = geometryGroup.__webglCustomAttributesList.length;
				for ( i = 0; i &lt; il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if( attributes[ attribute.buffer.belongsToAttribute ] &gt;= 0 ) {

						attribute.buffer.bind(gl.ARRAY_BUFFER);
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes["color"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				enableAttribute( attributes["color"] );
				_gl.vertexAttribPointer( attributes["color"], 3, gl.FLOAT, false, 0, 0 );

			}

			// normals

			if ( attributes["normal"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes["normal"] );
				_gl.vertexAttribPointer( attributes["normal"], 3, gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes["tangent"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes["tangent"] );
				_gl.vertexAttribPointer( attributes["tangent"], 4, gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes["uv"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				enableAttribute( attributes["uv"] );
				_gl.vertexAttribPointer( attributes["uv"], 2, gl.FLOAT, false, 0, 0 );


			}

			if ( attributes["uv2"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				enableAttribute( attributes["uv2"] );
				_gl.vertexAttribPointer( attributes["uv2"], 2, gl.FLOAT, false, 0, 0 );

			}

			if ( material.skinning &amp;&amp;
				 attributes["skinIndex"] &gt;= 0 &amp;&amp; attributes["skinWeight"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes["skinIndex"] );
				_gl.vertexAttribPointer( attributes["skinIndex"], 4, gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes["skinWeight"] );
				_gl.vertexAttribPointer( attributes["skinWeight"], 4, gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes["lineDistance"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes["lineDistance"] );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, gl.FLOAT, false, 0, 0 );

			}
		}

		// render mesh

		if ( object is Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( gl.LINES, geometryGroup.__webglLineCount, gl.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( gl.TRIANGLES, geometryGroup.__webglFaceCount, gl.UNSIGNED_SHORT, 0 );

			}

			info.render.calls ++;
			info.render.vertices += geometryGroup.__webglFaceCount;
			info.render.faces += geometryGroup.__webglFaceCount ~/ 3;

		// render lines

		} else if ( object is Line ) {

			primitives = ( (object as Line).type == LineStrip ) ? gl.LINE_STRIP : gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			info.render.calls ++;

		// render particles

		} else if ( object is ParticleSystem ) {

			_gl.drawArrays( gl.POINTS, 0, geometryGroup.__webglParticleCount );

			info.render.calls ++;
			info.render.points += geometryGroup.__webglParticleCount;

		// render ribbon

		} else if ( object is Ribbon ) {

			_gl.drawArrays( gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );

			info.render.calls ++;

		}

	}

	enableAttribute( attribute ) {

	  var k = attribute.toString();

		if ( _enabledAttributes[ k ] == null ||  !_enabledAttributes[ k ] ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ k ] = true;

		}

	}

	disableAttributes() {

		_enabledAttributes.forEach((attribute, enabled) {

			if ( enabled ) {

				_gl.disableVertexAttribArray( int.parse(attribute) );
				_enabledAttributes[ attribute ] = false;

			}

		});

	}

	setupMorphTargets ( material, WebGLGeometry geometryGroup, WebGLObject object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase != -1 &amp;&amp; attributes["position"] &gt;= 0) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes["position"] );
			_gl.vertexAttribPointer( attributes["position"], 3, gl.FLOAT, false, 0, 0 );

		} else if ( attributes["position"] &gt;= 0 ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes["position"] );
			_gl.vertexAttribPointer( attributes["position"], 3, gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length &gt; 0) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m &lt; material.numSupportedMorphTargets &amp;&amp; m &lt; order.length ) {

				if ( attributes[ "morphTarget" + m ] &gt;= 0 ) {
					_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphTarget" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget$m"], 3, gl.FLOAT, false, 0, 0 );
				}

				if ( attributes[ "morphNormal" + m ] &gt;= 0 &amp;&amp; material.morphNormals ) {

					_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphNormal" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphNormal$m" ], 3, gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ].toDouble();

				m ++;
			}

		} else {

			// find the most influencing

			var influence;
			List&lt;List&gt; activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i &lt; il; i ++ ) {

				influence = influences[ i ];

				if ( influence &gt; 0 ) {

					activeInfluenceIndices.add( [ i, influence ] );

				}

			}

			if ( activeInfluenceIndices.length &gt; material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length &gt; material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length == 0 ) {

				activeInfluenceIndices.add( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m &lt; material.numSupportedMorphTargets ) {

				if ( m &lt; activeInfluenceIndices.length &amp;&amp; activeInfluenceIndices[ m ] != null &amp;&amp; !activeInfluenceIndices[ m ].isEmpty) {

					influenceIndex = activeInfluenceIndices[ m ][ 0 ];

					_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
					enableAttribute( attributes[ "morphTarget$m" ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget$m" ], 3, gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphNormal$m" ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal$m" ], 3, gl.FLOAT, false, 0, 0 );

					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ].toDouble();

				} else {

					object.__webglMorphTargetInfluences[ m ] = 0.0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms["morphTargetInfluences"] != null ) {

			_gl.uniform1fv( material.program.uniforms["morphTargetInfluences"], object.__webglMorphTargetInfluences );

		}

	}

	// Sorting

	painterSort ( a, b ) =&gt; (a.z.isNaN || b.z.isNaN || a.z.isInfinite || b.z.isInfinite) ? 0 : (b.z - a.z).toInt();

	numericalSort ( a, b ) =&gt; (b[ 0 ] - a[ 0 ]).toInt();


	// Rendering
	render ( Scene scene, Camera camera) =&gt; _render( scene, camera);

	_render ( Scene scene, Camera c, {renderTarget: null, forceClear: false} ) {

		var i, il;

		WebGLObject webglObject;
		Object3D object;
		var renderList;

		List lights = scene.lights;
		Fog fog = scene.fog;

		// reset caching for this frame

		_currentMaterialId = -1;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( autoUpdateScene ) scene.updateMatrixWorld();

		var camera = new WebGLCamera(c);

		// update camera matrices and frustum

		if ( camera.parent == null ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.copyInverse(camera.matrixWorld);

		_projScreenMatrix.setFrom(camera.projectionMatrix).multiply(camera.matrixWorldInverse);
		_frustum.setFromMatrix( _projScreenMatrix );

		// update WebGL objects

		if ( autoUpdateObjects ) initWebGLObjects( scene );

		// custom render plugins (pre pass)

		renderPlugins( renderPluginsPre, scene, camera );

		//

		info.render.calls = 0;
		info.render.vertices = 0;
		info.render.faces = 0;
		info.render.points = 0;

		setRenderTarget( renderTarget );

		if ( autoClear || forceClear ) {

			clear( autoClearColor, autoClearDepth, autoClearStencil );

		}

		// set matrices for regular objects (frustum culled)

		renderList = scene["__webglObjects"];

		il = renderList.length;

		for ( i = 0; i &lt; il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object is Mesh || object is ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.contains( object ) ) {


					setupMatrices( webglObject, camera );

					unrollBufferMaterial( webglObject );

					webglObject.render = true;

					if ( sortObjects ) {

						if ( object.renderDepth != null ) {

							webglObject.z = object.renderDepth;

						} else {
							_vector3 = object.matrixWorld.getTranslation();
							_vector3.applyProjection(_projScreenMatrix);

							webglObject.z = _vector3.z;

						}

					}

				}

			}

		}

		if ( sortObjects ) {

			renderList.sort( painterSort );

		}

		// set matrices for immediate objects

		renderList = scene["__webglObjectsImmediate"];

		il = renderList.length;

		for ( i = 0; i &lt; il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( webglObject, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial != null ) {

			var material = scene.overrideMaterial;

			setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			setDepthTest( material.depthTest );
			setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( scene["__webglObjects"], false, "", camera, lights, fog, true, material );
			renderObjectsImmediate( scene["__webglObjectsImmediate"], "", camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			setBlending( NoBlending );

			renderObjects( scene["__webglObjects"], true, "opaque", camera, lights, fog, false, material );
			renderObjectsImmediate( scene["__webglObjectsImmediate"], "opaque", camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( scene["__webglObjects"], false, "transparent", camera, lights, fog, true, material );
			renderObjectsImmediate( scene["__webglObjectsImmediate"], "transparent", camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		renderPlugins( renderPluginsPost, scene, camera );


		// Generate mipmap if we're using any kind of mipmap filtering

		if ( (renderTarget != null ) &amp;&amp; renderTarget.generateMipmaps &amp;&amp; renderTarget.minFilter != NearestFilter &amp;&amp; renderTarget.minFilter != LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		setDepthTest( true );
		setDepthWrite( true );

		// _gl.finish();

	}

	renderPlugins( plugins, scene, camera ) {

		plugins.forEach((plugin) {
			// reset state for plugin (to start from clean slate)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

			plugin.render( scene, camera._camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

		});

	}

	renderObjects (  List&lt;WebGLObject&gt;renderList,
	                 bool reverse, String materialType,
	                 WebGLCamera camera,
	                 List&lt;Light&gt; lights,
	                 fog,
	                 useBlending,
	                 [overrideMaterial = null] ) {

		WebGLObject webglObject;
		var object, buffer, material;
		num start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i != end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial != null ) {

					material = overrideMaterial;

				} else {

					material = (materialType == "opaque")? webglObject.opaque : webglObject.transparent;

					if ( material == null ) continue;

					if ( useBlending ) setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					setDepthTest( material.depthTest );
					setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				setMaterialFaces( material );

				if ( buffer.isBufferGeometry ) {

					renderBufferDirect( camera, lights, fog, material, buffer, webglObject );

				} else {

					renderBuffer( camera, lights, fog, material, buffer, webglObject );

				}

			}

		}

	}

	renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, [overrideMaterial] ) {

		var webglObject, object, material, program, il;

		il = renderList.length;

		for ( var i = 0; i &lt; il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					setDepthTest( material.depthTest );
					setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	}

	renderImmediateObject( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = -1;

		setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( ( object ) { renderBufferImmediate( object, program, material ); } );

		}

	}

	unrollImmediateBufferMaterial ( WebGLObject webglobject ) {

		var material = webglobject.webglmaterial;

		if ( material.transparent ) {

		  webglobject.transparent = material;
		  webglobject.opaque = null;

		} else {

		  webglobject.opaque = material;
		  webglobject.transparent = null;

		}

	}

	unrollBufferMaterial ( WebGLObject object ) {

		WebGLGeometry	buffer = object.buffer;
		WebGLMaterial meshMaterial = object.webglmaterial;
		int materialIndex;
		WebGLMaterial material;


		if ( object.material is MeshFaceMaterial ) {

			materialIndex = buffer.materialIndex;

			if ( materialIndex &gt;= 0 ) {

				material = new WebGLMaterial.from(object.geometry.materials[ materialIndex ]);

				if ( material.transparent ) {

				  object.transparent = material;
				  object.opaque = null;

				} else {

				  object.opaque = material;
				  object.transparent = null;

				}

			}

		} else {

		  material = meshMaterial;

			if ( material != null ) {

				if ( material.transparent != null ) {

				  object.transparent = material;
				  object.opaque = null;

				} else {

				  object.opaque = material;
				  object.transparent = null;

				}

			}

		}

	}

	// Geometry splitting

	sortFacesByMaterial ( WebGLGeometry geometry, material ) {

		var f, fl, face, materialIndex, vertices,
			materialHash, groupHash;

		Map&lt;String, Map&gt; hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var usesFaceMaterial = material is MeshFaceMaterial;

		geometry.geometryGroups = {};

		fl = geometry.faces.length;
		for ( f = 0; f &lt; fl; f ++ ) {

			face = geometry.faces[ f ];
			materialIndex = usesFaceMaterial ? face.materialIndex.toString() : "0";

			if ( hash_map[ materialIndex ] == null ) {

				hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };

			}

			groupHash = "${hash_map[ materialIndex ]["hash"]}_${hash_map[ materialIndex ]["counter"]}";

			if ( geometry.geometryGroups[ groupHash ] == null ) {

				geometry.geometryGroups[ groupHash ] = new WebGLGeometry(faces3: [], faces4: [], materialIndex: int.parse(materialIndex), vertices: 0, numMorphTargets: numMorphTargets, numMorphNormals: numMorphNormals);

			}

			vertices = face.size;

			if ( geometry.geometryGroups[ groupHash ].vertices + vertices &gt; 65535 ) {

				hash_map[ materialIndex ]["counter"] += 1;
				groupHash = "${hash_map[ materialIndex ]["hash"]}_${hash_map[ materialIndex ]["counter"]}";

				if ( geometry.geometryGroups[ groupHash ] == null ) {

					geometry.geometryGroups[ groupHash ] = new WebGLGeometry(faces3: [], faces4: [], materialIndex: int.parse(materialIndex), vertices: 0, numMorphTargets: numMorphTargets, numMorphNormals: numMorphNormals );

				}

			}

			if ( face.size == 3 ) {

				geometry.geometryGroups[ groupHash ].faces3.add( f );

			} else {

				geometry.geometryGroups[ groupHash ].faces4.add( f );

			}

			geometry.geometryGroups[ groupHash ].vertices += vertices;

		}

		geometry.geometryGroupsList = [];

		geometry.geometryGroups.forEach( (k,g) {

     g.id = _geometryGroupCounter ++;

     geometry.geometryGroupsList.add( g );

   });

		return;

	}

	// Objects refresh

	initWebGLObjects( Scene scene ) {

		if ( scene["__webglObjects"] == null ) {

			scene["__webglObjects"] = [];
			scene["__webglObjectsImmediate"] = [];
			scene["__webglSprites"] = [];
			scene["__webglFlares"] = [];

		}

		while ( scene.__objectsAdded.length &gt; 0 ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.removeAt( 0 );

		}

		while ( scene.__objectsRemoved.length &gt; 0) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.removeAt( 0 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene["__webglObjects"].length; o &lt; ol; o ++ ) {

			updateObject( scene["__webglObjects"][ o ] );

		}

	}

	// Objects adding

	addObject ( Object3D object, Scene scene ) {

	  // nelsonsilva - wrapping in our own decorator
   WebGLObject webglobject = new WebGLObject(object);

   // ATTENTION - All type checks must be done with object and object.geometry
   WebGLGeometry geometry = webglobject.webglgeometry;

   var material;

		if (  !webglobject.__webglInit ) {

		  webglobject.__webglInit = true;

		  webglobject._modelViewMatrix = new Matrix4.identity();
		  webglobject._normalMatrix = new Matrix3.zero();

		  if ( geometry != null &amp;&amp; geometry.__webglInit == null ) {

				geometry.__webglInit = true;
				//geometry.addEventListener( 'dispose', onGeometryDispose );

			}

			if ( object is Mesh ) {

				material = object.material;

				if ( (object.geometry is Geometry)  &amp;&amp; (object.geometry is! BufferGeometry) ) {

					if ( geometry.geometryGroups == null) {

						sortFacesByMaterial( geometry, material );

					}

					// create separate VBOs per geometry chunk

					geometry.geometryGroups.forEach((k, geometryGroup) {

						// initialise VBO on the first access

						if ( geometryGroup.__webglVertexBuffer == null ) {

							createMeshBuffers( geometryGroup );
							initMeshBuffers( geometryGroup, webglobject );

							geometry.verticesNeedUpdate = true;
							geometry.morphTargetsNeedUpdate = true;
							geometry.elementsNeedUpdate = true;
							geometry.uvsNeedUpdate = true;
							geometry.normalsNeedUpdate = true;
							geometry.tangentsNeedUpdate = true;
							geometry.colorsNeedUpdate = true;

						}

					});

				} else if ( object.geometry is BufferGeometry ) {

					initDirectBuffers( object.geometry as BufferGeometry);

				}

			} else if ( object is Ribbon ) {

				if( geometry.__webglVertexBuffer == null) {

					createRibbonBuffers( geometry );
					initRibbonBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.normalsNeedUpdate = true;

				}

			} else if ( object is Line ) {

				if( geometry.__webglVertexBuffer == null ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, webglobject );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object is ParticleSystem ) {

				if ( geometry.__webglVertexBuffer == null ) {

					if ( (object.geometry is Geometry)  &amp;&amp; (object.geometry is! BufferGeometry) ) {
						createParticleBuffers( geometry );
						initParticleBuffers( geometry, webglobject );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					} else if ( object.geometry is BufferGeometry ) {

						initDirectBuffers( object.geometry );

					}

				}

			}
		}

		if (!webglobject.__webglActive) {

			if ( object is Mesh ) {

				if ( object.geometry is BufferGeometry ) {

					addBuffer( scene["__webglObjects"], geometry, webglobject );

				} else {

				  geometry.geometryGroups.forEach( (k, geometryGroup) {

						addBuffer( scene["__webglObjects"], geometryGroup, webglobject );

					});

				}

			} else if ( object is Ribbon ||
						object is Line ||
						object is ParticleSystem ) {

				addBuffer( scene["__webglObjects"],  geometry, webglobject );

			} else if ( object is ImmediateRenderObject || (object["immediateRenderCallback"] != null) ) {

				addBufferImmediate( scene["__webglObjectsImmediate"], webglobject );

			} else if ( object is Sprite ) {

				scene["__webglSprites"].add( object );

			} else if ( object is LensFlare ) {

				scene["__webglFlares"].add( object );

			}

			webglobject.__webglActive = true;

		}

	}

	addBuffer ( objlist, WebGLGeometry buffer, WebGLObject object ) {

	  var o = new WebGLObject._internal(object.object, null, null, buffer, object.render, object.z);
		objlist.add(o);

	}

	addBufferImmediate ( objlist, WebGLObject object ) {

	  var o = new WebGLObject._internal(object.object, null, null, null, object.render, object.z);

		objlist.add(o);

	}

	// Objects updates

	updateObject ( WebGLObject webglobject ) {

   Object3D object = webglobject.object;
		WebGLGeometry geometry = webglobject.webglgeometry, geometryGroup;
		var customAttributesDirty;

		WebGLMaterial material;

		if ( object is Mesh ) {

			if ( object.geometry is BufferGeometry ) {

				if ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {

					setDirectBuffers( geometry, gl.DYNAMIC_DRAW, !geometry.isDynamic );

				}

				geometry.verticesNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

			} else {

				// check all geometry groups

				for( var i = 0, il = geometry.geometryGroupsList.length; i &lt; il; i ++ ) {

					geometryGroup = geometry.geometryGroupsList[ i ];

					material = getBufferMaterial( webglobject, geometryGroup );

					if ( geometry.buffersNeedUpdate ) {

						initMeshBuffers( geometryGroup, webglobject );

					}

					customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

						setMeshBuffers( geometryGroup, webglobject, gl.DYNAMIC_DRAW, !geometry.isDynamic, material );

					}

				}

				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

				geometry.buffersNeedUpdate = false;

				if (material.attributes != null) {
				  clearCustomAttributes( material );
				}

			}

		} else if ( object is Ribbon ) {

			material = getBufferMaterial( webglobject, geometry );

			customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty ) {

				setRibbonBuffers( geometry, gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;

			if (material.attributes != null) {
				clearCustomAttributes( material );
			}

		} else if ( object is Line ) {

			material = getBufferMaterial( webglobject, geometry );

			customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate ||  geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			if (material.attributes != null) clearCustomAttributes( material );

		} else if ( object is ParticleSystem ) {

			if ( geometry is BufferGeometry ) {

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {

					setDirectBuffers( geometry, gl.DYNAMIC_DRAW, !geometry.isDynamic );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

			} else {

				material = getBufferMaterial( webglobject, geometryGroup );

				customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

					setParticleBuffers( geometry, gl.DYNAMIC_DRAW, object );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

				if (material.attributes != null) clearCustomAttributes( material );
			}

		}

	}

	// Objects updates - custom attributes check

	areCustomAttributesDirty( material ) =&gt; material.attributes.values.any((a) =&gt; a.needsUpdate);

	clearCustomAttributes( material ) =&gt; material.attributes.forEach((_, a) { a.needsUpdate = false; });

	// Objects removal

	removeObject ( Object3D object, scene ) {

	  WebGLObject webglobject = new WebGLObject(object);

		if ( object is Mesh  ||
			 object is ParticleSystem ||
			 object is Ribbon ||
			 object is Line ) {

			removeInstances( scene["__webglObjects"], object );

		} else if ( object is Sprite ) {

			removeInstancesDirect( scene["__webglSprites"], object );

		} else if ( object is LensFlare ) {

			removeInstancesDirect( scene["__webglFlares"], object );

		} else if ( object is ImmediateRenderObject || (object["immediateRenderCallback"] != null) ) {

			removeInstances( scene["__webglObjectsImmediate"], object );

		}

		webglobject.__webglActive = false;

	}

	removeInstances ( objlist, Object3D object ) {

		for ( var o = objlist.length - 1; o &gt;= 0; o -- ) {

			if ( objlist[ o ].object == object ) {

				objlist.removeAt( o );

			}

		}

	}

	removeInstancesDirect ( objlist, Object3D object ) {

		for ( var o = objlist.length - 1; o &gt;= 0; o -- ) {

     if ( identical(objlist[ o ], object) ) {

				objlist.removeAt( o );

			}

		}

	}

	// Materials

	initMaterial( WebGLMaterial material, List&lt;Light&gt; lights, Fog fog, WebGLObject webglobject ) {

		//material.addEventListener( 'dispose', onMaterialDispose );

	  Object3D object = webglobject.object;

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material.isMeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material.isMeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material.isMeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material.isMeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material.isMeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material.isLineBasicMaterial ) {

			shaderID = 'basic';

		// TODO - Added LineDashedMaterial
		// } else if ( material.isLineDashedMaterial ) {

		//	shaderID = 'dashed';

		} else if ( material.isParticleBasicMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID != null) {

			setMaterialShaders( material, ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		material.program = buildProgram(
			shaderID,
			material.fragmentShader,
			material.vertexShader,
			material.uniforms,
			material.attributes,
			material.defines,
			map: material.map,
			envMap: material.envMap,
			lightMap: material.lightMap,
			bumpMap: material.bumpMap,
			normalMap: material.normalMap,
			specularMap: material.specularMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog is FogExp2,

			sizeAttenuation: material.sizeAttenuation,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: supportsBoneTextures &amp;&amp; object != null &amp;&amp; object is SkinnedMesh &amp;&amp; object.useVertexTexture,
			boneTextureWidth: (object != null &amp;&amp; object is SkinnedMesh) ? object.boneTextureWidth : null,
			boneTextureHeight: (object != null &amp;&amp; object is SkinnedMesh) ? object.boneTextureHeight : null,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: maxMorphTargets,
			maxMorphNormals: maxMorphNormals,

			maxDirLights: maxLightCount['directional'],
			maxPointLights: maxLightCount['point'],
			maxSpotLights: maxLightCount['spot'],
			maxHemiLights: maxLightCount['hemi'],

			maxShadows: maxShadows,
			shadowMapEnabled: shadowMapEnabled &amp;&amp; object.receiveShadow,
			shadowMapType: shadowMapType,
			shadowMapDebug: shadowMapDebug,
			shadowMapCascade: shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			perPixel: material.perPixel,
			wrapAround: material.wrapAround,
			doubleSided: material.side == DoubleSide,
			flipSided: material.side == BackSide );

		var attributes = material.program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i &lt; maxMorphTargets; i ++ ) {

				id = "$base$i";

				if ( attributes[ id ] &gt;= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = "morphNormal";

			for ( i = 0; i &lt; maxMorphNormals; i ++ ) {

				id = "$base$i";

				if ( attributes[ id ] &gt;= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		material.uniforms.forEach( (k, u) =&gt; material.uniformsList.add( [ u, k ] ));

	}

	setMaterialShaders( WebGLMaterial material, shaders ) {

		material.uniforms = UniformsUtils.clone( shaders["uniforms"] );
		material.vertexShader = shaders["vertexShader"];
		material.fragmentShader = shaders["fragmentShader"];

	}

	setProgram( WebGLCamera camera, List lights, Fog fog, WebGLMaterial material, WebGLObject object ) {

	  _usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program != null ) deallocateMaterial( material );

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( object.__webglMorphTargetInfluences == null) {

				object.__webglMorphTargetInfluences = new Float32List( maxMorphTargets );

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

   if ( !identical(program, _currentProgram) ) {

			_gl.useProgram( program.glProgram );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id != _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

   if ( refreshMaterial || !identical(camera, _currentCamera) ) {

			_gl.uniformMatrix4fv( p_uniforms["projectionMatrix"], false, camera.projectionMatrix.storage );

     if ( !identical(camera, _currentCamera) ) _currentCamera = camera;

		}


		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( supportsBoneTextures &amp;&amp; object.useVertexTexture ) {

				if ( p_uniforms.boneTexture != null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					setTexture( object.boneTexture, textureUnit );

				}

			} else {

				if ( p_uniforms.boneGlobalMatrices != null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( (fog != null) &amp;&amp; material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material.isMeshPhongMaterial ||
				 material.isMeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					setupLights( program, lights );
					_lightsNeedUpdate = false;

				}

				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material.isMeshBasicMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isMeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			// TODO - Implement LineDashedMaterial
			//} else if ( material instanceof THREE.LineDashedMaterial ) {

			//	refreshUniformsLine( m_uniforms, material );
			//	refreshUniformsDash( m_uniforms, material );

			} else if ( material.isParticleBasicMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				m_uniforms["mNear"].value = camera.near;
				m_uniforms["mFar"].value = camera.far;
				m_uniforms["opacity"].value = material.opacity;

			} else if ( material.isMeshNormalMaterial ) {

				m_uniforms["opacity"].value = material.opacity;

			}

			if ( object.receiveShadow &amp;&amp; ! material.shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				 material.isMeshPhongMaterial ||
				 (material.envMap != null) ) {

				if ( p_uniforms["cameraPosition"] != null ) {

					_vector3 = camera.matrixWorld.getTranslation();
					_gl.uniform3f( p_uniforms["cameraPosition"], _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material.isMeshPhongMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms["viewMatrix"] != null ) {

					_gl.uniformMatrix4fv( p_uniforms["viewMatrix"], false, camera.matrixWorldInverse.storage );

				}

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms["modelMatrix"] != null ) {

			_gl.uniformMatrix4fv( p_uniforms["modelMatrix"], false, object.matrixWorld.storage );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	refreshUniformsCommon ( Map&lt;String, Uniform&gt; uniforms, material ) {

		uniforms["opacity"].value = material.opacity;

		if ( gammaInput ) {

			uniforms["diffuse"].value.copyGammaToLinear( material.color );

		} else {

			uniforms["diffuse"].value = material.color;

		}

		uniforms["map"].value = material.map;
		uniforms["lightMap"].value = material.lightMap;
		uniforms["specularMap"].value = material.specularMap;

		if ( material.bumpMap != null ) {

			uniforms["bumpMap"].value = material.bumpMap;
			uniforms["bumpScale"].value = material.bumpScale;

		}

		if ( material.normalMap != null ) {

			uniforms["normalMap"].value = material.normalMap;
			uniforms["normalScale"].value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. normal map
		//	4. bump map

		var uvScaleMap;

		if ( material.map != null ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap != null ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap != null ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap != null ) {

			uvScaleMap = material.bumpMap;

		}

		if ( uvScaleMap != null ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms["offsetRepeat"].value.setValues( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms["envMap"].value = material.envMap;
		uniforms["flipEnvMap"].value = ( material.envMap is WebGLRenderTargetCube ) ? 1 : -1;

		if ( gammaInput ) {

			//uniforms["reflectivity"].value = material.reflectivity * material.reflectivity;
			uniforms["reflectivity"].value = material.reflectivity;

		} else {

			uniforms["reflectivity"].value = material.reflectivity;

		}

		uniforms["refractionRatio"].value = material.refractionRatio;
		uniforms["combine"].value = material.combine;
		uniforms["useRefract"].value = ((material.envMap != null) &amp;&amp; (material.envMap.mapping is CubeRefractionMapping))? 1:0;

	}

	refreshUniformsLine ( uniforms, material ) {

		uniforms["diffuse"].value = material.color;
		uniforms["opacity"].value = material.opacity;

	}

	refreshUniformsDash ( uniforms, material ) {

		uniforms["dashSize"].value = material.dashSize;
		uniforms["totalSize"].value = material.dashSize + material.gapSize;
		uniforms["scale"].value = material.scale;

	}

	refreshUniformsParticle ( uniforms, material ) {

		uniforms["psColor"].value = material.color;
		uniforms["opacity"].value = material.opacity;
		uniforms["size"].value = material.size;
		uniforms["scale"].value = canvas.height / 2.0; // TODO: Cache

		uniforms["map"].value = material.map;

	}

	refreshUniformsFog ( uniforms, Fog fog ) {

		uniforms["fogColor"].value = fog.color;

		if ( fog is FogLinear ) {

			uniforms["fogNear"].value = fog.near;
			uniforms["fogFar"].value = fog.far;

		} else if ( fog is FogExp2 ) {

			uniforms["fogDensity"].value = fog.density;

		}

	}

	refreshUniformsPhong ( uniforms, material ) {

		uniforms["shininess"].value = material.shininess;

		if ( gammaInput ) {

			uniforms["ambient"].value.copyGammaToLinear( material.ambient );
			uniforms["emissive"].value.copyGammaToLinear( material.emissive );
			uniforms["specular"].value.copyGammaToLinear( material.specular );

		} else {

			uniforms["ambient"].value = material.ambient;
			uniforms["emissive"].value = material.emissive;
			uniforms["specular"].value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms["wrapRGB"].value.copy( material.wrapRGB );

		}

	}

	refreshUniformsLambert ( uniforms, material ) {

		if ( gammaInput ) {

			uniforms["ambient"].value.copyGammaToLinear( material.ambient );
			uniforms["emissive"].value.copyGammaToLinear( material.emissive );

		} else {

			uniforms["ambient"].value = material.ambient;
			uniforms["emissive"].value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms["wrapRGB"].value.copy( material.wrapRGB );

		}

	}

	refreshUniformsLights ( Map&lt;String, Uniform&gt; uniforms, Map lights ) {

		uniforms["ambientLightColor"].value = lights["ambient"];

		uniforms["directionalLightColor"].value = lights["directional"]["colors"];
		uniforms["directionalLightDirection"].value = lights["directional"]["positions"];

		uniforms["pointLightColor"].value = lights["point"]["colors"];
		uniforms["pointLightPosition"].value = lights["point"]["positions"];
		uniforms["pointLightDistance"].value = lights["point"]["distances"];

		uniforms["spotLightColor"].value = lights["spot"]["colors"];
		uniforms["spotLightPosition"].value = lights["spot"]["positions"];
		uniforms["spotLightDistance"].value = lights["spot"]["distances"];
		uniforms["spotLightDirection"].value = lights["spot"]["directions"];
		uniforms["spotLightAngleCos"].value = lights["spot"]["anglesCos"];
		uniforms["spotLightExponent"].value = lights["spot"]["exponents"];

		uniforms["hemisphereLightSkyColor"].value = lights["hemi"]["skyColors"];
		uniforms["hemisphereLightGroundColor"].value = lights["hemi"]["groundColors"];
		uniforms["hemisphereLightDirection"].value = lights["hemi"]["positions"];
	}

	refreshUniformsShadow ( Map&lt;String, Uniform&gt; uniforms, lights ) {

		if ( uniforms.containsKey("shadowMatrix") ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i &lt; il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light is SpotLight || ( light is DirectionalLight &amp;&amp; ! light.shadowCascade ) ) {

				  // Grow the arrays
				  if (uniforms["shadowMap"].value.length &lt; j + 1) {
				    uniforms["shadowMap"].value.length = j + 1;
				    uniforms["shadowMapSize"].value.length = j + 1;
				    uniforms["shadowMatrix"].value.length = j + 1;
				    uniforms["shadowDarkness"].value.length = j + 1;
				    uniforms["shadowBias"].value.length = j + 1;
				  }

					uniforms["shadowMap"].value[ j ] = light.shadowMap;
					uniforms["shadowMapSize"].value[ j ] = light.shadowMapSize;

					uniforms["shadowMatrix"].value[ j ] = light.shadowMatrix;

					uniforms["shadowDarkness"].value[ j ] = light.shadowDarkness;
					uniforms["shadowBias"].value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	}

	// Uniforms (load to GPU)

	loadUniformsMatrices ( uniforms, WebGLObject object ) {

		_gl.uniformMatrix4fv( uniforms["modelViewMatrix"], false, object._modelViewMatrix.storage );

		if ( uniforms["normalMatrix"] != null ) {

			_gl.uniformMatrix3fv( uniforms["normalMatrix"], false, object._normalMatrix.storage );

		}

	}

	int getTextureUnit() {

   var unit = _usedTextureUnits;

   if ( unit &gt;= maxTextures ) {
     print( "WebGLRenderer: trying to use $unit texture units while this GPU supports only $maxTextures" );
   }

   _usedTextureUnits += 1;

   return unit;

 }

	loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;

		jl = uniforms.length;
		for ( j = 0; j &lt; jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( location == null ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.typedValue; // Get the value properly typed

			if ( type == "i" ) { // single integer

				_gl.uniform1i( location, value );

			} else if ( type == "f" ) { // single float

				_gl.uniform1f( location, value );

			} else if ( type == "v2" ) { // single THREE.Vector2

				_gl.uniform2f( location, value.x, value.y );

			} else if ( type == "v3" ) { // single THREE.Vector3

				_gl.uniform3f( location, value.x, value.y, value.z );

			} else if ( type == "v4" ) { // single THREE.Vector4

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			} else if ( type == "c" ) { // single THREE.Color

				_gl.uniform3f( location, value.r, value.g, value.b );

			} else if ( type == "iv1" ) { // flat array of integers (JS or typed array)

				_gl.uniform1iv( location, value );

			} else if ( type == "iv" ) { // flat array of integers with 3 x N size (JS or typed array)

				_gl.uniform3iv( location, value );

			} else if ( type == "fv1" ) { // flat array of floats (JS or typed array)

				_gl.uniform1fv( location, value );

			} else if ( type == "fv" ) { // flat array of floats with 3 x N size (JS or typed array)

				_gl.uniform3fv( location, value );

			} else if ( type == "v2v" ) { // array of THREE.Vector2

				_gl.uniform2fv( location, value );

			} else if ( type == "v3v" ) { // array of THREE.Vector3

				_gl.uniform3fv( location, value );

			} else if ( type == "v4v" ) { // array of THREE.Vector4

				_gl.uniform4fv( location, value );

			} else if ( type == "m2") { // single THREE.Matrix2

				_gl.uniformMatrix2fv( location, false, value );

			} else if ( type == "m3") { // single THREE.Matrix3

				_gl.uniformMatrix3fv( location, false, value );

			} else if ( type == "m4") { // single THREE.Matrix4

				_gl.uniformMatrix4fv( location, false, value );

			} else if ( type == "m4v" ) { // array of THREE.Matrix4

				_gl.uniformMatrix4fv( location, false, value );

			} else if ( type == "t" ) { // single THREE.Texture (2d or cube)

	       texture = uniform.value;
	       textureUnit = getTextureUnit();

				_gl.uniform1i( location, textureUnit );

				if ( texture == null ) continue;

				if ( (texture.image is ImageList || texture.image is WebGLImageList) &amp;&amp; texture.image.length == 6 ) {

					setCubeTexture( texture, textureUnit );

				} else if ( texture is WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, textureUnit );

				} else {

					setTexture( texture, textureUnit );

				}

			} else if ( type == "tv" ) { // array of THREE.Texture (2d)

			  List&lt;Texture&gt; textures = uniform.value;

			  uniform._array = new Int32List.fromList(textures.map((_) =&gt; getTextureUnit()).toList());

				_gl.uniform1iv( location, uniform._array );

				il = textures.length;
				for( i = 0; i &lt; il; i ++ ) {

					texture = uniform.value[ i ];
         textureUnit = uniform._array[i];

					if ( texture == null) continue;

					setTexture( texture, textureUnit );

				}

			}

		}

	}

	setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	}

	setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	setupMatrices ( WebGLObject object, WebGLCamera camera ) {

		object._modelViewMatrix = camera.matrixWorldInverse * object.matrixWorld;

		object._normalMatrix = calcInverse( object._modelViewMatrix );
		object._normalMatrix.transpose();

	}

	setupLights ( Program program, List&lt;Light&gt; lights ) {

		var l, ll, light, n,
		r = 0.0, g = 0.0, b = 0.0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights;

		List dirColors = zlights["directional"]["colors"],
		     dirPositions = zlights["directional"]["positions"],

		     pointColors = zlights["point"]["colors"],
		     pointPositions = zlights["point"]["positions"],
     	 pointDistances = zlights["point"]["distances"],

     	 spotColors = zlights["spot"]["colors"],
     	 spotPositions = zlights["spot"]["positions"],
     	 spotDistances = zlights["spot"]["distances"],
     	 spotDirections = zlights["spot"]["directions"],
     	 spotAnglesCos = zlights["spot"]["anglesCos"],
     	 spotExponents = zlights["spot"]["exponents"],

     	 hemiSkyColors = zlights["hemi"]["skyColors"],
		 hemiGroundColors = zlights["hemi"]["groundColors"],
		 hemiPositions = zlights["hemi"]["positions"];

		var dirLength = 0,
   		pointLength = 0,
   		spotLength = 0,
  			hemiLength = 0,

			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,

   		dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l ++ ) {

			light = lights[ l ];

			// TODO - Setup proper interfaces for Light to avoid type checks
			if ( (((light is DirectionalLight) || (light is SpotLight)) &amp;&amp; (light as dynamic).onlyShadow) ||
			    ! light.visible ) { continue;
			}

			color = light.color;

			if ( (light is DirectionalLight) || (light is SpotLight) || (light is PointLight)) {
 			intensity = (light as dynamic).intensity;
 			distance = (light as dynamic).distance;
			}

			if ( light is AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light is DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction = light.matrixWorld.getTranslation();
				_vector3 = light.target.matrixWorld.getTranslation();
				_direction.sub(_vector3);
				_direction.normalize();

				 // skip lights with undefined direction
       // these create troubles in OpenGL (making pixel black)

       if (_direction.x == 0 &amp;&amp; _direction.y == 0 &amp;&amp; _direction.z == 0)
         continue;

       dirOffset = dirLength * 3;

       // Grow the lists
       dirColors.length = dirOffset + 3;
       dirPositions.length = dirOffset + 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;


				if ( gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if( light is PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

       		// Grow the lists
				pointColors.length = pointOffset + 3;
				pointPositions.length = pointOffset + 3;

				if ( gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				position = light.matrixWorld.getTranslation();

				pointPositions[ pointOffset ]     = position.x;
				pointPositions[ pointOffset + 1 ] = position.y;
				pointPositions[ pointOffset + 2 ] = position.z;

				if (pointDistances==null) { pointDistances = new List(); pointDistances.add(0); }
				if (pointDistances.length == 0) {pointDistances.add(0);}
				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if( light is SpotLight ) {

				spotCount += 1;

				spotOffset = spotLength * 3;

				if ( ! light.visible ) continue;

       		// Grow the lists
				spotColors.length = spotOffset + 3;
				spotPositions.length = spotOffset + 3;
				spotDirections.length = spotOffset + 3;
				spotDistances.length = spotLength + 1;

				if ( gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				position = light.matrixWorld.getTranslation();

				spotPositions[ spotOffset ]     = position.x;
				spotPositions[ spotOffset + 1 ] = position.y;
				spotPositions[ spotOffset + 2 ] = position.z;

				spotDistances[ spotLength ] = distance;

				_direction.setFrom( position );
				_direction.sub( light.target.matrixWorld.getTranslation() );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				// grow the arrays
				spotAnglesCos.length = spotLength + 1;
				spotExponents.length = spotLength + 1;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light is HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				position = light.matrixWorld.getTranslation();
				_direction.setFrom( position );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x == 0 &amp;&amp; _direction.y == 0 &amp;&amp; _direction.z == 0 ) continue;

				hemiOffset = hemiLength * 3;

				// Grow the lists
				hemiSkyColors.length = hemiOffset + 3;
				hemiGroundColors.length = hemiOffset + 3;
				hemiPositions.length = hemiOffset + 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		ll =  Math.max( dirColors.length, dirCount * 3 );
		for ( l = dirLength * 3; l &lt; ll; l ++ ) dirColors[ l ] = 0.0;
		ll = Math.max( pointColors.length, pointCount * 3 );
		for ( l = pointLength * 3; l &lt; ll; l ++ ) pointColors[ l ] = 0.0;
		ll = Math.max( spotColors.length, spotCount * 3 );
		for ( l = spotLength * 3; l &lt; ll; l ++ ) spotColors[ l ] = 0.0;
		ll = Math.max( hemiSkyColors.length, hemiCount * 3 );
		for ( l = hemiLength * 3; l &lt; ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		ll = Math.max( hemiGroundColors.length, hemiCount * 3 );
		for ( l = hemiLength * 3; l &lt; ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights["directional"]["length"] = dirLength;
		zlights["point"]["length"] = pointLength;
		zlights["spot"]["length"] = spotLength;
		zlights["hemi"]["length"] = hemiLength;

		zlights["ambient"][ 0 ] = r;
		zlights["ambient"][ 1 ] = g;
		zlights["ambient"][ 2 ] = b;

	}

	// GL state setting

	setFaceCulling( cullFace, frontFaceDirection ) {

		if ( cullFace == CullFaceNone ) {

			_gl.disable( gl.CULL_FACE );

		} else {

			if ( frontFaceDirection == FrontFaceDirectionCW ) {

				_gl.frontFace( gl.CW );

			} else {

				_gl.frontFace( gl.CCW );

			}

			if ( cullFace == CullFaceBack ) {

				_gl.cullFace( gl.BACK );

			} else if ( cullFace == CullFaceFront ) {

				_gl.cullFace( gl.FRONT );

			} else {

				_gl.cullFace( gl.FRONT_AND_BACK );

			}

			_gl.enable( gl.CULL_FACE );

		}

	}

	setMaterialFaces( material ) {

		var doubleSided = material.side == DoubleSide;
		var flipSided = material.side == BackSide;

		if ( _oldDoubleSided != doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( gl.CULL_FACE );

			} else {

				_gl.enable( gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided != flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( gl.CW );

			} else {

				_gl.frontFace( gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	}

	setDepthTest( depthTest ) {

		if ( _oldDepthTest != depthTest ) {

			if ( depthTest ) {

				_gl.enable( gl.DEPTH_TEST );

			} else {

				_gl.disable( gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	}

	setDepthWrite( depthWrite ) {

		if ( _oldDepthWrite != depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	}

	setLineWidth ( width ) {

		if ( width != _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	}

	setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset != polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset &amp;&amp; ( _oldPolygonOffsetFactor != factor || _oldPolygonOffsetUnits != units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	}

	setBlending( blending, [blendEquation, blendSrc, blendDst] ) {

		if ( blending != _oldBlending ) {

			if ( blending == NoBlending ) {

				_gl.disable( gl.BLEND );

			} else if ( blending == AdditiveBlending ) {

				_gl.enable( gl.BLEND );
				_gl.blendEquation( gl.FUNC_ADD );
				_gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

			} else if ( blending == SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( gl.BLEND );
				_gl.blendEquation( gl.FUNC_ADD );
				_gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending == MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( gl.BLEND );
				_gl.blendEquation( gl.FUNC_ADD );
				_gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

			} else if ( blending == CustomBlending ) {

				_gl.enable( gl.BLEND );

			} else {

				_gl.enable( gl.BLEND );
				_gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
				_gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending == CustomBlending ) {

			if ( blendEquation != _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc != _oldBlendSrc || blendDst != _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	}

	// Defines

	generateDefines ( defines ) {

		var chunk, chunks = [];

		defines.forEach((d, value) {

			if ( value != false ) {
				chunk = "#define $d $value";
				chunks.add( chunk );
			}

		});

		return chunks.join( "\n" );

	}

	// Shaders

	Program buildProgram( String shaderID, String fragmentShader, String vertexShader, uniforms, attributes, defines,
	                      {	int maxDirLights: 0,
					int maxPointLights: 0,
					int maxSpotLights: 0,
					int maxHemiLights: 0,
					int maxShadows: 0,
					int maxBones: 0,
					Texture map: null,
					Texture envMap: null,
					bool lightMap: false,
					bool bumpMap: false,
					bool normalMap: false,
					bool specularMap: false,
					var vertexColors: NoColors,
					bool skinning: false,
					bool useVertexTexture: false,
					num boneTextureWidth: null,
					num boneTextureHeight: null,
					bool morphTargets: false,
					bool morphNormals: false,
					bool perPixel: false,
					bool wrapAround: false,
					bool doubleSided: false,
					bool flipSided: false,
					bool shadowMapEnabled: false,
					int shadowMapType,
					bool shadowMapDebug: false,
					bool shadowMapCascade: false,
					bool sizeAttenuation: false,
					Fog fog: null,
		      bool useFog: false,
		      bool fogExp: false,
		      int maxMorphTargets: 8,
		      int maxMorphNormals: 4,
		      num alphaTest: 0,
		      bool metal: false} ) {

		var p, pl, glprogram, code;
		var chunks = [];

		// Generate code

		if ( shaderID != null ) {

			chunks.add( shaderID );

		} else {

			chunks.add( fragmentShader );
			chunks.add( vertexShader );

		}

		defines.forEach((d, define) {
			chunks.add( d );
			chunks.add( define );
		});

		code =  "${chunks.join()}"
		        "maxDirLights$maxDirLights"
		        "maxPointLights$maxPointLights"
		        "maxSpotLights$maxSpotLights"
		        "maxHemiLights$maxHemiLights"
		        "maxShadows$maxShadows"
		        "maxBones$maxBones"
		        "map$map"
		        "envMap$envMap"
		        "lightMap$lightMap"
		        "bumpMap$bumpMap"
		        "normalMap$normalMap"
		        "specularMap$specularMap"
		        "vertexColors$vertexColors"
		        "fog$fog"
	          "useFog$useFog"
	          "fogExp$fogExp"
		        "skinning$skinning"
		        "useVertexTexture$useVertexTexture"
		        "boneTextureWidth$boneTextureWidth"
		        "boneTextureHeight$boneTextureHeight"
		        "morphTargets$morphTargets"
           "morphNormals$morphNormals"
           "perPixel$perPixel"
           "wrapAround$wrapAround"
		        "doubleSided$doubleSided"
		        "flipSided$flipSided"
           "shadowMapEnabled$shadowMapEnabled"
           "shadowMapType$shadowMapType"
           "shadowMapDebug$shadowMapDebug"
		        "shadowMapCascade$shadowMapCascade"
           "sizeAttenuation$sizeAttenuation";


		// Check if code has been already compiled

		pl = _programs.length;
		for ( p = 0; p &lt; pl; p ++ ) {

			Program program = _programs[ p ];

			// TODO - why do we need identical here ?!
     if ( program.code == code ) {

				//print( "Code already compiled: $program$code" );

			  program.usedTimes ++;

				return program;

			}

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( shadowMapType == PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( shadowMapType == PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		//print( "building new program " );

		//

		var customDefines = generateDefines( defines );

		glprogram = _gl.createProgram();

		var prefix_vertex = [

			"precision $precision float;",

			customDefines,

			supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			gammaInput ? "#define GAMMA_INPUT" : "",
			gammaOutput ? "#define GAMMA_OUTPUT" : "",
			physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			"#define MAX_DIR_LIGHTS $maxDirLights",
			"#define MAX_POINT_LIGHTS $maxPointLights",
			"#define MAX_SPOT_LIGHTS $maxSpotLights",
			"#define MAX_HEMI_LIGHTS $maxHemiLights",

			"#define MAX_SHADOWS $maxShadows",

			"#define MAX_BONES $maxBones",

			(map != null) ? "#define USE_MAP" : "",
			(envMap != null) ? "#define USE_ENVMAP" : "",
			(lightMap != null) ? "#define USE_LIGHTMAP" : "",
			(bumpMap != null) ? "#define USE_BUMPMAP" : "",
			(normalMap != null) ? "#define USE_NORMALMAP" : "",
			(specularMap != null) ? "#define USE_SPECULARMAP" : "",
			(((vertexColors is bool) &amp;&amp; vertexColors) || ((vertexColors is int) &amp;&amp; (vertexColors != NoColors))) ? "#define USE_COLOR" : "",

			skinning ? "#define USE_SKINNING" : "",
			useVertexTexture ? "#define BONE_TEXTURE" : "",
			(boneTextureWidth != null) ? "#define N_BONE_PIXEL_X ${boneTextureWidth.toStringAsFixed(1)}" : "",
			(boneTextureHeight != null) ? "#define N_BONE_PIXEL_Y ${boneTextureHeight.toStringAsFixed( 1 )}" : "",

			morphTargets ? "#define USE_MORPHTARGETS" : "",
			morphNormals ? "#define USE_MORPHNORMALS" : "",
			perPixel ? "#define PHONG_PER_PIXEL" : "",
			wrapAround ? "#define WRAP_AROUND" : "",
			doubleSided ? "#define DOUBLE_SIDED" : "",
			flipSided ? "#define FLIP_SIDED" : "",

			shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			shadowMapEnabled ? "#define $shadowMapTypeDefine" : "",
			shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",

				"#ifdef USE_MORPHNORMALS",

					"attribute vec3 morphNormal0;",
					"attribute vec3 morphNormal1;",
					"attribute vec3 morphNormal2;",
					"attribute vec3 morphNormal3;",

				"#else",

					"attribute vec3 morphTarget4;",
					"attribute vec3 morphTarget5;",
					"attribute vec3 morphTarget6;",
					"attribute vec3 morphTarget7;",

				"#endif",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		].join("\n");

		var prefix_fragment = [

			"precision $precision float;",

			( bumpMap != null || normalMap != null ) ? "#extension GL_OES_standard_derivatives : enable" : "",

			customDefines,

			(bumpMap != null) ? "#extension GL_OES_standard_derivatives : enable" : "",

			"#define MAX_DIR_LIGHTS $maxDirLights",
			"#define MAX_POINT_LIGHTS $maxPointLights",
			"#define MAX_SPOT_LIGHTS $maxSpotLights",
			"#define MAX_HEMI_LIGHTS $maxHemiLights",

			"#define MAX_SHADOWS $maxShadows",

			(alphaTest != 0) ? "#define ALPHATEST $alphaTest": "",

			gammaInput ? "#define GAMMA_INPUT" : "",
			gammaOutput ? "#define GAMMA_OUTPUT" : "",
			physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			( useFog &amp;&amp; (fog != null) ) ? "#define USE_FOG" : "",
			( useFog &amp;&amp; (fog is FogExp2) ) ? "#define FOG_EXP2" : "",

			(map != null) ? "#define USE_MAP" : "",
			(envMap != null) ? "#define USE_ENVMAP" : "",
			(lightMap != null) ? "#define USE_LIGHTMAP" : "",
			(bumpMap != null) ? "#define USE_BUMPMAP" : "",
			(normalMap != null) ? "#define USE_NORMALMAP" : "",
			(specularMap != null) ? "#define USE_SPECULARMAP" : "",
			(((vertexColors is bool) &amp;&amp; vertexColors) || ((vertexColors is int) &amp;&amp; (vertexColors != NoColors))) ? "#define USE_COLOR" : "",

			metal ? "#define METAL" : "",
			perPixel ? "#define PHONG_PER_PIXEL" : "",
			wrapAround ? "#define WRAP_AROUND" : "",
			doubleSided ? "#define DOUBLE_SIDED" : "",
			flipSided ? "#define FLIP_SIDED" : "",

			shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			shadowMapEnabled ? "#define $shadowMapTypeDefine" : "",
			shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		].join("\n");

		var glFragmentShader = getShader( "fragment", "$prefix_fragment$fragmentShader" );
		var glVertexShader = getShader( "vertex", "$prefix_vertex$vertexShader" );

		_gl.attachShader( glprogram, glVertexShader );
		_gl.attachShader( glprogram, glFragmentShader );

		_gl.linkProgram( glprogram );

		if ( !_gl.getProgramParameter( glprogram, gl.LINK_STATUS ) ) {

		  var status = _gl.getProgramParameter( glprogram, gl.VALIDATE_STATUS );
		  var error = _gl.getError();
			print( "Could not initialise shader\nVALIDATE_STATUS: $status, gl error [$error]" );

		}

		// clean up

		_gl.deleteShader( glFragmentShader );
		_gl.deleteShader( glVertexShader );

		//print( prefix_fragment + fragmentShader );
		//print( prefix_vertex + vertexShader );

		//program.uniforms = {};
		//program.attributes = {};

		var program = new Program( _programs_counter++,  glprogram, code, usedTimes: 1 );

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'morphTargetInfluences'

		];

		if ( useVertexTexture ) {

			identifiers.add( 'boneTexture' );

		} else {

			identifiers.add( 'boneGlobalMatrices' );

		}

		uniforms.forEach((u, _) =&gt; identifiers.add( u ));

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( i = 0; i &lt; maxMorphTargets; i ++ ) {

			identifiers.add( "morphTarget$i" );

		}

		for ( i = 0; i &lt; maxMorphNormals; i ++ ) {

			identifiers.add( "morphNormal$i" );

		}

		if (attributes != null) {
		  attributes.forEach((a, _) =&gt; identifiers.add( a ));
		}

		cacheAttributeLocations( program, identifiers );

		_programs.add( program );

		info.memory.programs = _programs.length;

		return program;

	}

	// Shader parameters cache

	cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		l = identifiers.length;
		for( i = 0; i &lt; l; i ++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program.glProgram, id );

		}

	}

	cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		l = identifiers.length;
		for( i = 0; i &lt; l; i ++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program.glProgram, id );

		}

	}

	addLineNumbers ( string ) {

		var chunks = string.split( "\n" );

		var il = chunks.length;
		for ( var i = 0; i &lt; il; i ++ ) {

			// Chrome reports shader errors on lines
			// starting counting from 1

			chunks[ i ] = "${i + 1}:${chunks[i]}";

		}

		return chunks.join( "\n" );

	}

	getShader ( type, string ) {

		var shader;

		if ( type == "fragment" ) {

			shader = _gl.createShader( gl.FRAGMENT_SHADER );

		} else if ( type == "vertex" ) {

			shader = _gl.createShader( gl.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {

			print( _gl.getShaderInfoLog( shader ) );
			print( addLineNumbers( string ) );
			return null;

		}

		return shader;

	}

	// Textures


	isPowerOfTwo ( int value ) =&gt; ( value &amp; ( value - 1 ) ) == 0;

	setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		if ( (_glExtensionTextureFilterAnisotropic != null) &amp;&amp; texture.type != FloatType ) {

			if ( texture.anisotropy &gt; 1 || ( texture["__oldAnisotropy"] != null) ) {

				_gl.texParameterf( textureType, gl.ExtTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, maxAnisotropy ) );
				texture["__oldAnisotropy"] = texture.anisotropy;

			}

		}

	}

	_checkGLError() {
   int error = _gl.getError();
   if (error != 0) {
     print( "gl error [$error]" );
   }
	}

	setTexture( Texture texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( texture["__webglInit"] == null ) {

				texture["__webglInit"] = true;

				//texture.addEventListener( 'dispose', onTextureDispose );

				texture["__webglTexture"] = _gl.createTexture();

				info.memory.textures ++;

			}

			_gl.activeTexture( gl.TEXTURE0 + slot );
			_gl.bindTexture( gl.TEXTURE_2D, texture["__webglTexture"] );

			_gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, (texture.flipY) ? 1 : 0 );
			_gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, (texture.premultiplyAlpha) ? 1 : 0 );
			_gl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = texture.image,
			isImagePowerOfTwo = isPowerOfTwo( image.width ) &amp;&amp; isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture is DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length &gt; 0 &amp;&amp; isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2DTyped( gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2DTyped( gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture is CompressedTexture ) {

				// compressed textures can only use manually created mipmaps
				// WebGL can't generate mipmaps for DDS textures

				for( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.compressedTexImage2D( gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

				}

			} else {// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length &gt; 0 &amp;&amp; isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else if ( texture.image is ImageElement) {

					_gl.texImage2DImage( gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				} else if ( texture.image is CanvasElement ) {

				  _gl.texImage2DCanvas( gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				} else if ( texture.image is VideoElement ) {

				  _gl.texImage2DVideo( gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps &amp;&amp; isImagePowerOfTwo ) _gl.generateMipmap( gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate != null ) texture.onUpdate();

		} else {

			_gl.activeTexture( gl.TEXTURE0 + slot );
			_gl.bindTexture( gl.TEXTURE_2D, texture["__webglTexture"] );

		}

	}

	clampToMaxSize ( image, maxSize ) {

		if ( image.width &lt;= maxSize &amp;&amp; image.height &lt;= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = ( image.width * maxSize / maxDimension ).floor();
		var newHeight = ( image.height * maxSize / maxDimension ).floor();

		var canvas = new CanvasElement();
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.context2D;
		ctx.drawImageScaledFromSource( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}

	setCubeTexture ( Texture texture, slot ) {

		if ( texture.image.length == 6 ) {
		  if(texture.image is ImageList){
		    texture.image = new WebGLImageList(texture.image);
		  }
			if ( texture.needsUpdate ) {

				if ( texture.image.webglTextureCube == null ) {

					texture.image.webglTextureCube = _gl.createTexture();

					info.memory.textures ++;
				}

				_gl.activeTexture( gl.TEXTURE0 + slot );
				_gl.bindTexture( gl.TEXTURE_CUBE_MAP, texture.image.webglTextureCube);

				_gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, (texture.flipY) ? 1 : 0 );

				var isCompressed = texture is CompressedTexture;

				var cubeImage = new List(6);

				for ( var i = 0; i &lt; 6; i ++ ) {

					if ( autoScaleCubemaps &amp;&amp; ! isCompressed ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], maxCubemapSize );

					} else {

						cubeImage[ i ] = texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( (image as dynamic).width ) &amp;&amp; isPowerOfTwo( (image as dynamic).height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i &lt; 6; i ++ ) {

					if ( isCompressed ) {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for( var j = 0, jl = mipmaps.length; j &lt; jl; j ++ ) {

							mipmap = mipmaps[ j ];
							_gl.compressedTexImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						}

					} else {

						_gl.texImage2DImage( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

					}

				}

				if ( texture.generateMipmaps &amp;&amp; isImagePowerOfTwo ) {

					_gl.generateMipmap( gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate != null) texture.onUpdate();

			} else {

				_gl.activeTexture( gl.TEXTURE0 + slot );
				_gl.bindTexture( gl.TEXTURE_CUBE_MAP, texture.image.webglTextureCube );

			}

		}

	}

	setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( gl.TEXTURE0 + slot );
		_gl.bindTexture( gl.TEXTURE_CUBE_MAP, texture["__webglTexture"] );

	}

	// Render targets

	setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	}

	setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer &amp;&amp; ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( gl.RENDERBUFFER, gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, WebGLRenderingContext.RENDERBUFFER, renderbuffer );
		*/
		} else if( renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( gl.RENDERBUFFER, gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}

	setRenderTarget ( WebGLRenderTarget renderTarget ) {

		var isCube = ( renderTarget is WebGLRenderTargetCube );

		if ( (renderTarget != null ) &amp;&amp; ( renderTarget.__webglFramebuffer == null) ) {

			if ( renderTarget.depthBuffer == null ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer == null ) renderTarget.stencilBuffer = true;

			//renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) &amp;&amp; isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i &lt; 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2DTyped( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom != null ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2DTyped( gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom != null) {

					if ( renderTarget.depthBuffer &amp;&amp; ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget != null ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ (renderTarget as WebGLRenderTargetCube).activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

   if ( !identical(framebuffer, _currentFramebuffer) ) {

			_gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	}

	updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget is WebGLRenderTargetCube ) {

			_gl.bindTexture( gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( gl.TEXTURE_2D );
			_gl.bindTexture( gl.TEXTURE_2D, null );

		}

	}

	// Fallback filters for non-power-of-2 textures

	filterFallback ( f ) {

		if ( f == NearestFilter || f == NearestMipMapNearestFilter || f == NearestMipMapLinearFilter ) {

			return gl.NEAREST;

		}

		return gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	paramThreeToGL ( p ) {

		if ( p == RepeatWrapping ) return gl.REPEAT;
		if ( p == ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
		if ( p == MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;

		if ( p == NearestFilter ) return gl.NEAREST;
		if ( p == NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
		if ( p == NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;

		if ( p == LinearFilter ) return gl.LINEAR;
		if ( p == LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
		if ( p == LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;

		if ( p == UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p == UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p == UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p == UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

		if ( p == ByteType ) return gl.BYTE;
		if ( p == ShortType ) return gl.SHORT;
		if ( p == UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p == IntType ) return gl.INT;
		if ( p == UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p == FloatType ) return gl.FLOAT;

		if ( p == AlphaFormat ) return gl.ALPHA;
		if ( p == RGBFormat ) return gl.RGB;
		if ( p == RGBAFormat ) return gl.RGBA;
		if ( p == LuminanceFormat ) return gl.LUMINANCE;
		if ( p == LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;

		if ( p == AddEquation ) return gl.FUNC_ADD;
		if ( p == SubtractEquation ) return gl.FUNC_SUBTRACT;
		if ( p == ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;

		if ( p == ZeroFactor ) return gl.ZERO;
		if ( p == OneFactor ) return gl.ONE;
		if ( p == SrcColorFactor ) return gl.SRC_COLOR;
		if ( p == OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
		if ( p == SrcAlphaFactor ) return gl.SRC_ALPHA;
		if ( p == OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
		if ( p == DstAlphaFactor ) return gl.DST_ALPHA;
		if ( p == OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;

		if ( p == DstColorFactor ) return gl.DST_COLOR;
		if ( p == OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
		if ( p == SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;

		if ( _glExtensionCompressedTextureS3TC != null ) {

			if ( p == RGB_S3TC_DXT1_Format ) return gl.CompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p == RGBA_S3TC_DXT1_Format ) return gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p == RGBA_S3TC_DXT3_Format ) return gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p == RGBA_S3TC_DXT5_Format ) return gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}
		return 0;

	}

	// Allocations

	int allocateBones ( Object3D object ) {

		if ( supportsBoneTextures &amp;&amp; (object != null) &amp;&amp; object is SkinnedMesh &amp;&amp; object.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			// 	- leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			int nVertexUniforms = _gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			int nVertexMatrices = ( ( nVertexUniforms - 20 ) / 4 ).floor().toInt();

			var maxBones = nVertexMatrices;

			if ( object != null &amp;&amp; object is SkinnedMesh ) {

				maxBones = Math.min( object.bones.length, maxBones );

				if ( maxBones &lt; object.bones.length ) {

					print( "WebGLRenderer: too many bones - ${object.bones.length} , this GPU supports just $maxBones  (try OpenGL instead of ANGLE)" );

				}

			}

			return maxBones;

		}

	}

	allocateLights ( List&lt;Light&gt; lights ) {

		var l, ll, light, dirLights, pointLights, spotLights, hemiLights;

		dirLights = pointLights = spotLights = hemiLights = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l ++ ) {

			light = lights[ l ];

			if ( (( light is DirectionalLight ) || ( light is SpotLight )) &amp;&amp;
			    (light as dynamic).onlyShadow ) { continue;
			}

			if ( light is DirectionalLight ) dirLights ++;
			if ( light is PointLight ) pointLights ++;
			if ( light is SpotLight ) spotLights ++;
			if ( light is HemisphereLight ) hemiLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi':  hemiLights};

	}

	allocateShadows ( lights ) {

		var l, ll, light, maxShadows = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l++ ) {

			light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light is SpotLight ) maxShadows ++;
			if ( light is DirectionalLight &amp;&amp; ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	}

	// Initialization

	initGL () {

		try {
			_gl = canvas.getContext3d(alpha: alpha, premultipliedAlpha: premultipliedAlpha, antialias: antialias, stencil: stencil, preserveDrawingBuffer: preserveDrawingBuffer );
			if ( _gl == null ) {

				throw 'Error creating WebGL context.';

			}
		} catch ( error ) {

			print( error );

		}
		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' );
		if (_glExtensionTextureFilterAnisotropic == null) {
		  _glExtensionTextureFilterAnisotropic = _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' );
		}
		if (_glExtensionTextureFilterAnisotropic == null) {
		  _glExtensionTextureFilterAnisotropic = _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
		}
		if (_glExtensionCompressedTextureS3TC == null) {
			_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' );
		}
		if (_glExtensionCompressedTextureS3TC == null) {
		  _glExtensionCompressedTextureS3TC = _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' );
		}
		if (_glExtensionCompressedTextureS3TC == null) {
		  _glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
		}

		if ( _glExtensionTextureFloat == null ) {

			print( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

		if ( _glExtensionStandardDerivatives == null ) {

		  print( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( _glExtensionTextureFilterAnisotropic == null ) {

		  print( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

		if ( _glExtensionCompressedTextureS3TC == null ) {

			print( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );

		}
	}

	setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( gl.DEPTH_TEST );
		_gl.depthFunc( gl.LEQUAL );

		_gl.frontFace( gl.CCW );
		_gl.cullFace( gl.BACK );
		_gl.enable( gl.CULL_FACE );

		_gl.enable( gl.BLEND );
		_gl.blendEquation( gl.FUNC_ADD );
		_gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}


}
</pre>
</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../three/Renderer.html">Renderer</a></span></p>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="PRECISION_HIGH">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>PRECISION_HIGH</strong> <a class="anchor-link"
            href="#PRECISION_HIGH"
            title="Permalink to WebGLRenderer.PRECISION_HIGH">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static const String PRECISION_HIGH = 'highp'
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>WebGLRenderer</strong>({<a href="http://api.dartlang.org/dart_html/CanvasElement.html">CanvasElement</a> canvas, <a href="http://api.dartlang.org/dart_core/String.html">String</a> precision: PRECISION_HIGH, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> alpha: true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> premultipliedAlpha: true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> antialias: true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> stencil: true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> preserveDrawingBuffer: false, <a href="http://api.dartlang.org/dart_core/num.html">num</a> clearColorHex: 0x000000, <a href="http://api.dartlang.org/dart_core/num.html">num</a> clearAlpha: 0, <a href="http://api.dartlang.org/dart_core/num.html">num</a> devicePixelRatio}) <a class="anchor-link" href="#"
              title="Permalink to WebGLRenderer.WebGLRenderer">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="../dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="../dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="../dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html">Object</a> </div></div>
<pre class="source">
WebGLRenderer( {	this.canvas,
					this.precision: PRECISION_HIGH,
					this.alpha: true,
			      this.premultipliedAlpha: true,
		        this.antialias: true,
	          this.stencil: true,
					this.preserveDrawingBuffer: false,
					num clearColorHex: 0x000000,
					num clearAlpha: 0,
					num devicePixelRatio} )
		:

		_clearColor = new Color(clearColorHex),
		_clearAlpha = clearAlpha,

			// clearing
			autoClear = true,
			autoClearColor = true,
			autoClearDepth = true,
			autoClearStencil = true,

			// scene graph
			sortObjects = true,
			autoUpdateObjects = true,
			autoUpdateScene = true,

			// physically based shading
			gammaInput = false,
			gammaOutput = false,
			physicallyBasedShading = false,

			// shadow map
			shadowMapEnabled = false,
			shadowMapAutoUpdate = true,
			shadowMapType = PCFShadowMap,
			shadowMapCullFrontFaces = CullFaceFront,
			shadowMapDebug = false,
			shadowMapCascade = false,

			// morphs
			maxMorphTargets = 8,
			maxMorphNormals = 4,

			// flags
			autoScaleCubemaps = true,

			// custom render plugins
			renderPluginsPre = [],
			renderPluginsPost = [],

			info = new WebGLRendererInfo(),

			// internal properties

	_programs = [],
	_programs_counter = 0,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_currentCamera = null,
	_geometryGroupCounter = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = 0,
	_viewportHeight = 0,
	_currentWidth = 0,
	_currentHeight = 0 ,

_enabledAttributes = {},

	// frustum
_frustum = new Frustum(),

// camera matrices cache
_projScreenMatrix = new Matrix4.identity(),
_projScreenMatrixPS = new Matrix4.identity(),

_vector3 = new Vector3.zero(),

// light arrays cache

_direction = new Vector3.zero(),

_lightsNeedUpdate = true

{

 this.devicePixelRatio = (devicePixelRatio != null) ? devicePixelRatio : ( (window.devicePixelRatio != null) ? window.devicePixelRatio : 1);

 _lights = {

	    "ambient": [ 0, 0, 0 ],
	    "directional": { "length": 0, "colors": [], "positions": [] },
	    "point": { "length": 0, "colors": [], "positions": [], "distances": [] },
	    "spot": { "length": 0, "colors": [], "positions": [], "distances": [], "directions": [], "anglesCos": [], "exponents": [] },
	    "hemi": { "length": 0, "skyColors": [], "groundColors": [], "positions": [] }
	  };



 if (canvas == null) {
     canvas = new CanvasElement();
 }

	// initialize

	initGL();

	setDefaultGLState();


	// GPU capabilities
	maxTextures = _gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	maxVertexTextures = _gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	maxTextureSize = _gl.getParameter( gl.MAX_TEXTURE_SIZE );
	maxCubemapSize = _gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	maxAnisotropy = (_glExtensionTextureFilterAnisotropic != null) ? _gl.getParameter( gl.ExtTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	supportsVertexTextures = ( maxVertexTextures &gt; 0 );
	supportsBoneTextures = supportsVertexTextures &amp;&amp; (_glExtensionTextureFloat != null);

	var _compressedTextureFormats = (_glExtensionCompressedTextureS3TC != null) ? _gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS ) : [];

 //

 var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT );
 var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT );
 var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.LOW_FLOAT );

 var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT );
 var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT );
 var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.LOW_FLOAT );

 var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_INT );
 var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_INT );
 var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.LOW_INT );

 var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_INT );
 var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_INT );
 var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.LOW_INT );

 // clamp precision to maximum available

 var highpAvailable = _vertexShaderPrecisionHighpFloat.precision &gt; 0 &amp;&amp; _fragmentShaderPrecisionHighpFloat.precision &gt; 0;
 var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision &gt; 0 &amp;&amp; _fragmentShaderPrecisionMediumpFloat.precision &gt; 0;

 if ( precision == "highp" &amp;&amp; ! highpAvailable ) {

   if ( mediumpAvailable ) {

     precision = "mediump";
     print( "WebGLRenderer: highp not supported, using mediump" );

   } else {

     precision = "lowp";
     print( "WebGLRenderer: highp and mediump not supported, using lowp" );

   }

 }

 if ( precision == "mediump" &amp;&amp; ! mediumpAvailable ) {

   precision = "lowp";
   print( "WebGLRenderer: mediump not supported, using lowp" );

 }

	// default plugins (order is important)

	shadowMapPlugin = new ShadowMapPlugin();
	addPrePlugin( shadowMapPlugin );

	//addPostPlugin( new SpritePlugin() );
	//addPostPlugin( new LensFlarePlugin() );

}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="alpha">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>alpha</strong> <a class="anchor-link"
            href="#alpha"
            title="Permalink to WebGLRenderer.alpha">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool alpha
</pre>
</div>
</div>
<div class="field"><h4 id="antialias">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>antialias</strong> <a class="anchor-link"
            href="#antialias"
            title="Permalink to WebGLRenderer.antialias">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool alpha,
		   premultipliedAlpha,
		   antialias
</pre>
</div>
</div>
<div class="field"><h4 id="autoClear">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoClear</strong> <a class="anchor-link"
            href="#autoClear"
            title="Permalink to WebGLRenderer.autoClear">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool autoClear
</pre>
</div>
</div>
<div class="field"><h4 id="autoClearColor">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoClearColor</strong> <a class="anchor-link"
            href="#autoClearColor"
            title="Permalink to WebGLRenderer.autoClearColor">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool autoClear,
		autoClearColor
</pre>
</div>
</div>
<div class="field"><h4 id="autoClearDepth">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoClearDepth</strong> <a class="anchor-link"
            href="#autoClearDepth"
            title="Permalink to WebGLRenderer.autoClearDepth">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool autoClear,
		autoClearColor,
		autoClearDepth
</pre>
</div>
</div>
<div class="field"><h4 id="autoClearStencil">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoClearStencil</strong> <a class="anchor-link"
            href="#autoClearStencil"
            title="Permalink to WebGLRenderer.autoClearStencil">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool autoClear,
		autoClearColor,
		autoClearDepth,
		autoClearStencil
</pre>
</div>
</div>
<div class="field"><h4 id="autoScaleCubemaps">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoScaleCubemaps</strong> <a class="anchor-link"
            href="#autoScaleCubemaps"
            title="Permalink to WebGLRenderer.autoScaleCubemaps">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool autoScaleCubemaps
</pre>
</div>
</div>
<div class="field"><h4 id="autoUpdateObjects">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoUpdateObjects</strong> <a class="anchor-link"
            href="#autoUpdateObjects"
            title="Permalink to WebGLRenderer.autoUpdateObjects">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool sortObjects,
	autoUpdateObjects
</pre>
</div>
</div>
<div class="field"><h4 id="autoUpdateScene">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoUpdateScene</strong> <a class="anchor-link"
            href="#autoUpdateScene"
            title="Permalink to WebGLRenderer.autoUpdateScene">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool sortObjects,
	autoUpdateObjects,
	autoUpdateScene
</pre>
</div>
</div>
<div class="field"><h4 id="canvas">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_html/CanvasElement.html">CanvasElement</a>         <strong>canvas</strong> <a class="anchor-link"
            href="#canvas"
            title="Permalink to WebGLRenderer.canvas">#</a>
        </h4>
        <div class="doc">
<pre class="source">
CanvasElement canvas
</pre>
</div>
</div>
<div class="field"><h4 id="context">
<button class="show-code">Code</button>
final         <strong>context</strong> <a class="anchor-link"
            href="#context"
            title="Permalink to WebGLRenderer.context">#</a>
        </h4>
        <div class="doc">
<pre class="source">
get context =&gt; _gl;
</pre>
</div>
</div>
<div class="field"><h4 id="devicePixelRatio">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/double.html">double</a>         <strong>devicePixelRatio</strong> <a class="anchor-link"
            href="#devicePixelRatio"
            title="Permalink to WebGLRenderer.devicePixelRatio">#</a>
        </h4>
        <div class="doc">
<pre class="source">
double devicePixelRatio
</pre>
</div>
</div>
<div class="field"><h4 id="domElement">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_html/Element.html">Element</a>         <strong>domElement</strong> <a class="anchor-link"
            href="#domElement"
            title="Permalink to WebGLRenderer.domElement">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Element get domElement =&gt; canvas;
</pre>
</div>
</div>
<div class="field"><h4 id="gammaInput">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>gammaInput</strong> <a class="anchor-link"
            href="#gammaInput"
            title="Permalink to WebGLRenderer.gammaInput">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool gammaInput
</pre>
</div>
</div>
<div class="field"><h4 id="gammaOutput">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>gammaOutput</strong> <a class="anchor-link"
            href="#gammaOutput"
            title="Permalink to WebGLRenderer.gammaOutput">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool gammaInput,
	gammaOutput
</pre>
</div>
</div>
<div class="field"><h4 id="info">
<button class="show-code">Code</button>
<a href="../three/WebGLRendererInfo.html">WebGLRendererInfo</a>         <strong>info</strong> <a class="anchor-link"
            href="#info"
            title="Permalink to WebGLRenderer.info">#</a>
        </h4>
        <div class="doc">
<pre class="source">
WebGLRendererInfo info
</pre>
</div>
</div>
<div class="field"><h4 id="maxAnisotropy">
<button class="show-code">Code</button>
var         <strong>maxAnisotropy</strong> <a class="anchor-link"
            href="#maxAnisotropy"
            title="Permalink to WebGLRenderer.maxAnisotropy">#</a>
        </h4>
        <div class="doc">
<pre class="source">
var maxAnisotropy
</pre>
</div>
</div>
<div class="field"><h4 id="maxCubemapSize">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>maxCubemapSize</strong> <a class="anchor-link"
            href="#maxCubemapSize"
            title="Permalink to WebGLRenderer.maxCubemapSize">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num maxTextures, maxVertexTextures, maxTextureSize, maxCubemapSize
</pre>
</div>
</div>
<div class="field"><h4 id="maxMorphNormals">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>maxMorphNormals</strong> <a class="anchor-link"
            href="#maxMorphNormals"
            title="Permalink to WebGLRenderer.maxMorphNormals">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int maxMorphTargets,
		maxMorphNormals
</pre>
</div>
</div>
<div class="field"><h4 id="maxMorphTargets">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>maxMorphTargets</strong> <a class="anchor-link"
            href="#maxMorphTargets"
            title="Permalink to WebGLRenderer.maxMorphTargets">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int maxMorphTargets
</pre>
</div>
</div>
<div class="field"><h4 id="maxTextures">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>maxTextures</strong> <a class="anchor-link"
            href="#maxTextures"
            title="Permalink to WebGLRenderer.maxTextures">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num maxTextures
</pre>
</div>
</div>
<div class="field"><h4 id="maxTextureSize">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>maxTextureSize</strong> <a class="anchor-link"
            href="#maxTextureSize"
            title="Permalink to WebGLRenderer.maxTextureSize">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num maxTextures, maxVertexTextures, maxTextureSize
</pre>
</div>
</div>
<div class="field"><h4 id="maxVertexTextures">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>maxVertexTextures</strong> <a class="anchor-link"
            href="#maxVertexTextures"
            title="Permalink to WebGLRenderer.maxVertexTextures">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num maxTextures, maxVertexTextures
</pre>
</div>
</div>
<div class="field"><h4 id="physicallyBasedShading">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>physicallyBasedShading</strong> <a class="anchor-link"
            href="#physicallyBasedShading"
            title="Permalink to WebGLRenderer.physicallyBasedShading">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool gammaInput,
	gammaOutput,
	physicallyBasedShading
</pre>
</div>
</div>
<div class="field"><h4 id="precision">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>precision</strong> <a class="anchor-link"
            href="#precision"
            title="Permalink to WebGLRenderer.precision">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String precision
</pre>
</div>
</div>
<div class="field"><h4 id="premultipliedAlpha">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>premultipliedAlpha</strong> <a class="anchor-link"
            href="#premultipliedAlpha"
            title="Permalink to WebGLRenderer.premultipliedAlpha">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool alpha,
		   premultipliedAlpha
</pre>
</div>
</div>
<div class="field"><h4 id="preserveDrawingBuffer">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>preserveDrawingBuffer</strong> <a class="anchor-link"
            href="#preserveDrawingBuffer"
            title="Permalink to WebGLRenderer.preserveDrawingBuffer">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool alpha,
		   premultipliedAlpha,
		   antialias,
		   stencil,
		   preserveDrawingBuffer
</pre>
</div>
</div>
<div class="field"><h4 id="renderPluginsPost">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html">List</a>         <strong>renderPluginsPost</strong> <a class="anchor-link"
            href="#renderPluginsPost"
            title="Permalink to WebGLRenderer.renderPluginsPost">#</a>
        </h4>
        <div class="doc">
<pre class="source">
List renderPluginsPre,
		renderPluginsPost
</pre>
</div>
</div>
<div class="field"><h4 id="renderPluginsPre">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html">List</a>         <strong>renderPluginsPre</strong> <a class="anchor-link"
            href="#renderPluginsPre"
            title="Permalink to WebGLRenderer.renderPluginsPre">#</a>
        </h4>
        <div class="doc">
<pre class="source">
List renderPluginsPre
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapAutoUpdate">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapAutoUpdate</strong> <a class="anchor-link"
            href="#shadowMapAutoUpdate"
            title="Permalink to WebGLRenderer.shadowMapAutoUpdate">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapCascade">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapCascade</strong> <a class="anchor-link"
            href="#shadowMapCascade"
            title="Permalink to WebGLRenderer.shadowMapCascade">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapDebug,
	shadowMapCascade
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapCullFrontFaces">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>shadowMapCullFrontFaces</strong> <a class="anchor-link"
            href="#shadowMapCullFrontFaces"
            title="Permalink to WebGLRenderer.shadowMapCullFrontFaces">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int shadowMapType,
	shadowMapCullFrontFaces
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapDebug">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapDebug</strong> <a class="anchor-link"
            href="#shadowMapDebug"
            title="Permalink to WebGLRenderer.shadowMapDebug">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapDebug
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapEnabled">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapEnabled</strong> <a class="anchor-link"
            href="#shadowMapEnabled"
            title="Permalink to WebGLRenderer.shadowMapEnabled">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool shadowMapEnabled
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapPlugin">
<button class="show-code">Code</button>
var         <strong>shadowMapPlugin</strong> <a class="anchor-link"
            href="#shadowMapPlugin"
            title="Permalink to WebGLRenderer.shadowMapPlugin">#</a>
        </h4>
        <div class="doc">
<pre class="source">
var shadowMapPlugin
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapType">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>shadowMapType</strong> <a class="anchor-link"
            href="#shadowMapType"
            title="Permalink to WebGLRenderer.shadowMapType">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int shadowMapType
</pre>
</div>
</div>
<div class="field"><h4 id="sortObjects">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>sortObjects</strong> <a class="anchor-link"
            href="#sortObjects"
            title="Permalink to WebGLRenderer.sortObjects">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool sortObjects
</pre>
</div>
</div>
<div class="field"><h4 id="stencil">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>stencil</strong> <a class="anchor-link"
            href="#stencil"
            title="Permalink to WebGLRenderer.stencil">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool alpha,
		   premultipliedAlpha,
		   antialias,
		   stencil
</pre>
</div>
</div>
<div class="field"><h4 id="supportsBoneTextures">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>supportsBoneTextures</strong> <a class="anchor-link"
            href="#supportsBoneTextures"
            title="Permalink to WebGLRenderer.supportsBoneTextures">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool supportsVertexTextures,
	   supportsBoneTextures
</pre>
</div>
</div>
<div class="field"><h4 id="supportsVertexTextures">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>supportsVertexTextures</strong> <a class="anchor-link"
            href="#supportsVertexTextures"
            title="Permalink to WebGLRenderer.supportsVertexTextures">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool supportsVertexTextures
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="addBuffer">
<button class="show-code">Code</button>
dynamic <strong>addBuffer</strong>(objlist, <a href="../three/WebGLGeometry.html">WebGLGeometry</a> buffer, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#addBuffer"
              title="Permalink to WebGLRenderer.addBuffer">#</a></h4>
<div class="doc">
<pre class="source">
addBuffer ( objlist, WebGLGeometry buffer, WebGLObject object ) {

	  var o = new WebGLObject._internal(object.object, null, null, buffer, object.render, object.z);
		objlist.add(o);

	}
</pre>
</div>
</div>
<div class="method"><h4 id="addBufferImmediate">
<button class="show-code">Code</button>
dynamic <strong>addBufferImmediate</strong>(objlist, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#addBufferImmediate"
              title="Permalink to WebGLRenderer.addBufferImmediate">#</a></h4>
<div class="doc">
<pre class="source">
addBufferImmediate ( objlist, WebGLObject object ) {

	  var o = new WebGLObject._internal(object.object, null, null, null, object.render, object.z);

		objlist.add(o);

	}
</pre>
</div>
</div>
<div class="method"><h4 id="addLineNumbers">
<button class="show-code">Code</button>
dynamic <strong>addLineNumbers</strong>(string) <a class="anchor-link" href="#addLineNumbers"
              title="Permalink to WebGLRenderer.addLineNumbers">#</a></h4>
<div class="doc">
<pre class="source">
addLineNumbers ( string ) {

		var chunks = string.split( "\n" );

		var il = chunks.length;
		for ( var i = 0; i &lt; il; i ++ ) {

			// Chrome reports shader errors on lines
			// starting counting from 1

			chunks[ i ] = "${i + 1}:${chunks[i]}";

		}

		return chunks.join( "\n" );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="addObject">
<button class="show-code">Code</button>
dynamic <strong>addObject</strong>(<a href="../three/Object3D.html">Object3D</a> object, <a href="../three/Scene.html">Scene</a> scene) <a class="anchor-link" href="#addObject"
              title="Permalink to WebGLRenderer.addObject">#</a></h4>
<div class="doc">
<pre class="source">
addObject ( Object3D object, Scene scene ) {

	  // nelsonsilva - wrapping in our own decorator
  WebGLObject webglobject = new WebGLObject(object);

  // ATTENTION - All type checks must be done with object and object.geometry
  WebGLGeometry geometry = webglobject.webglgeometry;

  var material;

		if (  !webglobject.__webglInit ) {

		  webglobject.__webglInit = true;

		  webglobject._modelViewMatrix = new Matrix4.identity();
		  webglobject._normalMatrix = new Matrix3.zero();

		  if ( geometry != null &amp;&amp; geometry.__webglInit == null ) {

				geometry.__webglInit = true;
				//geometry.addEventListener( 'dispose', onGeometryDispose );

			}

			if ( object is Mesh ) {

				material = object.material;

				if ( (object.geometry is Geometry)  &amp;&amp; (object.geometry is! BufferGeometry) ) {

					if ( geometry.geometryGroups == null) {

						sortFacesByMaterial( geometry, material );

					}

					// create separate VBOs per geometry chunk

					geometry.geometryGroups.forEach((k, geometryGroup) {

						// initialise VBO on the first access

						if ( geometryGroup.__webglVertexBuffer == null ) {

							createMeshBuffers( geometryGroup );
							initMeshBuffers( geometryGroup, webglobject );

							geometry.verticesNeedUpdate = true;
							geometry.morphTargetsNeedUpdate = true;
							geometry.elementsNeedUpdate = true;
							geometry.uvsNeedUpdate = true;
							geometry.normalsNeedUpdate = true;
							geometry.tangentsNeedUpdate = true;
							geometry.colorsNeedUpdate = true;

						}

					});

				} else if ( object.geometry is BufferGeometry ) {

					initDirectBuffers( object.geometry as BufferGeometry);

				}

			} else if ( object is Ribbon ) {

				if( geometry.__webglVertexBuffer == null) {

					createRibbonBuffers( geometry );
					initRibbonBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.normalsNeedUpdate = true;

				}

			} else if ( object is Line ) {

				if( geometry.__webglVertexBuffer == null ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, webglobject );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object is ParticleSystem ) {

				if ( geometry.__webglVertexBuffer == null ) {

					if ( (object.geometry is Geometry)  &amp;&amp; (object.geometry is! BufferGeometry) ) {
						createParticleBuffers( geometry );
						initParticleBuffers( geometry, webglobject );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					} else if ( object.geometry is BufferGeometry ) {

						initDirectBuffers( object.geometry );

					}

				}

			}
		}

		if (!webglobject.__webglActive) {

			if ( object is Mesh ) {

				if ( object.geometry is BufferGeometry ) {

					addBuffer( scene["__webglObjects"], geometry, webglobject );

				} else {

				  geometry.geometryGroups.forEach( (k, geometryGroup) {

						addBuffer( scene["__webglObjects"], geometryGroup, webglobject );

					});

				}

			} else if ( object is Ribbon ||
						object is Line ||
						object is ParticleSystem ) {

				addBuffer( scene["__webglObjects"],  geometry, webglobject );

			} else if ( object is ImmediateRenderObject || (object["immediateRenderCallback"] != null) ) {

				addBufferImmediate( scene["__webglObjectsImmediate"], webglobject );

			} else if ( object is Sprite ) {

				scene["__webglSprites"].add( object );

			} else if ( object is LensFlare ) {

				scene["__webglFlares"].add( object );

			}

			webglobject.__webglActive = true;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="addPostPlugin">
<button class="show-code">Code</button>
dynamic <strong>addPostPlugin</strong>(plugin) <a class="anchor-link" href="#addPostPlugin"
              title="Permalink to WebGLRenderer.addPostPlugin">#</a></h4>
<div class="doc">
<pre class="source">
addPostPlugin( plugin ) {
		plugin.init( this );
		renderPluginsPost.add( plugin );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="addPrePlugin">
<button class="show-code">Code</button>
dynamic <strong>addPrePlugin</strong>(plugin) <a class="anchor-link" href="#addPrePlugin"
              title="Permalink to WebGLRenderer.addPrePlugin">#</a></h4>
<div class="doc">
<pre class="source">
addPrePlugin( plugin ) {
		plugin.init( this );
		renderPluginsPre.add( plugin );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="allocateBones">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a> <strong>allocateBones</strong>(<a href="../three/Object3D.html">Object3D</a> object) <a class="anchor-link" href="#allocateBones"
              title="Permalink to WebGLRenderer.allocateBones">#</a></h4>
<div class="doc">
<pre class="source">
int allocateBones ( Object3D object ) {

		if ( supportsBoneTextures &amp;&amp; (object != null) &amp;&amp; object is SkinnedMesh &amp;&amp; object.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			// 	- leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			int nVertexUniforms = _gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			int nVertexMatrices = ( ( nVertexUniforms - 20 ) / 4 ).floor().toInt();

			var maxBones = nVertexMatrices;

			if ( object != null &amp;&amp; object is SkinnedMesh ) {

				maxBones = Math.min( object.bones.length, maxBones );

				if ( maxBones &lt; object.bones.length ) {

					print( "WebGLRenderer: too many bones - ${object.bones.length} , this GPU supports just $maxBones  (try OpenGL instead of ANGLE)" );

				}

			}

			return maxBones;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="allocateLights">
<button class="show-code">Code</button>
dynamic <strong>allocateLights</strong>(<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../three/Light.html">Light</a>&gt; lights) <a class="anchor-link" href="#allocateLights"
              title="Permalink to WebGLRenderer.allocateLights">#</a></h4>
<div class="doc">
<pre class="source">
allocateLights ( List&lt;Light&gt; lights ) {

		var l, ll, light, dirLights, pointLights, spotLights, hemiLights;

		dirLights = pointLights = spotLights = hemiLights = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l ++ ) {

			light = lights[ l ];

			if ( (( light is DirectionalLight ) || ( light is SpotLight )) &amp;&amp;
			    (light as dynamic).onlyShadow ) { continue;
			}

			if ( light is DirectionalLight ) dirLights ++;
			if ( light is PointLight ) pointLights ++;
			if ( light is SpotLight ) spotLights ++;
			if ( light is HemisphereLight ) hemiLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi':  hemiLights};

	}
</pre>
</div>
</div>
<div class="method"><h4 id="allocateShadows">
<button class="show-code">Code</button>
dynamic <strong>allocateShadows</strong>(lights) <a class="anchor-link" href="#allocateShadows"
              title="Permalink to WebGLRenderer.allocateShadows">#</a></h4>
<div class="doc">
<pre class="source">
allocateShadows ( lights ) {

		var l, ll, light, maxShadows = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l++ ) {

			light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light is SpotLight ) maxShadows ++;
			if ( light is DirectionalLight &amp;&amp; ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="areCustomAttributesDirty">
<button class="show-code">Code</button>
dynamic <strong>areCustomAttributesDirty</strong>(material) <a class="anchor-link" href="#areCustomAttributesDirty"
              title="Permalink to WebGLRenderer.areCustomAttributesDirty">#</a></h4>
<div class="doc">
<pre class="source">
areCustomAttributesDirty( material ) =&gt; material.attributes.values.any((a) =&gt; a.needsUpdate);
</pre>
</div>
</div>
<div class="method"><h4 id="bufferGuessNormalType">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a> <strong>bufferGuessNormalType</strong>(<a href="../three/WebGLMaterial.html">WebGLMaterial</a> material) <a class="anchor-link" href="#bufferGuessNormalType"
              title="Permalink to WebGLRenderer.bufferGuessNormalType">#</a></h4>
<div class="doc">
<pre class="source">
int bufferGuessNormalType ( WebGLMaterial material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( !material.needsNormals  ) {
			return NoShading;
		}

		if ( material.needsSmoothNormals ) {

			return SmoothShading;

		} else {

			return FlatShading;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="bufferGuessUVType">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>bufferGuessUVType</strong>(material) <a class="anchor-link" href="#bufferGuessUVType"
              title="Permalink to WebGLRenderer.bufferGuessUVType">#</a></h4>
<div class="doc">
<pre class="source">
bool bufferGuessUVType ( material ) {

		// material must use some texture to require uvs

		if ((material.map != null) ||
		    (material.lightMap != null) ||
		    (material.bumpMap != null) ||
		    (material.normalMap != null) ||
		    (material.specularMap != null) ||
		    (material.isShaderMaterial)) {

			return true;

		}

		return false;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="bufferGuessVertexColorType">
<button class="show-code">Code</button>
dynamic <strong>bufferGuessVertexColorType</strong>(material) <a class="anchor-link" href="#bufferGuessVertexColorType"
              title="Permalink to WebGLRenderer.bufferGuessVertexColorType">#</a></h4>
<div class="doc">
<pre class="source">
bufferGuessVertexColorType ( material ) {

		if ( ((material.vertexColors is bool) &amp;&amp; material.vertexColors) ||
		     ((material.vertexColors is int) &amp;&amp; (material.vertexColors != NoColors))) {

			return material.vertexColors;

		}

		return false;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="buildProgram">
<button class="show-code">Code</button>
<a href="../three/Program.html">Program</a> <strong>buildProgram</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> shaderID, <a href="http://api.dartlang.org/dart_core/String.html">String</a> fragmentShader, <a href="http://api.dartlang.org/dart_core/String.html">String</a> vertexShader, uniforms, attributes, defines, {<a href="http://api.dartlang.org/dart_core/int.html">int</a> maxDirLights: 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxPointLights: 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxSpotLights: 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxHemiLights: 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxShadows: 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxBones: 0, <a href="../three/Texture.html">Texture</a> map: null, <a href="../three/Texture.html">Texture</a> envMap: null, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> lightMap: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> bumpMap: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> normalMap: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> specularMap: false, vertexColors: NoColors, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> skinning: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> useVertexTexture: false, <a href="http://api.dartlang.org/dart_core/num.html">num</a> boneTextureWidth: null, <a href="http://api.dartlang.org/dart_core/num.html">num</a> boneTextureHeight: null, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> morphTargets: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> morphNormals: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> perPixel: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> wrapAround: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> doubleSided: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> flipSided: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> shadowMapEnabled: false, <a href="http://api.dartlang.org/dart_core/int.html">int</a> shadowMapType, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> shadowMapDebug: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> shadowMapCascade: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> sizeAttenuation: false, <a href="../three/Fog.html">Fog</a> fog: null, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> useFog: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> fogExp: false, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxMorphTargets: 8, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxMorphNormals: 4, <a href="http://api.dartlang.org/dart_core/num.html">num</a> alphaTest: 0, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> metal: false}) <a class="anchor-link" href="#buildProgram"
              title="Permalink to WebGLRenderer.buildProgram">#</a></h4>
<div class="doc">
<pre class="source">
Program buildProgram( String shaderID, String fragmentShader, String vertexShader, uniforms, attributes, defines,
	                      {	int maxDirLights: 0,
					int maxPointLights: 0,
					int maxSpotLights: 0,
					int maxHemiLights: 0,
					int maxShadows: 0,
					int maxBones: 0,
					Texture map: null,
					Texture envMap: null,
					bool lightMap: false,
					bool bumpMap: false,
					bool normalMap: false,
					bool specularMap: false,
					var vertexColors: NoColors,
					bool skinning: false,
					bool useVertexTexture: false,
					num boneTextureWidth: null,
					num boneTextureHeight: null,
					bool morphTargets: false,
					bool morphNormals: false,
					bool perPixel: false,
					bool wrapAround: false,
					bool doubleSided: false,
					bool flipSided: false,
					bool shadowMapEnabled: false,
					int shadowMapType,
					bool shadowMapDebug: false,
					bool shadowMapCascade: false,
					bool sizeAttenuation: false,
					Fog fog: null,
		      bool useFog: false,
		      bool fogExp: false,
		      int maxMorphTargets: 8,
		      int maxMorphNormals: 4,
		      num alphaTest: 0,
		      bool metal: false} ) {

		var p, pl, glprogram, code;
		var chunks = [];

		// Generate code

		if ( shaderID != null ) {

			chunks.add( shaderID );

		} else {

			chunks.add( fragmentShader );
			chunks.add( vertexShader );

		}

		defines.forEach((d, define) {
			chunks.add( d );
			chunks.add( define );
		});

		code =  "${chunks.join()}"
		        "maxDirLights$maxDirLights"
		        "maxPointLights$maxPointLights"
		        "maxSpotLights$maxSpotLights"
		        "maxHemiLights$maxHemiLights"
		        "maxShadows$maxShadows"
		        "maxBones$maxBones"
		        "map$map"
		        "envMap$envMap"
		        "lightMap$lightMap"
		        "bumpMap$bumpMap"
		        "normalMap$normalMap"
		        "specularMap$specularMap"
		        "vertexColors$vertexColors"
		        "fog$fog"
	          "useFog$useFog"
	          "fogExp$fogExp"
		        "skinning$skinning"
		        "useVertexTexture$useVertexTexture"
		        "boneTextureWidth$boneTextureWidth"
		        "boneTextureHeight$boneTextureHeight"
		        "morphTargets$morphTargets"
          "morphNormals$morphNormals"
          "perPixel$perPixel"
          "wrapAround$wrapAround"
		        "doubleSided$doubleSided"
		        "flipSided$flipSided"
          "shadowMapEnabled$shadowMapEnabled"
          "shadowMapType$shadowMapType"
          "shadowMapDebug$shadowMapDebug"
		        "shadowMapCascade$shadowMapCascade"
          "sizeAttenuation$sizeAttenuation";


		// Check if code has been already compiled

		pl = _programs.length;
		for ( p = 0; p &lt; pl; p ++ ) {

			Program program = _programs[ p ];

			// TODO - why do we need identical here ?!
    if ( program.code == code ) {

				//print( "Code already compiled: $program$code" );

			  program.usedTimes ++;

				return program;

			}

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( shadowMapType == PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( shadowMapType == PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		//print( "building new program " );

		//

		var customDefines = generateDefines( defines );

		glprogram = _gl.createProgram();

		var prefix_vertex = [

			"precision $precision float;",

			customDefines,

			supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			gammaInput ? "#define GAMMA_INPUT" : "",
			gammaOutput ? "#define GAMMA_OUTPUT" : "",
			physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			"#define MAX_DIR_LIGHTS $maxDirLights",
			"#define MAX_POINT_LIGHTS $maxPointLights",
			"#define MAX_SPOT_LIGHTS $maxSpotLights",
			"#define MAX_HEMI_LIGHTS $maxHemiLights",

			"#define MAX_SHADOWS $maxShadows",

			"#define MAX_BONES $maxBones",

			(map != null) ? "#define USE_MAP" : "",
			(envMap != null) ? "#define USE_ENVMAP" : "",
			(lightMap != null) ? "#define USE_LIGHTMAP" : "",
			(bumpMap != null) ? "#define USE_BUMPMAP" : "",
			(normalMap != null) ? "#define USE_NORMALMAP" : "",
			(specularMap != null) ? "#define USE_SPECULARMAP" : "",
			(((vertexColors is bool) &amp;&amp; vertexColors) || ((vertexColors is int) &amp;&amp; (vertexColors != NoColors))) ? "#define USE_COLOR" : "",

			skinning ? "#define USE_SKINNING" : "",
			useVertexTexture ? "#define BONE_TEXTURE" : "",
			(boneTextureWidth != null) ? "#define N_BONE_PIXEL_X ${boneTextureWidth.toStringAsFixed(1)}" : "",
			(boneTextureHeight != null) ? "#define N_BONE_PIXEL_Y ${boneTextureHeight.toStringAsFixed( 1 )}" : "",

			morphTargets ? "#define USE_MORPHTARGETS" : "",
			morphNormals ? "#define USE_MORPHNORMALS" : "",
			perPixel ? "#define PHONG_PER_PIXEL" : "",
			wrapAround ? "#define WRAP_AROUND" : "",
			doubleSided ? "#define DOUBLE_SIDED" : "",
			flipSided ? "#define FLIP_SIDED" : "",

			shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			shadowMapEnabled ? "#define $shadowMapTypeDefine" : "",
			shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",

				"#ifdef USE_MORPHNORMALS",

					"attribute vec3 morphNormal0;",
					"attribute vec3 morphNormal1;",
					"attribute vec3 morphNormal2;",
					"attribute vec3 morphNormal3;",

				"#else",

					"attribute vec3 morphTarget4;",
					"attribute vec3 morphTarget5;",
					"attribute vec3 morphTarget6;",
					"attribute vec3 morphTarget7;",

				"#endif",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		].join("\n");

		var prefix_fragment = [

			"precision $precision float;",

			( bumpMap != null || normalMap != null ) ? "#extension GL_OES_standard_derivatives : enable" : "",

			customDefines,

			(bumpMap != null) ? "#extension GL_OES_standard_derivatives : enable" : "",

			"#define MAX_DIR_LIGHTS $maxDirLights",
			"#define MAX_POINT_LIGHTS $maxPointLights",
			"#define MAX_SPOT_LIGHTS $maxSpotLights",
			"#define MAX_HEMI_LIGHTS $maxHemiLights",

			"#define MAX_SHADOWS $maxShadows",

			(alphaTest != 0) ? "#define ALPHATEST $alphaTest": "",

			gammaInput ? "#define GAMMA_INPUT" : "",
			gammaOutput ? "#define GAMMA_OUTPUT" : "",
			physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			( useFog &amp;&amp; (fog != null) ) ? "#define USE_FOG" : "",
			( useFog &amp;&amp; (fog is FogExp2) ) ? "#define FOG_EXP2" : "",

			(map != null) ? "#define USE_MAP" : "",
			(envMap != null) ? "#define USE_ENVMAP" : "",
			(lightMap != null) ? "#define USE_LIGHTMAP" : "",
			(bumpMap != null) ? "#define USE_BUMPMAP" : "",
			(normalMap != null) ? "#define USE_NORMALMAP" : "",
			(specularMap != null) ? "#define USE_SPECULARMAP" : "",
			(((vertexColors is bool) &amp;&amp; vertexColors) || ((vertexColors is int) &amp;&amp; (vertexColors != NoColors))) ? "#define USE_COLOR" : "",

			metal ? "#define METAL" : "",
			perPixel ? "#define PHONG_PER_PIXEL" : "",
			wrapAround ? "#define WRAP_AROUND" : "",
			doubleSided ? "#define DOUBLE_SIDED" : "",
			flipSided ? "#define FLIP_SIDED" : "",

			shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			shadowMapEnabled ? "#define $shadowMapTypeDefine" : "",
			shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		].join("\n");

		var glFragmentShader = getShader( "fragment", "$prefix_fragment$fragmentShader" );
		var glVertexShader = getShader( "vertex", "$prefix_vertex$vertexShader" );

		_gl.attachShader( glprogram, glVertexShader );
		_gl.attachShader( glprogram, glFragmentShader );

		_gl.linkProgram( glprogram );

		if ( !_gl.getProgramParameter( glprogram, gl.LINK_STATUS ) ) {

		  var status = _gl.getProgramParameter( glprogram, gl.VALIDATE_STATUS );
		  var error = _gl.getError();
			print( "Could not initialise shader\nVALIDATE_STATUS: $status, gl error [$error]" );

		}

		// clean up

		_gl.deleteShader( glFragmentShader );
		_gl.deleteShader( glVertexShader );

		//print( prefix_fragment + fragmentShader );
		//print( prefix_vertex + vertexShader );

		//program.uniforms = {};
		//program.attributes = {};

		var program = new Program( _programs_counter++,  glprogram, code, usedTimes: 1 );

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'morphTargetInfluences'

		];

		if ( useVertexTexture ) {

			identifiers.add( 'boneTexture' );

		} else {

			identifiers.add( 'boneGlobalMatrices' );

		}

		uniforms.forEach((u, _) =&gt; identifiers.add( u ));

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( i = 0; i &lt; maxMorphTargets; i ++ ) {

			identifiers.add( "morphTarget$i" );

		}

		for ( i = 0; i &lt; maxMorphNormals; i ++ ) {

			identifiers.add( "morphNormal$i" );

		}

		if (attributes != null) {
		  attributes.forEach((a, _) =&gt; identifiers.add( a ));
		}

		cacheAttributeLocations( program, identifiers );

		_programs.add( program );

		info.memory.programs = _programs.length;

		return program;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="cacheAttributeLocations">
<button class="show-code">Code</button>
dynamic <strong>cacheAttributeLocations</strong>(program, identifiers) <a class="anchor-link" href="#cacheAttributeLocations"
              title="Permalink to WebGLRenderer.cacheAttributeLocations">#</a></h4>
<div class="doc">
<pre class="source">
cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		l = identifiers.length;
		for( i = 0; i &lt; l; i ++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program.glProgram, id );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="cacheUniformLocations">
<button class="show-code">Code</button>
dynamic <strong>cacheUniformLocations</strong>(program, identifiers) <a class="anchor-link" href="#cacheUniformLocations"
              title="Permalink to WebGLRenderer.cacheUniformLocations">#</a></h4>
<div class="doc">
<pre class="source">
cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		l = identifiers.length;
		for( i = 0; i &lt; l; i ++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program.glProgram, id );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="clampToMaxSize">
<button class="show-code">Code</button>
dynamic <strong>clampToMaxSize</strong>(image, maxSize) <a class="anchor-link" href="#clampToMaxSize"
              title="Permalink to WebGLRenderer.clampToMaxSize">#</a></h4>
<div class="doc">
<pre class="source">
clampToMaxSize ( image, maxSize ) {

		if ( image.width &lt;= maxSize &amp;&amp; image.height &lt;= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = ( image.width * maxSize / maxDimension ).floor();
		var newHeight = ( image.height * maxSize / maxDimension ).floor();

		var canvas = new CanvasElement();
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.context2D;
		ctx.drawImageScaledFromSource( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="clear">
<button class="show-code">Code</button>
dynamic <strong>clear</strong>([<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> color = true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> depth = true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> stencil = true]) <a class="anchor-link" href="#clear"
              title="Permalink to WebGLRenderer.clear">#</a></h4>
<div class="doc">
<pre class="source">
clear( [ bool color = true, bool depth = true, bool stencil = true] ) {

		var bits = 0;

		if ( color ) bits |= gl.COLOR_BUFFER_BIT;
		if ( depth ) bits |= gl.DEPTH_BUFFER_BIT;
		if ( stencil ) bits |= gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="clearCustomAttributes">
<button class="show-code">Code</button>
dynamic <strong>clearCustomAttributes</strong>(material) <a class="anchor-link" href="#clearCustomAttributes"
              title="Permalink to WebGLRenderer.clearCustomAttributes">#</a></h4>
<div class="doc">
<pre class="source">
clearCustomAttributes( material ) =&gt; material.attributes.forEach((_, a) { a.needsUpdate = false; });
</pre>
</div>
</div>
<div class="method"><h4 id="clearTarget">
<button class="show-code">Code</button>
dynamic <strong>clearTarget</strong>(renderTarget, color, depth, stencil) <a class="anchor-link" href="#clearTarget"
              title="Permalink to WebGLRenderer.clearTarget">#</a></h4>
<div class="doc">
<pre class="source">
clearTarget( renderTarget, color, depth, stencil ) {
		setRenderTarget( renderTarget );
		clear( color, depth, stencil );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="createLineBuffers">
<button class="show-code">Code</button>
dynamic <strong>createLineBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#createLineBuffers"
              title="Permalink to WebGLRenderer.createLineBuffers">#</a></h4>
<div class="doc">
<pre class="source">
createLineBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		info.memory.geometries ++;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="createMeshBuffers">
<button class="show-code">Code</button>
dynamic <strong>createMeshBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometryGroup) <a class="anchor-link" href="#createMeshBuffers"
              title="Permalink to WebGLRenderer.createMeshBuffers">#</a></h4>
<div class="doc">
<pre class="source">
createMeshBuffers ( WebGLGeometry geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets != null ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			 ml = geometryGroup.numMorphTargets;

			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.add( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals != null ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			ml = geometryGroup.numMorphNormals;

			for ( m = 0; m &lt; ml; m ++ ) {
				geometryGroup.__webglMorphNormalsBuffers.add( _gl.createBuffer() );

			}

		}

		info.memory.geometries++;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="createParticleBuffers">
<button class="show-code">Code</button>
dynamic <strong>createParticleBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#createParticleBuffers"
              title="Permalink to WebGLRenderer.createParticleBuffers">#</a></h4>
<div class="doc">
<pre class="source">
createParticleBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		info.memory.geometries++;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="createRibbonBuffers">
<button class="show-code">Code</button>
dynamic <strong>createRibbonBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#createRibbonBuffers"
              title="Permalink to WebGLRenderer.createRibbonBuffers">#</a></h4>
<div class="doc">
<pre class="source">
createRibbonBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglNormalBuffer = _gl.createBuffer();

		info.memory.geometries ++;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deallocateGeometry">
<button class="show-code">Code</button>
dynamic <strong>deallocateGeometry</strong>(geometry) <a class="anchor-link" href="#deallocateGeometry"
              title="Permalink to WebGLRenderer.deallocateGeometry">#</a></h4>
<div class="doc">
<pre class="source">
deallocateGeometry( geometry ) {

		geometry.__webglInit = null;

		if ( geometry.__webglVertexBuffer != null ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer != null  ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer != null  ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer != null  ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer != null  ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer != null  ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer != null  ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer != null  ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer != null  ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer != null  ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer != null  ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );

		// geometry groups

		if ( geometry.geometryGroups != null  ) {

			for ( var g in geometry.geometryGroups ) {

				var geometryGroup = geometry.geometryGroups[ g ];

				if ( geometryGroup.numMorphTargets != null  ) {

					for ( var m = 0, ml = geometryGroup.numMorphTargets; m &lt; ml; m ++ ) {

						_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

					}

				}

				if ( geometryGroup.numMorphNormals != null  ) {

					for ( var m = 0, ml = geometryGroup.numMorphNormals; m &lt; ml; m ++ ) {

						_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

					}

				}

				deleteCustomAttributesBuffers( geometryGroup );

			}

		}

		deleteCustomAttributesBuffers( geometry );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deallocateMaterial">
<button class="show-code">Code</button>
dynamic <strong>deallocateMaterial</strong>(material) <a class="anchor-link" href="#deallocateMaterial"
              title="Permalink to WebGLRenderer.deallocateMaterial">#</a></h4>
<div class="doc">
<pre class="source">
deallocateMaterial( material ) {

		var program = material.program;

		if ( program == null ) return;

		material.program = null;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il;
		Program programInfo;
		var deleteProgram = false;

		for ( var i = 0, il = _programs.length; i &lt; il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.glProgram == program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes == 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram == true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( var i = 0, il = _programs.length; i &lt; il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.glProgram != program ) {

					newPrograms.add( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			info.memory.programs --;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deallocateRenderTarget">
<button class="show-code">Code</button>
dynamic <strong>deallocateRenderTarget</strong>(renderTarget) <a class="anchor-link" href="#deallocateRenderTarget"
              title="Permalink to WebGLRenderer.deallocateRenderTarget">#</a></h4>
<div class="doc">
<pre class="source">
deallocateRenderTarget( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		if ( renderTarget is WebGLRenderTargetCube ) {

			for ( var i = 0; i &lt; 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deallocateTexture">
<button class="show-code">Code</button>
dynamic <strong>deallocateTexture</strong>(texture) <a class="anchor-link" href="#deallocateTexture"
              title="Permalink to WebGLRenderer.deallocateTexture">#</a></h4>
<div class="doc">
<pre class="source">
deallocateTexture( texture ) {

		if ( texture.image &amp;&amp; texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture["__webglInit"] ) return;

			texture["__webglInit"] = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deleteCustomAttributesBuffers">
<button class="show-code">Code</button>
dynamic <strong>deleteCustomAttributesBuffers</strong>(geometry) <a class="anchor-link" href="#deleteCustomAttributesBuffers"
              title="Permalink to WebGLRenderer.deleteCustomAttributesBuffers">#</a></h4>
<div class="doc">
<pre class="source">
deleteCustomAttributesBuffers( geometry ) {

		if ( geometry.__webglCustomAttributesList ) {

			for ( var id in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="disableAttributes">
<button class="show-code">Code</button>
dynamic <strong>disableAttributes</strong>() <a class="anchor-link" href="#disableAttributes"
              title="Permalink to WebGLRenderer.disableAttributes">#</a></h4>
<div class="doc">
<pre class="source">
disableAttributes() {

		_enabledAttributes.forEach((attribute, enabled) {

			if ( enabled ) {

				_gl.disableVertexAttribArray( int.parse(attribute) );
				_enabledAttributes[ attribute ] = false;

			}

		});

	}
</pre>
</div>
</div>
<div class="method"><h4 id="enableAttribute">
<button class="show-code">Code</button>
dynamic <strong>enableAttribute</strong>(attribute) <a class="anchor-link" href="#enableAttribute"
              title="Permalink to WebGLRenderer.enableAttribute">#</a></h4>
<div class="doc">
<pre class="source">
enableAttribute( attribute ) {

	  var k = attribute.toString();

		if ( _enabledAttributes[ k ] == null ||  !_enabledAttributes[ k ] ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ k ] = true;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="enableScissorTest">
<button class="show-code">Code</button>
dynamic <strong>enableScissorTest</strong>(enable) <a class="anchor-link" href="#enableScissorTest"
              title="Permalink to WebGLRenderer.enableScissorTest">#</a></h4>
<div class="doc">
<pre class="source">
enableScissorTest( enable ) {
		enable ? _gl.enable( gl.SCISSOR_TEST ) : _gl.disable( gl.SCISSOR_TEST );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="filterFallback">
<button class="show-code">Code</button>
dynamic <strong>filterFallback</strong>(f) <a class="anchor-link" href="#filterFallback"
              title="Permalink to WebGLRenderer.filterFallback">#</a></h4>
<div class="doc">
<pre class="source">
filterFallback ( f ) {

		if ( f == NearestFilter || f == NearestMipMapNearestFilter || f == NearestMipMapLinearFilter ) {

			return gl.NEAREST;

		}

		return gl.LINEAR;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="generateDefines">
<button class="show-code">Code</button>
dynamic <strong>generateDefines</strong>(defines) <a class="anchor-link" href="#generateDefines"
              title="Permalink to WebGLRenderer.generateDefines">#</a></h4>
<div class="doc">
<pre class="source">
generateDefines ( defines ) {

		var chunk, chunks = [];

		defines.forEach((d, value) {

			if ( value != false ) {
				chunk = "#define $d $value";
				chunks.add( chunk );
			}

		});

		return chunks.join( "\n" );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="getBufferMaterial">
<button class="show-code">Code</button>
<a href="../three/WebGLMaterial.html">WebGLMaterial</a> <strong>getBufferMaterial</strong>(<a href="../three/WebGLObject.html">WebGLObject</a> object, <a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometryGroup) <a class="anchor-link" href="#getBufferMaterial"
              title="Permalink to WebGLRenderer.getBufferMaterial">#</a></h4>
<div class="doc">
<pre class="source">
WebGLMaterial getBufferMaterial( WebGLObject object, WebGLGeometry geometryGroup ) {

	  Material material = (object.material is MeshFaceMaterial)
			? (object.material as MeshFaceMaterial).materials[ geometryGroup.materialIndex ]
			: object.material;

		return new WebGLMaterial.from(material);
	}
</pre>
</div>
</div>
<div class="method"><h4 id="getShader">
<button class="show-code">Code</button>
dynamic <strong>getShader</strong>(type, string) <a class="anchor-link" href="#getShader"
              title="Permalink to WebGLRenderer.getShader">#</a></h4>
<div class="doc">
<pre class="source">
getShader ( type, string ) {

		var shader;

		if ( type == "fragment" ) {

			shader = _gl.createShader( gl.FRAGMENT_SHADER );

		} else if ( type == "vertex" ) {

			shader = _gl.createShader( gl.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {

			print( _gl.getShaderInfoLog( shader ) );
			print( addLineNumbers( string ) );
			return null;

		}

		return shader;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="getTextureUnit">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a> <strong>getTextureUnit</strong>() <a class="anchor-link" href="#getTextureUnit"
              title="Permalink to WebGLRenderer.getTextureUnit">#</a></h4>
<div class="doc">
<pre class="source">
int getTextureUnit() {

  var unit = _usedTextureUnits;

  if ( unit &gt;= maxTextures ) {
    print( "WebGLRenderer: trying to use $unit texture units while this GPU supports only $maxTextures" );
  }

  _usedTextureUnits += 1;

  return unit;

}
</pre>
</div>
</div>
<div class="method"><h4 id="initCustomAttributes">
<button class="show-code">Code</button>
dynamic <strong>initCustomAttributes</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#initCustomAttributes"
              title="Permalink to WebGLRenderer.initCustomAttributes">#</a></h4>
<div class="doc">
<pre class="source">
initCustomAttributes ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		var material = object.webglmaterial;

		if ( material.attributes != null ) {

			if ( geometry.__webglCustomAttributesList == null ) {

				geometry.__webglCustomAttributesList = [];

			}

			material.attributes.forEach((key, attribute) {

				if( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					attribute.array = new Float32List( nvertices * attribute.size );

					attribute.buffer = new Buffer(_gl);
					attribute.buffer.belongsToAttribute = key;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.add( attribute );

			});

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initDirectBuffers">
<button class="show-code">Code</button>
dynamic <strong>initDirectBuffers</strong>(<a href="../three/BufferGeometry.html">BufferGeometry</a> geometry) <a class="anchor-link" href="#initDirectBuffers"
              title="Permalink to WebGLRenderer.initDirectBuffers">#</a></h4>
<div class="doc">
<pre class="source">
initDirectBuffers( BufferGeometry geometry ) {

		var a, attribute, type;

		geometry.attributes.forEach((a, v) {

			if ( a == "index" ) {

				type = gl.ELEMENT_ARRAY_BUFFER;

			} else {

				type = gl.ARRAY_BUFFER;

			}

			attribute = v;

			attribute.buffer = new Buffer(_gl);
			attribute.buffer.bind(type);
			_gl.bufferDataTyped(type, attribute.array, gl.STATIC_DRAW);

		});

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initGL">
<button class="show-code">Code</button>
dynamic <strong>initGL</strong>() <a class="anchor-link" href="#initGL"
              title="Permalink to WebGLRenderer.initGL">#</a></h4>
<div class="doc">
<pre class="source">
initGL () {

		try {
			_gl = canvas.getContext3d(alpha: alpha, premultipliedAlpha: premultipliedAlpha, antialias: antialias, stencil: stencil, preserveDrawingBuffer: preserveDrawingBuffer );
			if ( _gl == null ) {

				throw 'Error creating WebGL context.';

			}
		} catch ( error ) {

			print( error );

		}
		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' );
		if (_glExtensionTextureFilterAnisotropic == null) {
		  _glExtensionTextureFilterAnisotropic = _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' );
		}
		if (_glExtensionTextureFilterAnisotropic == null) {
		  _glExtensionTextureFilterAnisotropic = _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
		}
		if (_glExtensionCompressedTextureS3TC == null) {
			_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' );
		}
		if (_glExtensionCompressedTextureS3TC == null) {
		  _glExtensionCompressedTextureS3TC = _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' );
		}
		if (_glExtensionCompressedTextureS3TC == null) {
		  _glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
		}

		if ( _glExtensionTextureFloat == null ) {

			print( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

		if ( _glExtensionStandardDerivatives == null ) {

		  print( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( _glExtensionTextureFilterAnisotropic == null ) {

		  print( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

		if ( _glExtensionCompressedTextureS3TC == null ) {

			print( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );

		}
	}
</pre>
</div>
</div>
<div class="method"><h4 id="initLineBuffers">
<button class="show-code">Code</button>
dynamic <strong>initLineBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#initLineBuffers"
              title="Permalink to WebGLRenderer.initLineBuffers">#</a></h4>
<div class="doc">
<pre class="source">
initLineBuffers ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32List( nvertices * 3 );
		geometry.__colorArray = new Float32List( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32List( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initMaterial">
<button class="show-code">Code</button>
dynamic <strong>initMaterial</strong>(<a href="../three/WebGLMaterial.html">WebGLMaterial</a> material, <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../three/Light.html">Light</a>&gt; lights, <a href="../three/Fog.html">Fog</a> fog, <a href="../three/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#initMaterial"
              title="Permalink to WebGLRenderer.initMaterial">#</a></h4>
<div class="doc">
<pre class="source">
initMaterial( WebGLMaterial material, List&lt;Light&gt; lights, Fog fog, WebGLObject webglobject ) {

		//material.addEventListener( 'dispose', onMaterialDispose );

	  Object3D object = webglobject.object;

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material.isMeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material.isMeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material.isMeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material.isMeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material.isMeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material.isLineBasicMaterial ) {

			shaderID = 'basic';

		// TODO - Added LineDashedMaterial
		// } else if ( material.isLineDashedMaterial ) {

		//	shaderID = 'dashed';

		} else if ( material.isParticleBasicMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID != null) {

			setMaterialShaders( material, ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		material.program = buildProgram(
			shaderID,
			material.fragmentShader,
			material.vertexShader,
			material.uniforms,
			material.attributes,
			material.defines,
			map: material.map,
			envMap: material.envMap,
			lightMap: material.lightMap,
			bumpMap: material.bumpMap,
			normalMap: material.normalMap,
			specularMap: material.specularMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog is FogExp2,

			sizeAttenuation: material.sizeAttenuation,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: supportsBoneTextures &amp;&amp; object != null &amp;&amp; object is SkinnedMesh &amp;&amp; object.useVertexTexture,
			boneTextureWidth: (object != null &amp;&amp; object is SkinnedMesh) ? object.boneTextureWidth : null,
			boneTextureHeight: (object != null &amp;&amp; object is SkinnedMesh) ? object.boneTextureHeight : null,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: maxMorphTargets,
			maxMorphNormals: maxMorphNormals,

			maxDirLights: maxLightCount['directional'],
			maxPointLights: maxLightCount['point'],
			maxSpotLights: maxLightCount['spot'],
			maxHemiLights: maxLightCount['hemi'],

			maxShadows: maxShadows,
			shadowMapEnabled: shadowMapEnabled &amp;&amp; object.receiveShadow,
			shadowMapType: shadowMapType,
			shadowMapDebug: shadowMapDebug,
			shadowMapCascade: shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			perPixel: material.perPixel,
			wrapAround: material.wrapAround,
			doubleSided: material.side == DoubleSide,
			flipSided: material.side == BackSide );

		var attributes = material.program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i &lt; maxMorphTargets; i ++ ) {

				id = "$base$i";

				if ( attributes[ id ] &gt;= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = "morphNormal";

			for ( i = 0; i &lt; maxMorphNormals; i ++ ) {

				id = "$base$i";

				if ( attributes[ id ] &gt;= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		material.uniforms.forEach( (k, u) =&gt; material.uniformsList.add( [ u, k ] ));

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initMeshBuffers">
<button class="show-code">Code</button>
dynamic <strong>initMeshBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometryGroup, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#initMeshBuffers"
              title="Permalink to WebGLRenderer.initMeshBuffers">#</a></h4>
<div class="doc">
<pre class="source">
initMeshBuffers ( WebGLGeometry geometryGroup, WebGLObject object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,
			faces4 = geometryGroup.faces4,

			nvertices = faces3.length * 3 + faces4.length * 4,
			ntris     = faces3.length * 1 + faces4.length * 2,
			nlines    = faces3.length * 3 + faces4.length * 4;

		WebGLMaterial material = getBufferMaterial( object, geometryGroup );

		var uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		//console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32List( nvertices * 3 );

		if ( normalType != NoShading ) {

			geometryGroup.__normalArray = new Float32List( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32List( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32List( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceUvs.length &gt; 0 || geometry.faceVertexUvs.length &gt; 0 ) {

				geometryGroup.__uvArray = new Float32List( nvertices * 2 );

			}

			if ( geometry.faceUvs.length &gt; 1 || geometry.faceVertexUvs.length &gt; 1 ) {

				geometryGroup.__uv2Array = new Float32List( nvertices * 2 );

			}

		}

		if ( !object.geometry.skinWeights.isEmpty &amp;&amp; !object.geometry.skinIndices.isEmpty ) {

			geometryGroup.__skinIndexArray = new Float32List( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32List( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16List( ntris * 3 );
		geometryGroup.__lineArray = new Uint16List( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets != null ) {

			geometryGroup.__morphTargetsArrays = [];

			ml = geometryGroup.numMorphTargets;

			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.add( new Float32List( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals != null ) {

			geometryGroup.__morphNormalsArrays = [];

			ml = geometryGroup.numMorphNormals;

			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.add( new Float32List( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes != null) {

			if ( geometryGroup.__webglCustomAttributesList == null ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			material.attributes.forEach((key, attribute) {

				if( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;
					attribute.array = new Float32List( nvertices * attribute.size );

					var buffer = new Buffer(_gl);
					buffer.belongsToAttribute = key;
					attribute.buffer = buffer;

        // Do a shallow copy of the attribute object so different geometryGroup chunks use different
	        // attribute buffers which are correctly indexed in the setMeshBuffers function

	        var originalAttribute = attribute.clone();
					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.add( attribute );

			});

		}

		geometryGroup.__inittedArrays = true;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initParticleBuffers">
<button class="show-code">Code</button>
dynamic <strong>initParticleBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#initParticleBuffers"
              title="Permalink to WebGLRenderer.initParticleBuffers">#</a></h4>
<div class="doc">
<pre class="source">
initParticleBuffers ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32List( nvertices * 3 );
		geometry.__colorArray = new Float32List( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initRibbonBuffers">
<button class="show-code">Code</button>
dynamic <strong>initRibbonBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry, object) <a class="anchor-link" href="#initRibbonBuffers"
              title="Permalink to WebGLRenderer.initRibbonBuffers">#</a></h4>
<div class="doc">
<pre class="source">
initRibbonBuffers ( WebGLGeometry geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32List( nvertices * 3 );
		geometry.__colorArray = new Float32List( nvertices * 3 );
		geometry.__normalArray = new Float32List( nvertices * 3 );

		geometry.__webglVertexCount = nvertices;

		initCustomAttributes ( geometry, object );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initWebGLObjects">
<button class="show-code">Code</button>
dynamic <strong>initWebGLObjects</strong>(<a href="../three/Scene.html">Scene</a> scene) <a class="anchor-link" href="#initWebGLObjects"
              title="Permalink to WebGLRenderer.initWebGLObjects">#</a></h4>
<div class="doc">
<pre class="source">
initWebGLObjects( Scene scene ) {

		if ( scene["__webglObjects"] == null ) {

			scene["__webglObjects"] = [];
			scene["__webglObjectsImmediate"] = [];
			scene["__webglSprites"] = [];
			scene["__webglFlares"] = [];

		}

		while ( scene.__objectsAdded.length &gt; 0 ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.removeAt( 0 );

		}

		while ( scene.__objectsRemoved.length &gt; 0) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.removeAt( 0 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene["__webglObjects"].length; o &lt; ol; o ++ ) {

			updateObject( scene["__webglObjects"][ o ] );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="isPowerOfTwo">
<button class="show-code">Code</button>
dynamic <strong>isPowerOfTwo</strong>(<a href="http://api.dartlang.org/dart_core/int.html">int</a> value) <a class="anchor-link" href="#isPowerOfTwo"
              title="Permalink to WebGLRenderer.isPowerOfTwo">#</a></h4>
<div class="doc">
<pre class="source">
isPowerOfTwo ( int value ) =&gt; ( value &amp; ( value - 1 ) ) == 0;
</pre>
</div>
</div>
<div class="method"><h4 id="loadUniformsGeneric">
<button class="show-code">Code</button>
dynamic <strong>loadUniformsGeneric</strong>(program, uniforms) <a class="anchor-link" href="#loadUniformsGeneric"
              title="Permalink to WebGLRenderer.loadUniformsGeneric">#</a></h4>
<div class="doc">
<pre class="source">
loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;

		jl = uniforms.length;
		for ( j = 0; j &lt; jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( location == null ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.typedValue; // Get the value properly typed

			if ( type == "i" ) { // single integer

				_gl.uniform1i( location, value );

			} else if ( type == "f" ) { // single float

				_gl.uniform1f( location, value );

			} else if ( type == "v2" ) { // single THREE.Vector2

				_gl.uniform2f( location, value.x, value.y );

			} else if ( type == "v3" ) { // single THREE.Vector3

				_gl.uniform3f( location, value.x, value.y, value.z );

			} else if ( type == "v4" ) { // single THREE.Vector4

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			} else if ( type == "c" ) { // single THREE.Color

				_gl.uniform3f( location, value.r, value.g, value.b );

			} else if ( type == "iv1" ) { // flat array of integers (JS or typed array)

				_gl.uniform1iv( location, value );

			} else if ( type == "iv" ) { // flat array of integers with 3 x N size (JS or typed array)

				_gl.uniform3iv( location, value );

			} else if ( type == "fv1" ) { // flat array of floats (JS or typed array)

				_gl.uniform1fv( location, value );

			} else if ( type == "fv" ) { // flat array of floats with 3 x N size (JS or typed array)

				_gl.uniform3fv( location, value );

			} else if ( type == "v2v" ) { // array of THREE.Vector2

				_gl.uniform2fv( location, value );

			} else if ( type == "v3v" ) { // array of THREE.Vector3

				_gl.uniform3fv( location, value );

			} else if ( type == "v4v" ) { // array of THREE.Vector4

				_gl.uniform4fv( location, value );

			} else if ( type == "m2") { // single THREE.Matrix2

				_gl.uniformMatrix2fv( location, false, value );

			} else if ( type == "m3") { // single THREE.Matrix3

				_gl.uniformMatrix3fv( location, false, value );

			} else if ( type == "m4") { // single THREE.Matrix4

				_gl.uniformMatrix4fv( location, false, value );

			} else if ( type == "m4v" ) { // array of THREE.Matrix4

				_gl.uniformMatrix4fv( location, false, value );

			} else if ( type == "t" ) { // single THREE.Texture (2d or cube)

	       texture = uniform.value;
	       textureUnit = getTextureUnit();

				_gl.uniform1i( location, textureUnit );

				if ( texture == null ) continue;

				if ( (texture.image is ImageList || texture.image is WebGLImageList) &amp;&amp; texture.image.length == 6 ) {

					setCubeTexture( texture, textureUnit );

				} else if ( texture is WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, textureUnit );

				} else {

					setTexture( texture, textureUnit );

				}

			} else if ( type == "tv" ) { // array of THREE.Texture (2d)

			  List&lt;Texture&gt; textures = uniform.value;

			  uniform._array = new Int32List.fromList(textures.map((_) =&gt; getTextureUnit()).toList());

				_gl.uniform1iv( location, uniform._array );

				il = textures.length;
				for( i = 0; i &lt; il; i ++ ) {

					texture = uniform.value[ i ];
        textureUnit = uniform._array[i];

					if ( texture == null) continue;

					setTexture( texture, textureUnit );

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="loadUniformsMatrices">
<button class="show-code">Code</button>
dynamic <strong>loadUniformsMatrices</strong>(uniforms, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#loadUniformsMatrices"
              title="Permalink to WebGLRenderer.loadUniformsMatrices">#</a></h4>
<div class="doc">
<pre class="source">
loadUniformsMatrices ( uniforms, WebGLObject object ) {

		_gl.uniformMatrix4fv( uniforms["modelViewMatrix"], false, object._modelViewMatrix.storage );

		if ( uniforms["normalMatrix"] != null ) {

			_gl.uniformMatrix3fv( uniforms["normalMatrix"], false, object._normalMatrix.storage );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="materialNeedsSmoothNormals">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>materialNeedsSmoothNormals</strong>(material) <a class="anchor-link" href="#materialNeedsSmoothNormals"
              title="Permalink to WebGLRenderer.materialNeedsSmoothNormals">#</a></h4>
<div class="doc">
<pre class="source">
bool materialNeedsSmoothNormals ( material ) {

		return material != null &amp;&amp; material.shading != null &amp;&amp; material.shading == SmoothShading;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="numericalSort">
<button class="show-code">Code</button>
dynamic <strong>numericalSort</strong>(a, b) <a class="anchor-link" href="#numericalSort"
              title="Permalink to WebGLRenderer.numericalSort">#</a></h4>
<div class="doc">
<pre class="source">
numericalSort ( a, b ) =&gt; (b[ 0 ] - a[ 0 ]).toInt();
</pre>
</div>
</div>
<div class="method"><h4 id="onGeometryDispose">
<button class="show-code">Code</button>
dynamic <strong>onGeometryDispose</strong>(event) <a class="anchor-link" href="#onGeometryDispose"
              title="Permalink to WebGLRenderer.onGeometryDispose">#</a></h4>
<div class="doc">
<pre class="source">
onGeometryDispose( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

		info.memory.geometries --;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="onMaterialDispose">
<button class="show-code">Code</button>
dynamic <strong>onMaterialDispose</strong>(event) <a class="anchor-link" href="#onMaterialDispose"
              title="Permalink to WebGLRenderer.onMaterialDispose">#</a></h4>
<div class="doc">
<pre class="source">
onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="onRenderTargetDispose">
<button class="show-code">Code</button>
dynamic <strong>onRenderTargetDispose</strong>(event) <a class="anchor-link" href="#onRenderTargetDispose"
              title="Permalink to WebGLRenderer.onRenderTargetDispose">#</a></h4>
<div class="doc">
<pre class="source">
onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="onTextureDispose">
<button class="show-code">Code</button>
dynamic <strong>onTextureDispose</strong>(event) <a class="anchor-link" href="#onTextureDispose"
              title="Permalink to WebGLRenderer.onTextureDispose">#</a></h4>
<div class="doc">
<pre class="source">
onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		info.memory.textures --;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="painterSort">
<button class="show-code">Code</button>
dynamic <strong>painterSort</strong>(a, b) <a class="anchor-link" href="#painterSort"
              title="Permalink to WebGLRenderer.painterSort">#</a></h4>
<div class="doc">
<pre class="source">
painterSort ( a, b ) =&gt; (a.z.isNaN || b.z.isNaN || a.z.isInfinite || b.z.isInfinite) ? 0 : (b.z - a.z).toInt();
</pre>
</div>
</div>
<div class="method"><h4 id="paramThreeToGL">
<button class="show-code">Code</button>
dynamic <strong>paramThreeToGL</strong>(p) <a class="anchor-link" href="#paramThreeToGL"
              title="Permalink to WebGLRenderer.paramThreeToGL">#</a></h4>
<div class="doc">
<pre class="source">
paramThreeToGL ( p ) {

		if ( p == RepeatWrapping ) return gl.REPEAT;
		if ( p == ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
		if ( p == MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;

		if ( p == NearestFilter ) return gl.NEAREST;
		if ( p == NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
		if ( p == NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;

		if ( p == LinearFilter ) return gl.LINEAR;
		if ( p == LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
		if ( p == LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;

		if ( p == UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p == UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p == UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p == UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

		if ( p == ByteType ) return gl.BYTE;
		if ( p == ShortType ) return gl.SHORT;
		if ( p == UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p == IntType ) return gl.INT;
		if ( p == UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p == FloatType ) return gl.FLOAT;

		if ( p == AlphaFormat ) return gl.ALPHA;
		if ( p == RGBFormat ) return gl.RGB;
		if ( p == RGBAFormat ) return gl.RGBA;
		if ( p == LuminanceFormat ) return gl.LUMINANCE;
		if ( p == LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;

		if ( p == AddEquation ) return gl.FUNC_ADD;
		if ( p == SubtractEquation ) return gl.FUNC_SUBTRACT;
		if ( p == ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;

		if ( p == ZeroFactor ) return gl.ZERO;
		if ( p == OneFactor ) return gl.ONE;
		if ( p == SrcColorFactor ) return gl.SRC_COLOR;
		if ( p == OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
		if ( p == SrcAlphaFactor ) return gl.SRC_ALPHA;
		if ( p == OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
		if ( p == DstAlphaFactor ) return gl.DST_ALPHA;
		if ( p == OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;

		if ( p == DstColorFactor ) return gl.DST_COLOR;
		if ( p == OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
		if ( p == SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;

		if ( _glExtensionCompressedTextureS3TC != null ) {

			if ( p == RGB_S3TC_DXT1_Format ) return gl.CompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p == RGBA_S3TC_DXT1_Format ) return gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p == RGBA_S3TC_DXT3_Format ) return gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p == RGBA_S3TC_DXT5_Format ) return gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}
		return 0;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsCommon">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsCommon</strong>(<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="../three/Uniform.html">Uniform</a>&gt; uniforms, material) <a class="anchor-link" href="#refreshUniformsCommon"
              title="Permalink to WebGLRenderer.refreshUniformsCommon">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsCommon ( Map&lt;String, Uniform&gt; uniforms, material ) {

		uniforms["opacity"].value = material.opacity;

		if ( gammaInput ) {

			uniforms["diffuse"].value.copyGammaToLinear( material.color );

		} else {

			uniforms["diffuse"].value = material.color;

		}

		uniforms["map"].value = material.map;
		uniforms["lightMap"].value = material.lightMap;
		uniforms["specularMap"].value = material.specularMap;

		if ( material.bumpMap != null ) {

			uniforms["bumpMap"].value = material.bumpMap;
			uniforms["bumpScale"].value = material.bumpScale;

		}

		if ( material.normalMap != null ) {

			uniforms["normalMap"].value = material.normalMap;
			uniforms["normalScale"].value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. normal map
		//	4. bump map

		var uvScaleMap;

		if ( material.map != null ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap != null ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap != null ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap != null ) {

			uvScaleMap = material.bumpMap;

		}

		if ( uvScaleMap != null ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms["offsetRepeat"].value.setValues( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms["envMap"].value = material.envMap;
		uniforms["flipEnvMap"].value = ( material.envMap is WebGLRenderTargetCube ) ? 1 : -1;

		if ( gammaInput ) {

			//uniforms["reflectivity"].value = material.reflectivity * material.reflectivity;
			uniforms["reflectivity"].value = material.reflectivity;

		} else {

			uniforms["reflectivity"].value = material.reflectivity;

		}

		uniforms["refractionRatio"].value = material.refractionRatio;
		uniforms["combine"].value = material.combine;
		uniforms["useRefract"].value = ((material.envMap != null) &amp;&amp; (material.envMap.mapping is CubeRefractionMapping))? 1:0;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsDash">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsDash</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsDash"
              title="Permalink to WebGLRenderer.refreshUniformsDash">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsDash ( uniforms, material ) {

		uniforms["dashSize"].value = material.dashSize;
		uniforms["totalSize"].value = material.dashSize + material.gapSize;
		uniforms["scale"].value = material.scale;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsFog">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsFog</strong>(uniforms, <a href="../three/Fog.html">Fog</a> fog) <a class="anchor-link" href="#refreshUniformsFog"
              title="Permalink to WebGLRenderer.refreshUniformsFog">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsFog ( uniforms, Fog fog ) {

		uniforms["fogColor"].value = fog.color;

		if ( fog is FogLinear ) {

			uniforms["fogNear"].value = fog.near;
			uniforms["fogFar"].value = fog.far;

		} else if ( fog is FogExp2 ) {

			uniforms["fogDensity"].value = fog.density;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsLambert">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsLambert</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsLambert"
              title="Permalink to WebGLRenderer.refreshUniformsLambert">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsLambert ( uniforms, material ) {

		if ( gammaInput ) {

			uniforms["ambient"].value.copyGammaToLinear( material.ambient );
			uniforms["emissive"].value.copyGammaToLinear( material.emissive );

		} else {

			uniforms["ambient"].value = material.ambient;
			uniforms["emissive"].value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms["wrapRGB"].value.copy( material.wrapRGB );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsLights">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsLights</strong>(<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="../three/Uniform.html">Uniform</a>&gt; uniforms, <a href="http://api.dartlang.org/dart_core/Map.html">Map</a> lights) <a class="anchor-link" href="#refreshUniformsLights"
              title="Permalink to WebGLRenderer.refreshUniformsLights">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsLights ( Map&lt;String, Uniform&gt; uniforms, Map lights ) {

		uniforms["ambientLightColor"].value = lights["ambient"];

		uniforms["directionalLightColor"].value = lights["directional"]["colors"];
		uniforms["directionalLightDirection"].value = lights["directional"]["positions"];

		uniforms["pointLightColor"].value = lights["point"]["colors"];
		uniforms["pointLightPosition"].value = lights["point"]["positions"];
		uniforms["pointLightDistance"].value = lights["point"]["distances"];

		uniforms["spotLightColor"].value = lights["spot"]["colors"];
		uniforms["spotLightPosition"].value = lights["spot"]["positions"];
		uniforms["spotLightDistance"].value = lights["spot"]["distances"];
		uniforms["spotLightDirection"].value = lights["spot"]["directions"];
		uniforms["spotLightAngleCos"].value = lights["spot"]["anglesCos"];
		uniforms["spotLightExponent"].value = lights["spot"]["exponents"];

		uniforms["hemisphereLightSkyColor"].value = lights["hemi"]["skyColors"];
		uniforms["hemisphereLightGroundColor"].value = lights["hemi"]["groundColors"];
		uniforms["hemisphereLightDirection"].value = lights["hemi"]["positions"];
	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsLine">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsLine</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsLine"
              title="Permalink to WebGLRenderer.refreshUniformsLine">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsLine ( uniforms, material ) {

		uniforms["diffuse"].value = material.color;
		uniforms["opacity"].value = material.opacity;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsParticle">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsParticle</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsParticle"
              title="Permalink to WebGLRenderer.refreshUniformsParticle">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsParticle ( uniforms, material ) {

		uniforms["psColor"].value = material.color;
		uniforms["opacity"].value = material.opacity;
		uniforms["size"].value = material.size;
		uniforms["scale"].value = canvas.height / 2.0; // TODO: Cache

		uniforms["map"].value = material.map;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsPhong">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsPhong</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsPhong"
              title="Permalink to WebGLRenderer.refreshUniformsPhong">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsPhong ( uniforms, material ) {

		uniforms["shininess"].value = material.shininess;

		if ( gammaInput ) {

			uniforms["ambient"].value.copyGammaToLinear( material.ambient );
			uniforms["emissive"].value.copyGammaToLinear( material.emissive );
			uniforms["specular"].value.copyGammaToLinear( material.specular );

		} else {

			uniforms["ambient"].value = material.ambient;
			uniforms["emissive"].value = material.emissive;
			uniforms["specular"].value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms["wrapRGB"].value.copy( material.wrapRGB );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsShadow">
<button class="show-code">Code</button>
dynamic <strong>refreshUniformsShadow</strong>(<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="../three/Uniform.html">Uniform</a>&gt; uniforms, lights) <a class="anchor-link" href="#refreshUniformsShadow"
              title="Permalink to WebGLRenderer.refreshUniformsShadow">#</a></h4>
<div class="doc">
<pre class="source">
refreshUniformsShadow ( Map&lt;String, Uniform&gt; uniforms, lights ) {

		if ( uniforms.containsKey("shadowMatrix") ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i &lt; il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light is SpotLight || ( light is DirectionalLight &amp;&amp; ! light.shadowCascade ) ) {

				  // Grow the arrays
				  if (uniforms["shadowMap"].value.length &lt; j + 1) {
				    uniforms["shadowMap"].value.length = j + 1;
				    uniforms["shadowMapSize"].value.length = j + 1;
				    uniforms["shadowMatrix"].value.length = j + 1;
				    uniforms["shadowDarkness"].value.length = j + 1;
				    uniforms["shadowBias"].value.length = j + 1;
				  }

					uniforms["shadowMap"].value[ j ] = light.shadowMap;
					uniforms["shadowMapSize"].value[ j ] = light.shadowMapSize;

					uniforms["shadowMatrix"].value[ j ] = light.shadowMatrix;

					uniforms["shadowDarkness"].value[ j ] = light.shadowDarkness;
					uniforms["shadowBias"].value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="removeInstances">
<button class="show-code">Code</button>
dynamic <strong>removeInstances</strong>(objlist, <a href="../three/Object3D.html">Object3D</a> object) <a class="anchor-link" href="#removeInstances"
              title="Permalink to WebGLRenderer.removeInstances">#</a></h4>
<div class="doc">
<pre class="source">
removeInstances ( objlist, Object3D object ) {

		for ( var o = objlist.length - 1; o &gt;= 0; o -- ) {

			if ( objlist[ o ].object == object ) {

				objlist.removeAt( o );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="removeInstancesDirect">
<button class="show-code">Code</button>
dynamic <strong>removeInstancesDirect</strong>(objlist, <a href="../three/Object3D.html">Object3D</a> object) <a class="anchor-link" href="#removeInstancesDirect"
              title="Permalink to WebGLRenderer.removeInstancesDirect">#</a></h4>
<div class="doc">
<pre class="source">
removeInstancesDirect ( objlist, Object3D object ) {

		for ( var o = objlist.length - 1; o &gt;= 0; o -- ) {

    if ( identical(objlist[ o ], object) ) {

				objlist.removeAt( o );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="removeObject">
<button class="show-code">Code</button>
dynamic <strong>removeObject</strong>(<a href="../three/Object3D.html">Object3D</a> object, scene) <a class="anchor-link" href="#removeObject"
              title="Permalink to WebGLRenderer.removeObject">#</a></h4>
<div class="doc">
<pre class="source">
removeObject ( Object3D object, scene ) {

	  WebGLObject webglobject = new WebGLObject(object);

		if ( object is Mesh  ||
			 object is ParticleSystem ||
			 object is Ribbon ||
			 object is Line ) {

			removeInstances( scene["__webglObjects"], object );

		} else if ( object is Sprite ) {

			removeInstancesDirect( scene["__webglSprites"], object );

		} else if ( object is LensFlare ) {

			removeInstancesDirect( scene["__webglFlares"], object );

		} else if ( object is ImmediateRenderObject || (object["immediateRenderCallback"] != null) ) {

			removeInstances( scene["__webglObjectsImmediate"], object );

		}

		webglobject.__webglActive = false;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="render">
<button class="show-code">Code</button>
dynamic <strong>render</strong>(<a href="../three/Scene.html">Scene</a> scene, <a href="../three/Camera.html">Camera</a> camera) <a class="anchor-link" href="#render"
              title="Permalink to WebGLRenderer.render">#</a></h4>
<div class="doc">
<pre class="source">
render ( Scene scene, Camera camera) =&gt; _render( scene, camera);
</pre>
</div>
</div>
<div class="method"><h4 id="renderBuffer">
<button class="show-code">Code</button>
dynamic <strong>renderBuffer</strong>(camera, lights, fog, <a href="../three/WebGLMaterial.html">WebGLMaterial</a> material, <a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometryGroup, object) <a class="anchor-link" href="#renderBuffer"
              title="Permalink to WebGLRenderer.renderBuffer">#</a></h4>
<div class="doc">
<pre class="source">
renderBuffer ( camera, lights, fog, WebGLMaterial material, WebGLGeometry geometryGroup, object ) {

	  // Wrap these into proper WebGL objects since this method is called from plugins
	  WebGLObject webglobject = (object is WebGLObject) ? object : new WebGLObject(object);
    object = webglobject.object;

    WebGLCamera webglcamera = (camera is WebGLCamera) ? camera : new WebGLCamera(camera);
    camera = webglcamera._camera;

		if ( !material.visible ) return;

		var program, attributes, linewidth, primitives, a, attribute, i, il;

		program = setProgram( webglcamera, lights, fog, material, webglobject );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash != _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

      if ( updateBuffers ) {

			disableAttributes();

		}
		// vertices

		if ( !material.morphTargets &amp;&amp; attributes["position"] &gt;= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes["position"] );
				_gl.vertexAttribPointer( attributes["position"], 3, gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( webglobject.morphTargetBase != 0 ) {

				setupMorphTargets( material, geometryGroup, webglobject );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList != null) {

			  il = geometryGroup.__webglCustomAttributesList.length;
				for ( i = 0; i &lt; il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if( attributes[ attribute.buffer.belongsToAttribute ] &gt;= 0 ) {

						attribute.buffer.bind(gl.ARRAY_BUFFER);
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes["color"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				enableAttribute( attributes["color"] );
				_gl.vertexAttribPointer( attributes["color"], 3, gl.FLOAT, false, 0, 0 );

			}

			// normals

			if ( attributes["normal"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes["normal"] );
				_gl.vertexAttribPointer( attributes["normal"], 3, gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes["tangent"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes["tangent"] );
				_gl.vertexAttribPointer( attributes["tangent"], 4, gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes["uv"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				enableAttribute( attributes["uv"] );
				_gl.vertexAttribPointer( attributes["uv"], 2, gl.FLOAT, false, 0, 0 );


			}

			if ( attributes["uv2"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				enableAttribute( attributes["uv2"] );
				_gl.vertexAttribPointer( attributes["uv2"], 2, gl.FLOAT, false, 0, 0 );

			}

			if ( material.skinning &amp;&amp;
				 attributes["skinIndex"] &gt;= 0 &amp;&amp; attributes["skinWeight"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes["skinIndex"] );
				_gl.vertexAttribPointer( attributes["skinIndex"], 4, gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes["skinWeight"] );
				_gl.vertexAttribPointer( attributes["skinWeight"], 4, gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes["lineDistance"] &gt;= 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes["lineDistance"] );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, gl.FLOAT, false, 0, 0 );

			}
		}

		// render mesh

		if ( object is Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( gl.LINES, geometryGroup.__webglLineCount, gl.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( gl.TRIANGLES, geometryGroup.__webglFaceCount, gl.UNSIGNED_SHORT, 0 );

			}

			info.render.calls ++;
			info.render.vertices += geometryGroup.__webglFaceCount;
			info.render.faces += geometryGroup.__webglFaceCount ~/ 3;

		// render lines

		} else if ( object is Line ) {

			primitives = ( (object as Line).type == LineStrip ) ? gl.LINE_STRIP : gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			info.render.calls ++;

		// render particles

		} else if ( object is ParticleSystem ) {

			_gl.drawArrays( gl.POINTS, 0, geometryGroup.__webglParticleCount );

			info.render.calls ++;
			info.render.points += geometryGroup.__webglParticleCount;

		// render ribbon

		} else if ( object is Ribbon ) {

			_gl.drawArrays( gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );

			info.render.calls ++;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderBufferDirect">
<button class="show-code">Code</button>
dynamic <strong>renderBufferDirect</strong>(<a href="../three/WebGLCamera.html">WebGLCamera</a> camera, <a href="http://api.dartlang.org/dart_core/List.html">List</a> lights, fog, <a href="../three/WebGLMaterial.html">WebGLMaterial</a> material, <a href="../three/WebGLGeometry.html">WebGLGeometry</a> webglgeometry, <a href="../three/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#renderBufferDirect"
              title="Permalink to WebGLRenderer.renderBufferDirect">#</a></h4>
<div class="doc">
<pre class="source">
renderBufferDirect ( WebGLCamera camera, List lights, fog, WebGLMaterial material, WebGLGeometry webglgeometry, WebGLObject webglobject ) {

		if ( !material.visible ) return;

		var program, attributes, linewidth, primitives, a, attribute;

		program = setProgram( camera, lights, fog, material, webglobject );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( webglgeometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash != _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// render mesh
  	var object = webglobject.object;

  	BufferGeometry geometry = webglgeometry._geometry;

		if ( object is Mesh ) {

			var index = geometry.aIndex;

			// indexed triangles

			if ( index != null) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length &gt; 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i &lt; il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						// vertices

						var position = geometry.attributes[ "position" ];
						var positionSize = position.itemSize;

						position.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["position"] );
						_gl.vertexAttribPointer( attributes["position"], positionSize, gl.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32

						// normals

						var normal = geometry.attributes[ "normal" ];

						if ( attributes["normal"] &gt;= 0 &amp;&amp; normal != null) {

							var normalSize = normal.itemSize;

							normal.buffer.bind( gl.ARRAY_BUFFER );
							enableAttribute( attributes["normal"] );
							_gl.vertexAttribPointer( attributes["normal"], normalSize, gl.FLOAT, false, 0, startIndex * normalSize * 4 );

						}

						// uvs

						var uv = geometry.attributes[ "uv" ];

						if ( attributes["uv"] &gt;= 0 &amp;&amp; uv != null ) {

							var uvSize = uv.itemSize;

							uv.buffer.bind( gl.ARRAY_BUFFER );
							enableAttribute( attributes["uv"]);
							_gl.vertexAttribPointer( attributes["uv"], uvSize, gl.FLOAT, false, 0, startIndex * uvSize * 4 );

						}

						// colors

						var color = geometry.attributes[ "color" ];

						if ( attributes["color"] &gt;= 0 &amp;&amp; color != null ) {

							var colorSize = color.itemSize;

							color.buffer.bind( gl.ARRAY_BUFFER );
							enableAttribute( attributes["color"] );
							_gl.vertexAttribPointer( attributes["color"], colorSize, gl.FLOAT, false, 0, startIndex * colorSize * 4 );

						}

						// tangents

						var tangent = geometry.attributes[ "tangent" ];

						if ( attributes["tangent"] &gt;= 0 &amp;&amp; tangent != null ) {

							var tangentSize = tangent.itemSize;

							tangent.buffer.bind( gl.ARRAY_BUFFER );
							enableAttribute( attributes["tangent"] );
							_gl.vertexAttribPointer( attributes["tangent"], tangentSize, gl.FLOAT, false, 0, startIndex * tangentSize * 4 );

						}

						// indices

						index.buffer.bind( gl.ELEMENT_ARRAY_BUFFER );

					}

					// render indexed triangles

					_gl.drawElements( gl.TRIANGLES, offsets[ i ].count, gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

					info.render.calls ++;
					info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
					info.render.faces += offsets[ i ].count ~/ 3;

				}

			// non-indexed triangles

			} else {

			  GeometryAttribute&lt;Float32List&gt; position = geometry.aPosition;

				if ( updateBuffers ) {

					// vertices


					var positionSize = position.itemSize;

					position.buffer.bind( gl.ARRAY_BUFFER );
					enableAttribute( attributes["position"] );
					_gl.vertexAttribPointer( attributes["position"], positionSize, gl.FLOAT, false, 0, 0 );

					// normals

					GeometryAttribute&lt;Float32List&gt; normal = geometry.aNormal;

					if ( attributes["normal"] &gt;= 0 &amp;&amp; normal != null ) {

						var normalSize = normal.itemSize;

						normal.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["normal"] );
						_gl.vertexAttribPointer( attributes["normal"], normalSize, gl.FLOAT, false, 0, 0 );

					}

					// uvs

					GeometryAttribute&lt;Float32List&gt; uv = geometry.aUV;

					if ( attributes["uv"] &gt;= 0 &amp;&amp; uv != null ) {

						var uvSize = uv.itemSize;

						uv.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["uv"] );
						_gl.vertexAttribPointer( attributes["uv"], uvSize, gl.FLOAT, false, 0, 0 );

					}

					// colors

					GeometryAttribute&lt;Float32List&gt; color = geometry.aColor;

					if ( attributes["color"] &gt;= 0 &amp;&amp; color != null ) {

						var colorSize = color.itemSize;

						color.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["color"] );
						_gl.vertexAttribPointer( attributes["color"], colorSize, gl.FLOAT, false, 0, 0 );

					}

					// tangents

					GeometryAttribute&lt;Float32List&gt; tangent = geometry.aTangent;

					if ( attributes["tangent"] &gt;= 0 &amp;&amp; tangent != null ) {

						var tangentSize = tangent.itemSize;

						tangent.buffer.bind( gl.ARRAY_BUFFER );
						enableAttribute( attributes["tangent"] );
						_gl.vertexAttribPointer( attributes["tangent"], tangentSize, gl.FLOAT, false, 0, 0 );

					}
				}

				// render non-indexed triangles

				_gl.drawArrays( gl.TRIANGLES, 0, position.numItems ~/ 3 );

				info.render.calls ++;
				info.render.vertices += position.numItems ~/ 3;
				info.render.faces += position.numItems ~/ 3 ~/ 3;

			}

		// render particles

		} else if ( object is ParticleSystem ) {

			if ( updateBuffers ) {

				// vertices

				var position = geometry.attributes[ "position" ];
				var positionSize = position.itemSize;

				position.buffer.bind( gl.ARRAY_BUFFER );
				enableAttribute( attributes["position"] );
				_gl.vertexAttribPointer( attributes["position"], positionSize, gl.FLOAT, false, 0, 0 );

				// colors

				var color = geometry.attributes[ "color" ];

				if ( attributes["color"] &gt;= 0 &amp;&amp; color != null ) {

					var colorSize = color.itemSize;

					color.buffer.bind( gl.ARRAY_BUFFER );
					enableAttribute( attributes["color"] );
					_gl.vertexAttribPointer( attributes["color"], colorSize, gl.FLOAT, false, 0, 0 );

				}

				// render particles

				_gl.drawArrays( gl.POINTS, 0, position.numItems ~/ 3);

				info.render.calls ++;
				info.render.points += position.numItems ~/ 3;

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderBufferImmediate">
<button class="show-code">Code</button>
dynamic <strong>renderBufferImmediate</strong>(object, program, material) <a class="anchor-link" href="#renderBufferImmediate"
              title="Permalink to WebGLRenderer.renderBufferImmediate">#</a></h4>
<div class="doc">
<pre class="source">
renderBufferImmediate ( object, program, material ) {

		if ( object.hasPositions &amp;&amp; ! object["__webglVertexBuffer"] ) object["__webglVertexBuffer"] = _gl.createBuffer();
		if ( object.hasNormals &amp;&amp; ! object["__webglNormalBuffer"] ) object["__webglNormalBuffer"] = _gl.createBuffer();
		if ( object.hasUvs &amp;&amp; ! object["__webglUVBuffer"] ) object["__webglUVBuffer"] = _gl.createBuffer();
		if ( object.hasColors &amp;&amp; ! object["__webglColorBuffer"] ) object["__webglColorBuffer"] = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, object["__webglVertexBuffer"] );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, object.positionArray, gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["position"] );
			_gl.vertexAttribPointer( program.attributes["position"], 3, gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, object["__webglNormalBuffer"] );

			if ( material.shading == FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i &lt; il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferDataTyped( gl.ARRAY_BUFFER, object.normalArray, gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["normal"] );
			_gl.vertexAttribPointer( program.attributes["normal"], 3, gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs &amp;&amp; material.map ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, object["__webglUVBuffer"] );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, object.uvArray, gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["uv"] );
			_gl.vertexAttribPointer( program.attributes["uv"], 2, gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors &amp;&amp; material.vertexColors != NoColors ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, object["__webglColorBuffer"] );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, object.colorArray, gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["color"] );
			_gl.vertexAttribPointer( program.attributes["color"], 3, gl.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( gl.TRIANGLES, 0, object.count );

		object.count = 0;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderImmediateObject">
<button class="show-code">Code</button>
dynamic <strong>renderImmediateObject</strong>(camera, lights, fog, material, object) <a class="anchor-link" href="#renderImmediateObject"
              title="Permalink to WebGLRenderer.renderImmediateObject">#</a></h4>
<div class="doc">
<pre class="source">
renderImmediateObject( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = -1;

		setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( ( object ) { renderBufferImmediate( object, program, material ); } );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderObjects">
<button class="show-code">Code</button>
dynamic <strong>renderObjects</strong>(<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../three/WebGLObject.html">WebGLObject</a>&gt; renderList, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> reverse, <a href="http://api.dartlang.org/dart_core/String.html">String</a> materialType, <a href="../three/WebGLCamera.html">WebGLCamera</a> camera, <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../three/Light.html">Light</a>&gt; lights, fog, useBlending, [overrideMaterial = null]) <a class="anchor-link" href="#renderObjects"
              title="Permalink to WebGLRenderer.renderObjects">#</a></h4>
<div class="doc">
<pre class="source">
renderObjects (  List&lt;WebGLObject&gt;renderList,
	                 bool reverse, String materialType,
	                 WebGLCamera camera,
	                 List&lt;Light&gt; lights,
	                 fog,
	                 useBlending,
	                 [overrideMaterial = null] ) {

		WebGLObject webglObject;
		var object, buffer, material;
		num start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i != end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial != null ) {

					material = overrideMaterial;

				} else {

					material = (materialType == "opaque")? webglObject.opaque : webglObject.transparent;

					if ( material == null ) continue;

					if ( useBlending ) setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					setDepthTest( material.depthTest );
					setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				setMaterialFaces( material );

				if ( buffer.isBufferGeometry ) {

					renderBufferDirect( camera, lights, fog, material, buffer, webglObject );

				} else {

					renderBuffer( camera, lights, fog, material, buffer, webglObject );

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderObjectsImmediate">
<button class="show-code">Code</button>
dynamic <strong>renderObjectsImmediate</strong>(renderList, materialType, camera, lights, fog, useBlending, [overrideMaterial]) <a class="anchor-link" href="#renderObjectsImmediate"
              title="Permalink to WebGLRenderer.renderObjectsImmediate">#</a></h4>
<div class="doc">
<pre class="source">
renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, [overrideMaterial] ) {

		var webglObject, object, material, program, il;

		il = renderList.length;

		for ( var i = 0; i &lt; il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					setDepthTest( material.depthTest );
					setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderPlugins">
<button class="show-code">Code</button>
dynamic <strong>renderPlugins</strong>(plugins, scene, camera) <a class="anchor-link" href="#renderPlugins"
              title="Permalink to WebGLRenderer.renderPlugins">#</a></h4>
<div class="doc">
<pre class="source">
renderPlugins( plugins, scene, camera ) {

		plugins.forEach((plugin) {
			// reset state for plugin (to start from clean slate)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

			plugin.render( scene, camera._camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

		});

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setBlending">
<button class="show-code">Code</button>
dynamic <strong>setBlending</strong>(blending, [blendEquation, blendSrc, blendDst]) <a class="anchor-link" href="#setBlending"
              title="Permalink to WebGLRenderer.setBlending">#</a></h4>
<div class="doc">
<pre class="source">
setBlending( blending, [blendEquation, blendSrc, blendDst] ) {

		if ( blending != _oldBlending ) {

			if ( blending == NoBlending ) {

				_gl.disable( gl.BLEND );

			} else if ( blending == AdditiveBlending ) {

				_gl.enable( gl.BLEND );
				_gl.blendEquation( gl.FUNC_ADD );
				_gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

			} else if ( blending == SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( gl.BLEND );
				_gl.blendEquation( gl.FUNC_ADD );
				_gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending == MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( gl.BLEND );
				_gl.blendEquation( gl.FUNC_ADD );
				_gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

			} else if ( blending == CustomBlending ) {

				_gl.enable( gl.BLEND );

			} else {

				_gl.enable( gl.BLEND );
				_gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
				_gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending == CustomBlending ) {

			if ( blendEquation != _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc != _oldBlendSrc || blendDst != _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setClearColor">
<button class="show-code">Code</button>
dynamic <strong>setClearColor</strong>(color, alpha) <a class="anchor-link" href="#setClearColor"
              title="Permalink to WebGLRenderer.setClearColor">#</a></h4>
<div class="doc">
<pre class="source">
setClearColor( color, alpha ) {

		_clearColor.copy( color );
		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setClearColorHex">
<button class="show-code">Code</button>
dynamic <strong>setClearColorHex</strong>(hex, alpha) <a class="anchor-link" href="#setClearColorHex"
              title="Permalink to WebGLRenderer.setClearColorHex">#</a></h4>
<div class="doc">
<pre class="source">
setClearColorHex( hex, alpha ) {

		_clearColor.setHex( hex );
		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setColorGamma">
<button class="show-code">Code</button>
dynamic <strong>setColorGamma</strong>(array, offset, color, intensitySq) <a class="anchor-link" href="#setColorGamma"
              title="Permalink to WebGLRenderer.setColorGamma">#</a></h4>
<div class="doc">
<pre class="source">
setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setColorLinear">
<button class="show-code">Code</button>
dynamic <strong>setColorLinear</strong>(array, offset, color, intensity) <a class="anchor-link" href="#setColorLinear"
              title="Permalink to WebGLRenderer.setColorLinear">#</a></h4>
<div class="doc">
<pre class="source">
setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setCubeTexture">
<button class="show-code">Code</button>
dynamic <strong>setCubeTexture</strong>(<a href="../three/Texture.html">Texture</a> texture, slot) <a class="anchor-link" href="#setCubeTexture"
              title="Permalink to WebGLRenderer.setCubeTexture">#</a></h4>
<div class="doc">
<pre class="source">
setCubeTexture ( Texture texture, slot ) {

		if ( texture.image.length == 6 ) {
		  if(texture.image is ImageList){
		    texture.image = new WebGLImageList(texture.image);
		  }
			if ( texture.needsUpdate ) {

				if ( texture.image.webglTextureCube == null ) {

					texture.image.webglTextureCube = _gl.createTexture();

					info.memory.textures ++;
				}

				_gl.activeTexture( gl.TEXTURE0 + slot );
				_gl.bindTexture( gl.TEXTURE_CUBE_MAP, texture.image.webglTextureCube);

				_gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, (texture.flipY) ? 1 : 0 );

				var isCompressed = texture is CompressedTexture;

				var cubeImage = new List(6);

				for ( var i = 0; i &lt; 6; i ++ ) {

					if ( autoScaleCubemaps &amp;&amp; ! isCompressed ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], maxCubemapSize );

					} else {

						cubeImage[ i ] = texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( (image as dynamic).width ) &amp;&amp; isPowerOfTwo( (image as dynamic).height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i &lt; 6; i ++ ) {

					if ( isCompressed ) {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for( var j = 0, jl = mipmaps.length; j &lt; jl; j ++ ) {

							mipmap = mipmaps[ j ];
							_gl.compressedTexImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						}

					} else {

						_gl.texImage2DImage( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

					}

				}

				if ( texture.generateMipmaps &amp;&amp; isImagePowerOfTwo ) {

					_gl.generateMipmap( gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate != null) texture.onUpdate();

			} else {

				_gl.activeTexture( gl.TEXTURE0 + slot );
				_gl.bindTexture( gl.TEXTURE_CUBE_MAP, texture.image.webglTextureCube );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setCubeTextureDynamic">
<button class="show-code">Code</button>
dynamic <strong>setCubeTextureDynamic</strong>(texture, slot) <a class="anchor-link" href="#setCubeTextureDynamic"
              title="Permalink to WebGLRenderer.setCubeTextureDynamic">#</a></h4>
<div class="doc">
<pre class="source">
setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( gl.TEXTURE0 + slot );
		_gl.bindTexture( gl.TEXTURE_CUBE_MAP, texture["__webglTexture"] );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setDefaultGLState">
<button class="show-code">Code</button>
dynamic <strong>setDefaultGLState</strong>() <a class="anchor-link" href="#setDefaultGLState"
              title="Permalink to WebGLRenderer.setDefaultGLState">#</a></h4>
<div class="doc">
<pre class="source">
setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( gl.DEPTH_TEST );
		_gl.depthFunc( gl.LEQUAL );

		_gl.frontFace( gl.CCW );
		_gl.cullFace( gl.BACK );
		_gl.enable( gl.CULL_FACE );

		_gl.enable( gl.BLEND );
		_gl.blendEquation( gl.FUNC_ADD );
		_gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setDepthTest">
<button class="show-code">Code</button>
dynamic <strong>setDepthTest</strong>(depthTest) <a class="anchor-link" href="#setDepthTest"
              title="Permalink to WebGLRenderer.setDepthTest">#</a></h4>
<div class="doc">
<pre class="source">
setDepthTest( depthTest ) {

		if ( _oldDepthTest != depthTest ) {

			if ( depthTest ) {

				_gl.enable( gl.DEPTH_TEST );

			} else {

				_gl.disable( gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setDepthWrite">
<button class="show-code">Code</button>
dynamic <strong>setDepthWrite</strong>(depthWrite) <a class="anchor-link" href="#setDepthWrite"
              title="Permalink to WebGLRenderer.setDepthWrite">#</a></h4>
<div class="doc">
<pre class="source">
setDepthWrite( depthWrite ) {

		if ( _oldDepthWrite != depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setDirectBuffers">
<button class="show-code">Code</button>
dynamic <strong>setDirectBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> webglgeometry, <a href="http://api.dartlang.org/dart_core/int.html">int</a> hint, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> dispose) <a class="anchor-link" href="#setDirectBuffers"
              title="Permalink to WebGLRenderer.setDirectBuffers">#</a></h4>
<div class="doc">
<pre class="source">
setDirectBuffers ( WebGLGeometry webglgeometry, int hint, bool dispose ) {

	  BufferGeometry geometry = webglgeometry._geometry;

		var attributes = geometry.attributes;

		var index = geometry.aIndex;
		var position = geometry.aPosition;
		var normal = geometry.aNormal;
		var uv = geometry.aUV;
		var color = geometry.aColor;
		var tangent = geometry.aTangent;

		if ( webglgeometry.elementsNeedUpdate &amp;&amp; index != null ) {

			index.buffer.bind( gl.ELEMENT_ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ELEMENT_ARRAY_BUFFER, index.array, hint );

		}

		if ( webglgeometry.verticesNeedUpdate &amp;&amp; position != null ) {

			position.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, position.array, hint );

		}

		if ( webglgeometry.normalsNeedUpdate &amp;&amp; normal != null ) {

			normal.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, normal.array, hint );

		}

		if ( webglgeometry.uvsNeedUpdate &amp;&amp; uv != null ) {

			uv.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, uv.array, hint );

		}

		if ( webglgeometry.colorsNeedUpdate &amp;&amp; color != null ) {

			color.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, color.array, hint );

		}

		if ( webglgeometry.tangentsNeedUpdate &amp;&amp; tangent != null ) {

			tangent.buffer.bind( gl.ARRAY_BUFFER );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, tangent.array, hint );

		}

		if ( dispose ) {

		  geometry.attributes.forEach((_, attribute) {
			 attribute.array = null; //delete geometry.attributes[ i ].array;
			});

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setFaceCulling">
<button class="show-code">Code</button>
dynamic <strong>setFaceCulling</strong>(cullFace, frontFaceDirection) <a class="anchor-link" href="#setFaceCulling"
              title="Permalink to WebGLRenderer.setFaceCulling">#</a></h4>
<div class="doc">
<pre class="source">
setFaceCulling( cullFace, frontFaceDirection ) {

		if ( cullFace == CullFaceNone ) {

			_gl.disable( gl.CULL_FACE );

		} else {

			if ( frontFaceDirection == FrontFaceDirectionCW ) {

				_gl.frontFace( gl.CW );

			} else {

				_gl.frontFace( gl.CCW );

			}

			if ( cullFace == CullFaceBack ) {

				_gl.cullFace( gl.BACK );

			} else if ( cullFace == CullFaceFront ) {

				_gl.cullFace( gl.FRONT );

			} else {

				_gl.cullFace( gl.FRONT_AND_BACK );

			}

			_gl.enable( gl.CULL_FACE );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setLineBuffers">
<button class="show-code">Code</button>
dynamic <strong>setLineBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry, hint) <a class="anchor-link" href="#setLineBuffers"
              title="Permalink to WebGLRenderer.setLineBuffers">#</a></h4>
<div class="doc">
<pre class="source">
setLineBuffers ( WebGLGeometry geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c &lt; cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d &lt; dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes != null ) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &amp;&amp;
					 ( customAttribute.boundTo == null ||
					   customAttribute.boundTo == "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size == 1 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size == 2 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size == 3 ) {

						if ( customAttribute.type == "c" ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size == 4 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					customAttribute.buffer.bind( gl.ARRAY_BUFFER );
					_gl.bufferDataTyped( gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setLineWidth">
<button class="show-code">Code</button>
dynamic <strong>setLineWidth</strong>(width) <a class="anchor-link" href="#setLineWidth"
              title="Permalink to WebGLRenderer.setLineWidth">#</a></h4>
<div class="doc">
<pre class="source">
setLineWidth ( width ) {

		if ( width != _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setMaterialFaces">
<button class="show-code">Code</button>
dynamic <strong>setMaterialFaces</strong>(material) <a class="anchor-link" href="#setMaterialFaces"
              title="Permalink to WebGLRenderer.setMaterialFaces">#</a></h4>
<div class="doc">
<pre class="source">
setMaterialFaces( material ) {

		var doubleSided = material.side == DoubleSide;
		var flipSided = material.side == BackSide;

		if ( _oldDoubleSided != doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( gl.CULL_FACE );

			} else {

				_gl.enable( gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided != flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( gl.CW );

			} else {

				_gl.frontFace( gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setMaterialShaders">
<button class="show-code">Code</button>
dynamic <strong>setMaterialShaders</strong>(<a href="../three/WebGLMaterial.html">WebGLMaterial</a> material, shaders) <a class="anchor-link" href="#setMaterialShaders"
              title="Permalink to WebGLRenderer.setMaterialShaders">#</a></h4>
<div class="doc">
<pre class="source">
setMaterialShaders( WebGLMaterial material, shaders ) {

		material.uniforms = UniformsUtils.clone( shaders["uniforms"] );
		material.vertexShader = shaders["vertexShader"];
		material.fragmentShader = shaders["fragmentShader"];

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setMeshBuffers">
<button class="show-code">Code</button>
dynamic <strong>setMeshBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometryGroup, <a href="../three/WebGLObject.html">WebGLObject</a> object, hint, dispose, material) <a class="anchor-link" href="#setMeshBuffers"
              title="Permalink to WebGLRenderer.setMeshBuffers">#</a></h4>
<div class="doc">
<pre class="source">
setMeshBuffers( WebGLGeometry geometryGroup, WebGLObject object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType == SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.webglgeometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		chunk_faces4 = geometryGroup.faces4,
		obj_faces = geometry.faces,

		obj_uvs  = (geometry.faceVertexUvs.length == 0) ? [] : geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = (geometry.faceVertexUvs.length &gt; 1) ? geometry.faceVertexUvs[ 1 ] : null,

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;


		if ( dirtyVertices ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];
				v4 = vertices[ face.d ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				vertexArray[ offset + 9 ]  = v4.x;
				vertexArray[ offset + 10 ] = v4.y;
				vertexArray[ offset + 11 ] = v4.z;

				offset += 12;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, vertexArray, hint);

		}

		if ( dirtyMorphTargets ) {

			vkl = morphTargets.length;
			for ( vk = 0; vk &lt; vkl; vk ++ ) {

				offset_morphTarget = 0;

				fl = chunk_faces3.length;
				for ( f = 0; f &lt; fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				fl = chunk_faces4.length;
				for ( f = 0; f &lt; fl; f ++ ) {

					chf = chunk_faces4[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];
					v4 = morphTargets[ vk ].vertices[ face.d ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					vka[ offset_morphTarget + 9 ]  = v4.x;
					vka[ offset_morphTarget + 10 ] = v4.y;
					vka[ offset_morphTarget + 11 ] = v4.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;
							n4 = faceVertexNormals.d;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;
							n4 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

						nka[ offset_morphTarget + 9 ]  = n4.x;
						nka[ offset_morphTarget + 10 ] = n4.y;
						nka[ offset_morphTarget + 11 ] = n4.z;

					}

					//

					offset_morphTarget += 12;

				}

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferDataTyped( gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( !obj_skinWeights.isEmpty) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];
				sw4 = obj_skinWeights[ face.d ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				skinWeightArray[ offset_skin + 12 ] = sw4.x;
				skinWeightArray[ offset_skin + 13 ] = sw4.y;
				skinWeightArray[ offset_skin + 14 ] = sw4.z;
				skinWeightArray[ offset_skin + 15 ] = sw4.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];
				si4 = obj_skinIndices[ face.d ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				skinIndexArray[ offset_skin + 12 ] = si4.x;
				skinIndexArray[ offset_skin + 13 ] = si4.y;
				skinIndexArray[ offset_skin + 14 ] = si4.z;
				skinIndexArray[ offset_skin + 15 ] = si4.w;

				offset_skin += 16;

			}

			if ( offset_skin &gt; 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors &amp;&amp; vertexColorType) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length == 3 &amp;&amp; vertexColorType == VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length == 4 &amp;&amp; vertexColorType == VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];
					c4 = vertexColors[ 3 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;
					c4 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				colorArray[ offset_color + 9 ]  = c4.r;
				colorArray[ offset_color + 10 ] = c4.g;
				colorArray[ offset_color + 11 ] = c4.b;

				offset_color += 12;

			}

			if ( offset_color &gt; 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents &amp;&amp; geometry.hasTangents ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];
				t4 = vertexTangents[ 3 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				tangentArray[ offset_tangent + 12 ] = t4.x;
				tangentArray[ offset_tangent + 13 ] = t4.y;
				tangentArray[ offset_tangent + 14 ] = t4.z;
				tangentArray[ offset_tangent + 15 ] = t4.w;

				offset_tangent += 16;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals &amp;&amp; (normalType != NoShading) ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length == 3 &amp;&amp; needsSmoothNormals ) {

					for ( i = 0; i &lt; 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i &lt; 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length == 4 &amp;&amp; needsSmoothNormals ) {

					for ( i = 0; i &lt; 4; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i &lt; 4; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs &amp;&amp; !obj_uvs.isEmpty &amp;&amp; uvType ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv == null ) continue;

				for ( i = 0; i &lt; 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.u;
					uvArray[ offset_uv + 1 ] = uvi.v;

					offset_uv += 2;

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces4[ f ];

				uv = obj_uvs[ fi ];

				if ( uv == null ) continue;

				for ( i = 0; i &lt; 4; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.u;
					uvArray[ offset_uv + 1 ] = uvi.v;

					offset_uv += 2;

				}

			}

			if ( offset_uv &gt; 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs &amp;&amp; (obj_uvs2 != null) &amp;&amp; uvType ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 == null ) continue;

				for ( i = 0; i &lt; 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.u;
					uv2Array[ offset_uv2 + 1 ] = uv2i.v;

					offset_uv2 += 2;

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces4[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 == null ) continue;

				for ( i = 0; i &lt; 4; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.u;
					uv2Array[ offset_uv2 + 1 ] = uv2i.v;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 &gt; 0 ) {

				_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferDataTyped( gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			 fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				faceArray[ offset_face ]     = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 3;

				faceArray[ offset_face + 3 ] = vertexIndex + 1;
				faceArray[ offset_face + 4 ] = vertexIndex + 2;
				faceArray[ offset_face + 5 ] = vertexIndex + 3;

				offset_face += 6;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 3;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				lineArray[ offset_line + 6 ] = vertexIndex + 2;
				lineArray[ offset_line + 7 ] = vertexIndex + 3;

				offset_line += 8;

				vertexIndex += 4;

			}

			_gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferDataTyped( gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferDataTyped( gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes != null) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size == 1 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
							customAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];

							offset_custom += 4;

						}

					} else if ( customAttribute.boundTo == "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;
							customAttribute.array[ offset_custom + 3 ] = value;

							offset_custom += 4;

						}

					}

				} else if ( customAttribute.size == 2 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					} else if ( customAttribute.boundTo == "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					}

				} else if ( customAttribute.size == 3 ) {

					var pp;

					if ( customAttribute.type == "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo == "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo == "faceVertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];
							v4 = value[ 3 ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					}

				} else if ( customAttribute.size == 4 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo == "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo == "faceVertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];
							v4 = value[ 3 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					}

				}

				customAttribute.buffer.bind(gl.ARRAY_BUFFER);

      		_gl.bufferDataTyped(gl.ARRAY_BUFFER, customAttribute.array, hint);

			}

		}

		if ( dispose ) {

			geometryGroup.__inittedArrays = false; //delete geometryGroup.__inittedArrays"];
			geometryGroup.__colorArray = null; //delete geometryGroup.__colorArray"];
			geometryGroup.__normalArray = null; //delete geometryGroup.__normalArray"];
			geometryGroup.__tangentArray = null; //delete geometryGroup.__tangentArray"];
			geometryGroup.__uvArray = null; //delete geometryGroup.__uvArray"];
			geometryGroup.__uv2Array = null; //delete geometryGroup.__uv2Array"];
			geometryGroup.__faceArray = null; //delete geometryGroup.__faceArray"];
			geometryGroup.__vertexArray = null; //delete geometryGroup.__vertexArray"];
			geometryGroup.__lineArray = null; //delete geometryGroup.__lineArray"];
			geometryGroup.__skinIndexArray = null; //delete geometryGroup.__skinIndexArray"];
			geometryGroup.__skinWeightArray = null; //delete geometryGroup.__skinWeightArray"];

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setParticleBuffers">
<button class="show-code">Code</button>
dynamic <strong>setParticleBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry, hint, object) <a class="anchor-link" href="#setParticleBuffers"
              title="Permalink to WebGLRenderer.setParticleBuffers">#</a></h4>
<div class="doc">
<pre class="source">
setParticleBuffers ( WebGLGeometry geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.setFrom( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.setFrom(vertex);
				_vector3.applyProjection(_projScreenMatrixPS);

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c &lt; cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes != null ) {

				il = customAttributes.length;
				for ( i = 0; i &lt; il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size == 1 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size == 2 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size == 3 ) {

						if ( customAttribute.type == "c" ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size == 4 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v &lt; vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c &lt; cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes != null) {

				il = customAttributes.length;
				for ( i = 0; i &lt; il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &amp;&amp;
						 ( customAttribute.boundTo == null ||
						   customAttribute.boundTo == "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size == 1 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size == 2 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size == 3 ) {

							if ( customAttribute.type == "c" ) {

								for ( ca = 0; ca &lt; cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca &lt; cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size == 4 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes != null) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					customAttribute.buffer.bind( gl.ARRAY_BUFFER );
					_gl.bufferDataTyped( gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	}
</pre>
</div>
</div>
<div class="method"><h4 id="setPolygonOffset">
<button class="show-code">Code</button>
dynamic <strong>setPolygonOffset</strong>(polygonoffset, factor, units) <a class="anchor-link" href="#setPolygonOffset"
              title="Permalink to WebGLRenderer.setPolygonOffset">#</a></h4>
<div class="doc">
<pre class="source">
setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset != polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset &amp;&amp; ( _oldPolygonOffsetFactor != factor || _oldPolygonOffsetUnits != units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setProgram">
<button class="show-code">Code</button>
dynamic <strong>setProgram</strong>(<a href="../three/WebGLCamera.html">WebGLCamera</a> camera, <a href="http://api.dartlang.org/dart_core/List.html">List</a> lights, <a href="../three/Fog.html">Fog</a> fog, <a href="../three/WebGLMaterial.html">WebGLMaterial</a> material, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#setProgram"
              title="Permalink to WebGLRenderer.setProgram">#</a></h4>
<div class="doc">
<pre class="source">
setProgram( WebGLCamera camera, List lights, Fog fog, WebGLMaterial material, WebGLObject object ) {

	  _usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program != null ) deallocateMaterial( material );

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( object.__webglMorphTargetInfluences == null) {

				object.__webglMorphTargetInfluences = new Float32List( maxMorphTargets );

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

  if ( !identical(program, _currentProgram) ) {

			_gl.useProgram( program.glProgram );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id != _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

  if ( refreshMaterial || !identical(camera, _currentCamera) ) {

			_gl.uniformMatrix4fv( p_uniforms["projectionMatrix"], false, camera.projectionMatrix.storage );

    if ( !identical(camera, _currentCamera) ) _currentCamera = camera;

		}


		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( supportsBoneTextures &amp;&amp; object.useVertexTexture ) {

				if ( p_uniforms.boneTexture != null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					setTexture( object.boneTexture, textureUnit );

				}

			} else {

				if ( p_uniforms.boneGlobalMatrices != null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( (fog != null) &amp;&amp; material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material.isMeshPhongMaterial ||
				 material.isMeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					setupLights( program, lights );
					_lightsNeedUpdate = false;

				}

				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material.isMeshBasicMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isMeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			// TODO - Implement LineDashedMaterial
			//} else if ( material instanceof THREE.LineDashedMaterial ) {

			//	refreshUniformsLine( m_uniforms, material );
			//	refreshUniformsDash( m_uniforms, material );

			} else if ( material.isParticleBasicMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				m_uniforms["mNear"].value = camera.near;
				m_uniforms["mFar"].value = camera.far;
				m_uniforms["opacity"].value = material.opacity;

			} else if ( material.isMeshNormalMaterial ) {

				m_uniforms["opacity"].value = material.opacity;

			}

			if ( object.receiveShadow &amp;&amp; ! material.shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				 material.isMeshPhongMaterial ||
				 (material.envMap != null) ) {

				if ( p_uniforms["cameraPosition"] != null ) {

					_vector3 = camera.matrixWorld.getTranslation();
					_gl.uniform3f( p_uniforms["cameraPosition"], _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material.isMeshPhongMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms["viewMatrix"] != null ) {

					_gl.uniformMatrix4fv( p_uniforms["viewMatrix"], false, camera.matrixWorldInverse.storage );

				}

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms["modelMatrix"] != null ) {

			_gl.uniformMatrix4fv( p_uniforms["modelMatrix"], false, object.matrixWorld.storage );

		}

		return program;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setRenderTarget">
<button class="show-code">Code</button>
dynamic <strong>setRenderTarget</strong>(<a href="../three/WebGLRenderTarget.html">WebGLRenderTarget</a> renderTarget) <a class="anchor-link" href="#setRenderTarget"
              title="Permalink to WebGLRenderer.setRenderTarget">#</a></h4>
<div class="doc">
<pre class="source">
setRenderTarget ( WebGLRenderTarget renderTarget ) {

		var isCube = ( renderTarget is WebGLRenderTargetCube );

		if ( (renderTarget != null ) &amp;&amp; ( renderTarget.__webglFramebuffer == null) ) {

			if ( renderTarget.depthBuffer == null ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer == null ) renderTarget.stencilBuffer = true;

			//renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) &amp;&amp; isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i &lt; 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2DTyped( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom != null ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2DTyped( gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom != null) {

					if ( renderTarget.depthBuffer &amp;&amp; ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget != null ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ (renderTarget as WebGLRenderTargetCube).activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

  if ( !identical(framebuffer, _currentFramebuffer) ) {

			_gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setRibbonBuffers">
<button class="show-code">Code</button>
dynamic <strong>setRibbonBuffers</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry, hint) <a class="anchor-link" href="#setRibbonBuffers"
              title="Permalink to WebGLRenderer.setRibbonBuffers">#</a></h4>
<div class="doc">
<pre class="source">
setRibbonBuffers ( WebGLGeometry geometry, hint ) {

		var v, c, n, vertex, offset, color, normal,

		i, il, ca, cal, customAttribute, value,

		vertices = geometry.vertices,
		colors = geometry.colors,
		normals = geometry.normals,

		vl = vertices.length,
		cl = colors.length,
		nl = normals.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		normalArray = geometry.__normalArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList;

		if ( dirtyVertices ) {

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c &lt; cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyNormals ) {

			for ( n = 0; n &lt; nl; n ++ ) {

				normal = normals[ n ];

				offset = n * 3;

				normalArray[ offset ]     = normal.x;
				normalArray[ offset + 1 ] = normal.y;
				normalArray[ offset + 2 ] = normal.z;

			}

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometry.__webglNormalBuffer );
			_gl.bufferDataTyped( gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( customAttributes ) {

			for ( var i = 0, il = customAttributes.length; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &amp;&amp;
					 ( customAttribute.boundTo == null ||
					   customAttribute.boundTo == "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size == 1 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size == 2 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size == 3 ) {

						if ( customAttribute.type == "c" ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size == 4 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					customAttribute.buffer.bind( gl.ARRAY_BUFFER );
					_gl.bufferDataTyped( gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setScissor">
<button class="show-code">Code</button>
dynamic <strong>setScissor</strong>(x, y, width, height) <a class="anchor-link" href="#setScissor"
              title="Permalink to WebGLRenderer.setScissor">#</a></h4>
<div class="doc">
<pre class="source">
setScissor( x, y, width, height ) {
		_gl.scissor( x, y, width, height );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="setSize">
<button class="show-code">Code</button>
dynamic <strong>setSize</strong>(width, height) <a class="anchor-link" href="#setSize"
              title="Permalink to WebGLRenderer.setSize">#</a></h4>
<div class="doc">
<pre class="source">
setSize( width, height ) {
		canvas.width = (width * devicePixelRatio).toInt();
		canvas.height = (height * devicePixelRatio).toInt();

		canvas.style.width = "${width}px";
		canvas.style.height = "${height}px";

		setViewport( 0, 0, canvas.width, canvas.height );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setTexture">
<button class="show-code">Code</button>
dynamic <strong>setTexture</strong>(<a href="../three/Texture.html">Texture</a> texture, slot) <a class="anchor-link" href="#setTexture"
              title="Permalink to WebGLRenderer.setTexture">#</a></h4>
<div class="doc">
<pre class="source">
setTexture( Texture texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( texture["__webglInit"] == null ) {

				texture["__webglInit"] = true;

				//texture.addEventListener( 'dispose', onTextureDispose );

				texture["__webglTexture"] = _gl.createTexture();

				info.memory.textures ++;

			}

			_gl.activeTexture( gl.TEXTURE0 + slot );
			_gl.bindTexture( gl.TEXTURE_2D, texture["__webglTexture"] );

			_gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, (texture.flipY) ? 1 : 0 );
			_gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, (texture.premultiplyAlpha) ? 1 : 0 );
			_gl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = texture.image,
			isImagePowerOfTwo = isPowerOfTwo( image.width ) &amp;&amp; isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture is DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length &gt; 0 &amp;&amp; isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2DTyped( gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2DTyped( gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture is CompressedTexture ) {

				// compressed textures can only use manually created mipmaps
				// WebGL can't generate mipmaps for DDS textures

				for( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.compressedTexImage2D( gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

				}

			} else {// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length &gt; 0 &amp;&amp; isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else if ( texture.image is ImageElement) {

					_gl.texImage2DImage( gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				} else if ( texture.image is CanvasElement ) {

				  _gl.texImage2DCanvas( gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				} else if ( texture.image is VideoElement ) {

				  _gl.texImage2DVideo( gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps &amp;&amp; isImagePowerOfTwo ) _gl.generateMipmap( gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate != null ) texture.onUpdate();

		} else {

			_gl.activeTexture( gl.TEXTURE0 + slot );
			_gl.bindTexture( gl.TEXTURE_2D, texture["__webglTexture"] );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setTextureParameters">
<button class="show-code">Code</button>
dynamic <strong>setTextureParameters</strong>(textureType, texture, isImagePowerOfTwo) <a class="anchor-link" href="#setTextureParameters"
              title="Permalink to WebGLRenderer.setTextureParameters">#</a></h4>
<div class="doc">
<pre class="source">
setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		if ( (_glExtensionTextureFilterAnisotropic != null) &amp;&amp; texture.type != FloatType ) {

			if ( texture.anisotropy &gt; 1 || ( texture["__oldAnisotropy"] != null) ) {

				_gl.texParameterf( textureType, gl.ExtTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, maxAnisotropy ) );
				texture["__oldAnisotropy"] = texture.anisotropy;

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupFrameBuffer">
<button class="show-code">Code</button>
dynamic <strong>setupFrameBuffer</strong>(framebuffer, renderTarget, textureTarget) <a class="anchor-link" href="#setupFrameBuffer"
              title="Permalink to WebGLRenderer.setupFrameBuffer">#</a></h4>
<div class="doc">
<pre class="source">
setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupLights">
<button class="show-code">Code</button>
dynamic <strong>setupLights</strong>(<a href="../three/Program.html">Program</a> program, <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../three/Light.html">Light</a>&gt; lights) <a class="anchor-link" href="#setupLights"
              title="Permalink to WebGLRenderer.setupLights">#</a></h4>
<div class="doc">
<pre class="source">
setupLights ( Program program, List&lt;Light&gt; lights ) {

		var l, ll, light, n,
		r = 0.0, g = 0.0, b = 0.0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights;

		List dirColors = zlights["directional"]["colors"],
		     dirPositions = zlights["directional"]["positions"],

		     pointColors = zlights["point"]["colors"],
		     pointPositions = zlights["point"]["positions"],
    	 pointDistances = zlights["point"]["distances"],

    	 spotColors = zlights["spot"]["colors"],
    	 spotPositions = zlights["spot"]["positions"],
    	 spotDistances = zlights["spot"]["distances"],
    	 spotDirections = zlights["spot"]["directions"],
    	 spotAnglesCos = zlights["spot"]["anglesCos"],
    	 spotExponents = zlights["spot"]["exponents"],

    	 hemiSkyColors = zlights["hemi"]["skyColors"],
		 hemiGroundColors = zlights["hemi"]["groundColors"],
		 hemiPositions = zlights["hemi"]["positions"];

		var dirLength = 0,
  		pointLength = 0,
  		spotLength = 0,
 			hemiLength = 0,

			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,

  		dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l ++ ) {

			light = lights[ l ];

			// TODO - Setup proper interfaces for Light to avoid type checks
			if ( (((light is DirectionalLight) || (light is SpotLight)) &amp;&amp; (light as dynamic).onlyShadow) ||
			    ! light.visible ) { continue;
			}

			color = light.color;

			if ( (light is DirectionalLight) || (light is SpotLight) || (light is PointLight)) {
			intensity = (light as dynamic).intensity;
			distance = (light as dynamic).distance;
			}

			if ( light is AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light is DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction = light.matrixWorld.getTranslation();
				_vector3 = light.target.matrixWorld.getTranslation();
				_direction.sub(_vector3);
				_direction.normalize();

				 // skip lights with undefined direction
      // these create troubles in OpenGL (making pixel black)

      if (_direction.x == 0 &amp;&amp; _direction.y == 0 &amp;&amp; _direction.z == 0)
        continue;

      dirOffset = dirLength * 3;

      // Grow the lists
      dirColors.length = dirOffset + 3;
      dirPositions.length = dirOffset + 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;


				if ( gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if( light is PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

      		// Grow the lists
				pointColors.length = pointOffset + 3;
				pointPositions.length = pointOffset + 3;

				if ( gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				position = light.matrixWorld.getTranslation();

				pointPositions[ pointOffset ]     = position.x;
				pointPositions[ pointOffset + 1 ] = position.y;
				pointPositions[ pointOffset + 2 ] = position.z;

				if (pointDistances==null) { pointDistances = new List(); pointDistances.add(0); }
				if (pointDistances.length == 0) {pointDistances.add(0);}
				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if( light is SpotLight ) {

				spotCount += 1;

				spotOffset = spotLength * 3;

				if ( ! light.visible ) continue;

      		// Grow the lists
				spotColors.length = spotOffset + 3;
				spotPositions.length = spotOffset + 3;
				spotDirections.length = spotOffset + 3;
				spotDistances.length = spotLength + 1;

				if ( gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				position = light.matrixWorld.getTranslation();

				spotPositions[ spotOffset ]     = position.x;
				spotPositions[ spotOffset + 1 ] = position.y;
				spotPositions[ spotOffset + 2 ] = position.z;

				spotDistances[ spotLength ] = distance;

				_direction.setFrom( position );
				_direction.sub( light.target.matrixWorld.getTranslation() );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				// grow the arrays
				spotAnglesCos.length = spotLength + 1;
				spotExponents.length = spotLength + 1;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light is HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				position = light.matrixWorld.getTranslation();
				_direction.setFrom( position );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x == 0 &amp;&amp; _direction.y == 0 &amp;&amp; _direction.z == 0 ) continue;

				hemiOffset = hemiLength * 3;

				// Grow the lists
				hemiSkyColors.length = hemiOffset + 3;
				hemiGroundColors.length = hemiOffset + 3;
				hemiPositions.length = hemiOffset + 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		ll =  Math.max( dirColors.length, dirCount * 3 );
		for ( l = dirLength * 3; l &lt; ll; l ++ ) dirColors[ l ] = 0.0;
		ll = Math.max( pointColors.length, pointCount * 3 );
		for ( l = pointLength * 3; l &lt; ll; l ++ ) pointColors[ l ] = 0.0;
		ll = Math.max( spotColors.length, spotCount * 3 );
		for ( l = spotLength * 3; l &lt; ll; l ++ ) spotColors[ l ] = 0.0;
		ll = Math.max( hemiSkyColors.length, hemiCount * 3 );
		for ( l = hemiLength * 3; l &lt; ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		ll = Math.max( hemiGroundColors.length, hemiCount * 3 );
		for ( l = hemiLength * 3; l &lt; ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights["directional"]["length"] = dirLength;
		zlights["point"]["length"] = pointLength;
		zlights["spot"]["length"] = spotLength;
		zlights["hemi"]["length"] = hemiLength;

		zlights["ambient"][ 0 ] = r;
		zlights["ambient"][ 1 ] = g;
		zlights["ambient"][ 2 ] = b;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupMatrices">
<button class="show-code">Code</button>
dynamic <strong>setupMatrices</strong>(<a href="../three/WebGLObject.html">WebGLObject</a> object, <a href="../three/WebGLCamera.html">WebGLCamera</a> camera) <a class="anchor-link" href="#setupMatrices"
              title="Permalink to WebGLRenderer.setupMatrices">#</a></h4>
<div class="doc">
<pre class="source">
setupMatrices ( WebGLObject object, WebGLCamera camera ) {

		object._modelViewMatrix = camera.matrixWorldInverse * object.matrixWorld;

		object._normalMatrix = calcInverse( object._modelViewMatrix );
		object._normalMatrix.transpose();

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupMorphTargets">
<button class="show-code">Code</button>
dynamic <strong>setupMorphTargets</strong>(material, <a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometryGroup, <a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#setupMorphTargets"
              title="Permalink to WebGLRenderer.setupMorphTargets">#</a></h4>
<div class="doc">
<pre class="source">
setupMorphTargets ( material, WebGLGeometry geometryGroup, WebGLObject object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase != -1 &amp;&amp; attributes["position"] &gt;= 0) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes["position"] );
			_gl.vertexAttribPointer( attributes["position"], 3, gl.FLOAT, false, 0, 0 );

		} else if ( attributes["position"] &gt;= 0 ) {

			_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes["position"] );
			_gl.vertexAttribPointer( attributes["position"], 3, gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length &gt; 0) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m &lt; material.numSupportedMorphTargets &amp;&amp; m &lt; order.length ) {

				if ( attributes[ "morphTarget" + m ] &gt;= 0 ) {
					_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphTarget" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget$m"], 3, gl.FLOAT, false, 0, 0 );
				}

				if ( attributes[ "morphNormal" + m ] &gt;= 0 &amp;&amp; material.morphNormals ) {

					_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphNormal" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphNormal$m" ], 3, gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ].toDouble();

				m ++;
			}

		} else {

			// find the most influencing

			var influence;
			List&lt;List&gt; activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i &lt; il; i ++ ) {

				influence = influences[ i ];

				if ( influence &gt; 0 ) {

					activeInfluenceIndices.add( [ i, influence ] );

				}

			}

			if ( activeInfluenceIndices.length &gt; material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length &gt; material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length == 0 ) {

				activeInfluenceIndices.add( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m &lt; material.numSupportedMorphTargets ) {

				if ( m &lt; activeInfluenceIndices.length &amp;&amp; activeInfluenceIndices[ m ] != null &amp;&amp; !activeInfluenceIndices[ m ].isEmpty) {

					influenceIndex = activeInfluenceIndices[ m ][ 0 ];

					_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
					enableAttribute( attributes[ "morphTarget$m" ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget$m" ], 3, gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.bindBuffer( gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphNormal$m" ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal$m" ], 3, gl.FLOAT, false, 0, 0 );

					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ].toDouble();

				} else {

					object.__webglMorphTargetInfluences[ m ] = 0.0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms["morphTargetInfluences"] != null ) {

			_gl.uniform1fv( material.program.uniforms["morphTargetInfluences"], object.__webglMorphTargetInfluences );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupRenderBuffer">
<button class="show-code">Code</button>
dynamic <strong>setupRenderBuffer</strong>(renderbuffer, renderTarget) <a class="anchor-link" href="#setupRenderBuffer"
              title="Permalink to WebGLRenderer.setupRenderBuffer">#</a></h4>
<div class="doc">
<pre class="source">
setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer &amp;&amp; ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( gl.RENDERBUFFER, gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, WebGLRenderingContext.RENDERBUFFER, renderbuffer );
		*/
		} else if( renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( gl.RENDERBUFFER, gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setViewport">
<button class="show-code">Code</button>
dynamic <strong>setViewport</strong>([x = 0, y = 0, width = -1, height = -1]) <a class="anchor-link" href="#setViewport"
              title="Permalink to WebGLRenderer.setViewport">#</a></h4>
<div class="doc">
<pre class="source">
setViewport( [x = 0, y = 0, width = -1, height = -1] ) {

		_viewportX = x;
		_viewportY = y;


		_viewportWidth = (width != -1) ? width : canvas.width;
		_viewportHeight = (height != -1)? height : canvas.height;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="sortFacesByMaterial">
<button class="show-code">Code</button>
dynamic <strong>sortFacesByMaterial</strong>(<a href="../three/WebGLGeometry.html">WebGLGeometry</a> geometry, material) <a class="anchor-link" href="#sortFacesByMaterial"
              title="Permalink to WebGLRenderer.sortFacesByMaterial">#</a></h4>
<div class="doc">
<pre class="source">
sortFacesByMaterial ( WebGLGeometry geometry, material ) {

		var f, fl, face, materialIndex, vertices,
			materialHash, groupHash;

		Map&lt;String, Map&gt; hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var usesFaceMaterial = material is MeshFaceMaterial;

		geometry.geometryGroups = {};

		fl = geometry.faces.length;
		for ( f = 0; f &lt; fl; f ++ ) {

			face = geometry.faces[ f ];
			materialIndex = usesFaceMaterial ? face.materialIndex.toString() : "0";

			if ( hash_map[ materialIndex ] == null ) {

				hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };

			}

			groupHash = "${hash_map[ materialIndex ]["hash"]}_${hash_map[ materialIndex ]["counter"]}";

			if ( geometry.geometryGroups[ groupHash ] == null ) {

				geometry.geometryGroups[ groupHash ] = new WebGLGeometry(faces3: [], faces4: [], materialIndex: int.parse(materialIndex), vertices: 0, numMorphTargets: numMorphTargets, numMorphNormals: numMorphNormals);

			}

			vertices = face.size;

			if ( geometry.geometryGroups[ groupHash ].vertices + vertices &gt; 65535 ) {

				hash_map[ materialIndex ]["counter"] += 1;
				groupHash = "${hash_map[ materialIndex ]["hash"]}_${hash_map[ materialIndex ]["counter"]}";

				if ( geometry.geometryGroups[ groupHash ] == null ) {

					geometry.geometryGroups[ groupHash ] = new WebGLGeometry(faces3: [], faces4: [], materialIndex: int.parse(materialIndex), vertices: 0, numMorphTargets: numMorphTargets, numMorphNormals: numMorphNormals );

				}

			}

			if ( face.size == 3 ) {

				geometry.geometryGroups[ groupHash ].faces3.add( f );

			} else {

				geometry.geometryGroups[ groupHash ].faces4.add( f );

			}

			geometry.geometryGroups[ groupHash ].vertices += vertices;

		}

		geometry.geometryGroupsList = [];

		geometry.geometryGroups.forEach( (k,g) {

    g.id = _geometryGroupCounter ++;

    geometry.geometryGroupsList.add( g );

  });

		return;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="unrollBufferMaterial">
<button class="show-code">Code</button>
dynamic <strong>unrollBufferMaterial</strong>(<a href="../three/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#unrollBufferMaterial"
              title="Permalink to WebGLRenderer.unrollBufferMaterial">#</a></h4>
<div class="doc">
<pre class="source">
unrollBufferMaterial ( WebGLObject object ) {

		WebGLGeometry	buffer = object.buffer;
		WebGLMaterial meshMaterial = object.webglmaterial;
		int materialIndex;
		WebGLMaterial material;


		if ( object.material is MeshFaceMaterial ) {

			materialIndex = buffer.materialIndex;

			if ( materialIndex &gt;= 0 ) {

				material = new WebGLMaterial.from(object.geometry.materials[ materialIndex ]);

				if ( material.transparent ) {

				  object.transparent = material;
				  object.opaque = null;

				} else {

				  object.opaque = material;
				  object.transparent = null;

				}

			}

		} else {

		  material = meshMaterial;

			if ( material != null ) {

				if ( material.transparent != null ) {

				  object.transparent = material;
				  object.opaque = null;

				} else {

				  object.opaque = material;
				  object.transparent = null;

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="unrollImmediateBufferMaterial">
<button class="show-code">Code</button>
dynamic <strong>unrollImmediateBufferMaterial</strong>(<a href="../three/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#unrollImmediateBufferMaterial"
              title="Permalink to WebGLRenderer.unrollImmediateBufferMaterial">#</a></h4>
<div class="doc">
<pre class="source">
unrollImmediateBufferMaterial ( WebGLObject webglobject ) {

		var material = webglobject.webglmaterial;

		if ( material.transparent ) {

		  webglobject.transparent = material;
		  webglobject.opaque = null;

		} else {

		  webglobject.opaque = material;
		  webglobject.transparent = null;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="updateObject">
<button class="show-code">Code</button>
dynamic <strong>updateObject</strong>(<a href="../three/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#updateObject"
              title="Permalink to WebGLRenderer.updateObject">#</a></h4>
<div class="doc">
<pre class="source">
updateObject ( WebGLObject webglobject ) {

  Object3D object = webglobject.object;
		WebGLGeometry geometry = webglobject.webglgeometry, geometryGroup;
		var customAttributesDirty;

		WebGLMaterial material;

		if ( object is Mesh ) {

			if ( object.geometry is BufferGeometry ) {

				if ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {

					setDirectBuffers( geometry, gl.DYNAMIC_DRAW, !geometry.isDynamic );

				}

				geometry.verticesNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

			} else {

				// check all geometry groups

				for( var i = 0, il = geometry.geometryGroupsList.length; i &lt; il; i ++ ) {

					geometryGroup = geometry.geometryGroupsList[ i ];

					material = getBufferMaterial( webglobject, geometryGroup );

					if ( geometry.buffersNeedUpdate ) {

						initMeshBuffers( geometryGroup, webglobject );

					}

					customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

						setMeshBuffers( geometryGroup, webglobject, gl.DYNAMIC_DRAW, !geometry.isDynamic, material );

					}

				}

				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

				geometry.buffersNeedUpdate = false;

				if (material.attributes != null) {
				  clearCustomAttributes( material );
				}

			}

		} else if ( object is Ribbon ) {

			material = getBufferMaterial( webglobject, geometry );

			customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty ) {

				setRibbonBuffers( geometry, gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;

			if (material.attributes != null) {
				clearCustomAttributes( material );
			}

		} else if ( object is Line ) {

			material = getBufferMaterial( webglobject, geometry );

			customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate ||  geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			if (material.attributes != null) clearCustomAttributes( material );

		} else if ( object is ParticleSystem ) {

			if ( geometry is BufferGeometry ) {

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {

					setDirectBuffers( geometry, gl.DYNAMIC_DRAW, !geometry.isDynamic );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

			} else {

				material = getBufferMaterial( webglobject, geometryGroup );

				customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

					setParticleBuffers( geometry, gl.DYNAMIC_DRAW, object );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

				if (material.attributes != null) clearCustomAttributes( material );
			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="updateRenderTargetMipmap">
<button class="show-code">Code</button>
dynamic <strong>updateRenderTargetMipmap</strong>(renderTarget) <a class="anchor-link" href="#updateRenderTargetMipmap"
              title="Permalink to WebGLRenderer.updateRenderTargetMipmap">#</a></h4>
<div class="doc">
<pre class="source">
updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget is WebGLRenderTargetCube ) {

			_gl.bindTexture( gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( gl.TEXTURE_2D );
			_gl.bindTexture( gl.TEXTURE_2D, null );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="updateShadowMap">
<button class="show-code">Code</button>
dynamic <strong>updateShadowMap</strong>(scene, camera) <a class="anchor-link" href="#updateShadowMap"
              title="Permalink to WebGLRenderer.updateShadowMap">#</a></h4>
<div class="doc">
<pre class="source">
updateShadowMap( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		shadowMapPlugin.update( scene, camera );

	}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-11-08 17:35:31.614</div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
